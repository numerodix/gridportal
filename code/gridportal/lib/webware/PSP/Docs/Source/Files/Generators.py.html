<HTML><HEAD><TITLE>PSP/Generators.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE>

<FONT COLOR=#FF0000>"""
    This module holds the classes that generate the python code reulting from the PSP template file.
    As the parser encounters PSP elements, it creates a new Generator object for that type of element.
    Each of these elements is put into a list maintained by the ParseEventHandler object.  When it comes
    time to output the Source Code, each generator is called in turn to create it's source.

    
--------------------------------------------------------------------------------
    (c) Copyright by Jay Love, 2000 (mailto:jsliv@jslove.net)

    Permission to use, copy, modify, and distribute this software and its
    documentation for any purpose and without fee or royalty is hereby granted,
    provided that the above copyright notice appear in all copies and that
    both that copyright notice and this permission notice appear in
    supporting documentation or portions thereof, including modifications,
    that you make.

    THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO
    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
    FITNESS, IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,
    INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
    FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
    NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
    WITH THE USE OR PERFORMANCE OF THIS SOFTWARE !

        This software is based in part on work done by the Jakarta group.

"""</FONT>




<FONT COLOR=black><B>import</B></FONT> PSPUtils
<FONT COLOR=black><B>import</B></FONT> BraceConverter
<FONT COLOR=black><B>try</B></FONT>:
    <FONT COLOR=black><B>import</B></FONT> string
<FONT COLOR=black><B>except</B></FONT>:
    <FONT COLOR=black><B>pass</B></FONT>

<FONT COLOR=black><B>try</B></FONT>:
    <FONT COLOR=black><B>import</B></FONT> os
<FONT COLOR=black><B>except</B></FONT>:
    <FONT COLOR=black><B>pass</B></FONT>

<FONT COLOR=#1111CC>#these are global so that the ParseEventHandler and this module agree.</FONT>
ResponseObject = <FONT COLOR=#FF0000>'res'</FONT>
AwakeCreated = 0


<FONT COLOR=black><B>class</B></FONT> GenericGenerator:
    <FONT COLOR=#FF0000>""" Base class for the generators """</FONT>
    <FONT COLOR=black><B>def</B></FONT> __init__(self, ctxt=None):
        self._ctxt = ctxt
        self.phase=<FONT COLOR=#FF0000>'Service'</FONT>


<FONT COLOR=black><B>class</B></FONT> ExpressionGenerator(GenericGenerator):
    <FONT COLOR=#FF0000>""" This class handles expression blocks.  It simply outputs
    the (hopefully) python expression within the block wrapped
    with a _formatter() call. """</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, chars):
        self.chars = chars
        GenericGenerator.__init__(self)

    <FONT COLOR=black><B>def</B></FONT> generate(self, writer, phase=None):
        writer.println(<FONT COLOR=#FF0000>'res.write(_formatter('</FONT> + PSPUtils.removeQuotes(self.chars) + <FONT COLOR=#FF0000>'))'</FONT>)




<FONT COLOR=black><B>class</B></FONT> CharDataGenerator(GenericGenerator):
    <FONT COLOR=#FF0000>"""This class handles standard character output, mostly HTML.  It just dumps it out.
    Need to handle all the escaping of characters.  It's just skipped for now."""</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, chars):
        GenericGenerator.__init__(self)
        self.chars = chars

    <FONT COLOR=black><B>def</B></FONT> generate(self, writer, phase=None):
        <FONT COLOR=#1111CC># Quote any existing backslash so generated python will not interpret it when running.</FONT>
        self.chars = string.replace(self.chars, <FONT COLOR=#FF0000>'\\'</FONT>, r<FONT COLOR=#FF0000>'\\'</FONT>)

        <FONT COLOR=#1111CC># quote any single quotes so it does not get confused with our triple-quotes</FONT>
        self.chars = string.replace(self.chars,<FONT COLOR=#FF0000>'"'</FONT>,r<FONT COLOR=#FF0000>'\"'</FONT>)

        self.generateChunk(writer)

    <FONT COLOR=black><B>def</B></FONT> generateChunk(self, writer, start=0, stop=None):
        writer.printIndent()<FONT COLOR=#1111CC>#gives a tab</FONT>
        writer.printChars(ResponseObject+<FONT COLOR=#FF0000>'.write("""'</FONT>)
        writer.printChars(self.chars)
        writer.printChars(<FONT COLOR=#FF0000>'""")'</FONT>)
        writer.printChars(<FONT COLOR=#FF0000>'\n'</FONT>)

    <FONT COLOR=black><B>def</B></FONT> mergeData(self, cdGen):
        self.chars = self.chars + cdGen.chars

<FONT COLOR=black><B>class</B></FONT> ScriptGenerator(GenericGenerator):
    <FONT COLOR=#FF0000>"""generates scripts"""</FONT>
    <FONT COLOR=black><B>def</B></FONT> __init__(self, chars, attrs):
        GenericGenerator.__init__(self) 
        self.chars = chars

    <FONT COLOR=black><B>def</B></FONT> generate(self, writer, phase=None):

        <FONT COLOR=black><B>if</B></FONT> writer._useBraces:
            <FONT COLOR=#1111CC># send lines to be output by the braces generator</FONT>
            bc = BraceConverter.BraceConverter()
            <FONT COLOR=black><B>for</B></FONT> line <FONT COLOR=black><B>in</B></FONT> string.splitfields(PSPUtils.removeQuotes(self.chars),<FONT COLOR=#FF0000>'\n'</FONT>):
                bc.parseLine(line,writer)
            <FONT COLOR=black><B>return</B></FONT>


        <FONT COLOR=#1111CC>#check for whitespace at the beginning and if less than 2 spaces, remove</FONT>
        <FONT COLOR=black><B>if</B></FONT> self.chars[:1]==<FONT COLOR=#FF0000>' '</FONT> <FONT COLOR=black><B>and</B></FONT> self.chars[:2]!= <FONT COLOR=#FF0000>'  '</FONT>:
            self.chars=string.lstrip(self.chars)
        lines = string.splitfields(PSPUtils.removeQuotes(self.chars),<FONT COLOR=#FF0000>'\n'</FONT>)
        <FONT COLOR=#1111CC>#writer.printList(string.splitfields(PSPUtils.removeQuotes(self.chars),'\n'))</FONT>
        

        <FONT COLOR=#1111CC>#userIndent check</FONT>
        <FONT COLOR=black><B>if</B></FONT> len(lines[-1])&gt;0 <FONT COLOR=black><B>and</B></FONT> lines[-1][-1] == <FONT COLOR=#FF0000>'$'</FONT>:
            lastline = lines[-1] = lines[-1][:-1]
            <FONT COLOR=black><B>if</B></FONT> lastline == <FONT COLOR=#FF0000>''</FONT>: lastline = lines[-2] <FONT COLOR=#1111CC>#handle endscript marker on its own line</FONT>
            count=0
            <FONT COLOR=black><B>while</B></FONT> lastline[count] <FONT COLOR=black><B>in</B></FONT> string.whitespace:
                count=count+1
            userIndent = lastline[:count]
        <FONT COLOR=black><B>else</B></FONT>:
            userIndent = writer.EMPTY_STRING
            lastline=lines[-1]

        <FONT COLOR=#1111CC>#print </FONT>out code, (moved <FONT COLOR=black><B>from</B></FONT> above)
        writer._userIndent = writer.EMPTY_STRING <FONT COLOR=#1111CC>#reset to none</FONT>
        writer.printList(lines)
        writer.printChars(<FONT COLOR=#FF0000>'\n'</FONT>)

        <FONT COLOR=#1111CC>#check for a block</FONT>
        <FONT COLOR=#1111CC>#lastline = string.splitfields(PSPUtils.removeQuotes(self.chars),'\n')[-1]</FONT>
        commentstart = string.find(lastline,<FONT COLOR=#FF0000>'#'</FONT>)
        <FONT COLOR=black><B>if</B></FONT> commentstart &gt; 0: lastline = lastline[:commentstart]
        blockcheck=string.rstrip(lastline)
        <FONT COLOR=black><B>if</B></FONT> len(blockcheck)&gt;0 <FONT COLOR=black><B>and</B></FONT> blockcheck[-1] == <FONT COLOR=#FF0000>':'</FONT>:
            writer.pushIndent()
            writer.println()
            writer._blockcount = writer._blockcount+1
            <FONT COLOR=#1111CC>#check for end of block, "pass" by itself</FONT>
        <FONT COLOR=black><B>if</B></FONT> string.strip(self.chars) == <FONT COLOR=#FF0000>'pass'</FONT> <FONT COLOR=black><B>and</B></FONT> writer._blockcount&gt;0:
            writer.popIndent()
            writer.println()
            writer._blockcount = writer._blockcount-1

        <FONT COLOR=#1111CC>#set userIndent for subsequent HTML</FONT>
        writer._userIndent = userIndent

<FONT COLOR=black><B>class</B></FONT> EndBlockGenerator(GenericGenerator):
    <FONT COLOR=black><B>def</B></FONT> __init__(self):
        GenericGenerator.__init__(self)

    <FONT COLOR=black><B>def</B></FONT> generate(self, writer, phase=None):
        <FONT COLOR=black><B>if</B></FONT> writer._blockcount&gt;0:
            writer.popIndent()
            writer.println()
            writer._blockcount = writer._blockcount-1
        writer._userIndent = writer.EMPTY_STRING
        
        

<FONT COLOR=black><B>class</B></FONT> MethodGenerator(GenericGenerator):
    <FONT COLOR=#FF0000>""" generates class methods defined in the PSP page.  There are two parts to method generation.  This
    class handles getting the method name and parameters set up."""</FONT>
    <FONT COLOR=black><B>def</B></FONT> __init__(self, chars, attrs):
        GenericGenerator.__init__(self)
        self.phase=<FONT COLOR=#FF0000>'Declarations'</FONT>
        self.attrs=attrs
    
    <FONT COLOR=black><B>def</B></FONT> generate(self, writer, phase=None):
        writer.printIndent()
        writer.printChars(<FONT COLOR=#FF0000>'def '</FONT>)
        writer.printChars(self.attrs[<FONT COLOR=#FF0000>'name'</FONT>])
        writer.printChars(<FONT COLOR=#FF0000>'('</FONT>)
        <FONT COLOR=#1111CC>#self.attrs['params']</FONT>
        writer.printChars(<FONT COLOR=#FF0000>'self'</FONT>)
        <FONT COLOR=black><B>if</B></FONT> self.attrs.has_key(<FONT COLOR=#FF0000>'params'</FONT>) <FONT COLOR=black><B>and</B></FONT> self.attrs[<FONT COLOR=#FF0000>'params'</FONT>] != <FONT COLOR=#FF0000>''</FONT>:
            writer.printChars(<FONT COLOR=#FF0000>', '</FONT>)
            writer.printChars(self.attrs[<FONT COLOR=#FF0000>'params'</FONT>])
        writer.printChars(<FONT COLOR=#FF0000>'):\n'</FONT>)
        <FONT COLOR=black><B>if</B></FONT> self.attrs[<FONT COLOR=#FF0000>'name'</FONT>] == <FONT COLOR=#FF0000>'awake'</FONT>:  <FONT COLOR=#1111CC>#This is hacky, need better method, but it works: MAybe I should require a standard parent and do the intPSP call in that awake???????</FONT>
            AwakeCreated = 1
            <FONT COLOR=#1111CC>#below indented on 6/1/00, was outside if block</FONT>
            writer.pushIndent()
            writer.println(<FONT COLOR=#FF0000>'self.initPSP()\n'</FONT>)
            writer.popIndent()
            writer.println()

<FONT COLOR=black><B>class</B></FONT> MethodEndGenerator(GenericGenerator):
    <FONT COLOR=#FF0000>""" Part of class method generation.  After MethodGenerator, MethodEndGenerator actually generates
    the code for th method body."""</FONT>
    <FONT COLOR=black><B>def</B></FONT> __init__(self, chars, attrs):
        GenericGenerator.__init__(self)
        self.phase=<FONT COLOR=#FF0000>'Declarations'</FONT>
        self.attrs=attrs
        self.chars=chars

    <FONT COLOR=black><B>def</B></FONT> generate(self, writer, phase=None):
        writer.pushIndent()
        writer.printList(string.splitfields(PSPUtils.removeQuotes(self.chars),<FONT COLOR=#FF0000>'\n'</FONT>))
        writer.printChars(<FONT COLOR=#FF0000>'\n'</FONT>)
        writer.popIndent()


<FONT COLOR=black><B>class</B></FONT> IncludeGenerator(GenericGenerator):
    <FONT COLOR=#FF0000>"""
    Handles psp:include directives.  This is a new version of this directive that actually
    forwards the request to the specified page.
    """</FONT>

<FONT COLOR=#1111CC>#   _theFunction = """</FONT>
<FONT COLOR=#1111CC>#__pspincludepath = self.transaction().request().urlPathDir() + "%s"</FONT>
<FONT COLOR=#1111CC>#self.transaction().application().includeURL(self.transaction(), __pspincludepath)</FONT>
    _theFunction = <FONT COLOR=#FF0000>"""
__pspincludepath = "%s"
self.transaction().application().includeURL(self.transaction(), __pspincludepath)
"""</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, attrs, param, ctxt):
        GenericGenerator.__init__(self,ctxt)
        self.attrs = attrs
        self.param = param
        self.scriptgen = None

        self.url = attrs.get(<FONT COLOR=#FF0000>'path'</FONT>)
        <FONT COLOR=black><B>if</B></FONT> self.url == None:
            <FONT COLOR=black><B>raise</B></FONT> <FONT COLOR=#FF0000>"No path attribute in Include"</FONT>
    
        self.scriptgen = ScriptGenerator(self._theFunction % self.url, None)
    

    <FONT COLOR=black><B>def</B></FONT> generate(self, writer, phase=None):
        <FONT COLOR=#FF0000>"""
        Just insert theFunction
        """</FONT>
        self.scriptgen.generate(writer, phase)


<FONT COLOR=black><B>class</B></FONT> InsertGenerator(GenericGenerator):
    <FONT COLOR=#FF0000>""" Include files designated by the psp:insert syntax.
    If the attribute static is set to true or 1, we include the file now, at compile time.
    Otherwise, we use a function added to every PSP page named __includeFile, which reads the file at run time.
    """</FONT>
    <FONT COLOR=black><B>def</B></FONT> __init__(self, attrs, param, ctxt):
        GenericGenerator.__init__(self,ctxt)
        self.attrs = attrs
        self.param = param
        self.static=1
        self.scriptgen = None

        self.page = attrs.get(<FONT COLOR=#FF0000>'file'</FONT>)
        <FONT COLOR=black><B>if</B></FONT> self.page == None:
            <FONT COLOR=black><B>raise</B></FONT> <FONT COLOR=#FF0000>"No Page attribute in Include"</FONT>
        thepath=self._ctxt.resolveRelativeURI(self.page)


        self.static = attrs.get(<FONT COLOR=#FF0000>'static'</FONT>, None)
        <FONT COLOR=black><B>if</B></FONT> self.static == string.lower(<FONT COLOR=#FF0000>"true"</FONT>) <FONT COLOR=black><B>or</B></FONT> self.static == <FONT COLOR=#FF0000>"1"</FONT>:
            self.static=1
    
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> os.path.exists(thepath):
            <FONT COLOR=black><B>print</B></FONT> self.page
            <FONT COLOR=black><B>raise</B></FONT> <FONT COLOR=#FF0000>"Invalid included file"</FONT>,thepath
        self.page=thepath

        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self.static:
            self.scriptgen = ScriptGenerator(<FONT COLOR=#FF0000>"self.__includeFile('%s')"</FONT> % string.replace(thepath, <FONT COLOR=#FF0000>'\\'</FONT>, <FONT COLOR=#FF0000>'\\\\'</FONT>), None)

    <FONT COLOR=black><B>def</B></FONT> generate(self, writer, phase=None):
        <FONT COLOR=#FF0000>""" JSP does this in the servlet.  I'm doing it here because I have triple quotes.
        Note: res.write statements inflate the size of the resulting classfile when it is cached.
        Cut down on those by using a single res.write on the whole file, after escaping any triple-double quotes."""</FONT>

        <FONT COLOR=black><B>if</B></FONT> self.static:
            data = open(self.page).read()
            data=string.replace(data,<FONT COLOR=#FF0000>'"""'</FONT>,r<FONT COLOR=#FF0000>'\"""'</FONT>)
            writer.println(<FONT COLOR=#FF0000>'res.write("""'</FONT>+data+<FONT COLOR=#FF0000>'""")'</FONT>)
            writer.println()
        <FONT COLOR=black><B>else</B></FONT>:
            self.scriptgen.generate(writer, phase)
            
        

</PRE>
                  <!--footer-->
                  </BODY>
