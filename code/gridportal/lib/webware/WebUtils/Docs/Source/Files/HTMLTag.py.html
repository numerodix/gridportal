<HTML><HEAD><TITLE>WebUtils/HTMLTag.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=#FF0000>"""
HTMLTag defines a class of the same name that represents HTML content. An
additional HTMLReader class kicks off the process of reading an HTML file into a
set of tags:

    from WebUtils.HTMLTag import HTMLReader
    reader = HTMLReader()
    tag = reader.readFileNamed('foo.html')
    tag.pprint()

Tags have attributes and children, which makes them hierarchical. See HTMLTag
class docs for more info.

Note that you imported HTMLReader instead of HTMLTag. You only need the latter
if you plan on creating tags directly.

You can discard the reader immediately if you like:

    tag = HTMLReader().readFileNamed('foo.html')

The point of reading HTML into tab objects is so that you have a concrete,
Pythonic data structure to work with. The original motiviation for such a beast
was in building automated regression test suites that wanted granular,
structured access to the HTML output by the web application.

See the doc string for HTMLTag for examples of what you can do with tags.


CAVEATS

* HTMLReader needs special attention with regards to tags like &lt;p&gt; and &lt;li&gt;
which sometimes are closed (&lt;/p&gt; &lt;/li&gt;) and sometimes not. See its doc string
for full information.

* HTMLReader is picky about the correctness of the HTML you feed it. Again see
the class docs for full info.


TO DO

* See the TO DO sections for each class.


CREDITS

* I didn't grok how to write an SGMLParser subclass until I read the very small
example by Sean McGrath at http://www.digitome.com/html2pyx.py (which I believe
is broken for empty tags).

* Determined what HTML tags are empty by scanning O'Reilly's HTML Pocket
Reference.
"""</FONT>

<FONT COLOR=#1111CC># - report line numbers for errors</FONT>
<FONT COLOR=#1111CC># - extra checking about what tags are allowed or disallowed inside other tags</FONT>
<FONT COLOR=#1111CC># - minor tweaks</FONT>


<FONT COLOR=#1111CC># Check for Python 2.0</FONT>
<FONT COLOR=black><B>import</B></FONT> sys
pyVer = getattr(sys, <FONT COLOR=#FF0000>'version_info'</FONT>, None)
<FONT COLOR=black><B>if</B></FONT> pyVer <FONT COLOR=black><B>is</B></FONT> None  <FONT COLOR=black><B>or</B></FONT>  pyVer[0]&lt;2:
    <FONT COLOR=black><B>raise</B></FONT> Exception, <FONT COLOR=#FF0000>'HTMLTag requires Python 2.0 or greater.'</FONT>


runFast = 1
    <FONT COLOR=#1111CC># if enabled, overrides some key SGMLParser methods for more speed.</FONT>
    <FONT COLOR=#1111CC># changing this has no effect once the module is imported (unless you reload())</FONT>


<FONT COLOR=black><B>from</B></FONT> sgmllib <FONT COLOR=black><B>import</B></FONT> SGMLParser
<FONT COLOR=black><B>from</B></FONT> MiscUtils <FONT COLOR=black><B>import</B></FONT> NoDefault
<FONT COLOR=black><B>import</B></FONT> types
<FONT COLOR=black><B>from</B></FONT> types <FONT COLOR=black><B>import</B></FONT> StringType


<FONT COLOR=black><B>class</B></FONT> HTMLTagError(Exception):

    <FONT COLOR=black><B>def</B></FONT> __init__(self, msg, **values):
        Exception.__init__(self, msg)
        self.values = values.copy()

<FONT COLOR=black><B>class</B></FONT> HTMLTagAttrLookupError(HTMLTagError, LookupError): <FONT COLOR=black><B>pass</B></FONT>
<FONT COLOR=black><B>class</B></FONT> HTMLTagUnbalancedError(HTMLTagError): <FONT COLOR=black><B>pass</B></FONT>
<FONT COLOR=black><B>class</B></FONT> HTMLNotAllowedError(HTMLTagError): <FONT COLOR=black><B>pass</B></FONT>
<FONT COLOR=black><B>class</B></FONT> HTMLTagProcessingInstructionError(HTMLTagError): <FONT COLOR=black><B>pass</B></FONT>
<FONT COLOR=black><B>class</B></FONT> HTMLTagIncompleteError(HTMLTagError): <FONT COLOR=black><B>pass</B></FONT>


DefaultEmptyTags = <FONT COLOR=#FF0000>'area basefont base bgsound br col colgroup frame hr img input isindex link meta spacer wbr'</FONT>.split()


<FONT COLOR=black><B>class</B></FONT> HTMLTag:
    <FONT COLOR=#FF0000>"""
    Tags essentially have 4 major attributes:
        * name
        * attributes
        * children
        * subtags

    Name is simple:
        print tag.name()

    Attributes are dictionary-like in nature:
        print tag.attr('color')  # throws an exception if no color
        print tag.attr('bgcolor', None)  # returns none if no bgcolor
        print tag.attrs()

    Children are all the leaf parts of a tag, consisting of other tags and strings
    of character data.
        print tag.numChildren()
        print tag.childAt(0)
        print tag.children()

    Subtags is a convenient list of only the tags in the children:
        print tag.numSubtags()
        print tag.subtagAT(0)
        print tag.subtags()

    You can search a tag and all the tags it contains for a tag with a particular
    attribute matching a particular value:
        print tag.tagWithMatchingAttr('width', '100%')

    An HTMLTagAttrLookupError is raised if no matching tag is found. You can avoid
    this by providing a default value:
        print tag.tagWithMatchingAttr('width', '100%', None)

    Looking for specific 'id' attributes is common in regression testing (it allows
    you to zero in on logical portions of a page), so a convenience method is
    provided:
        tag = htmlTag.tagWithId('accountTable')


    TO DO

    * A walker() method for traversing the tag tree.
    * Search for a subtag with a given name, recursive or not.
    * Attribute traversal with dotted notation?
    * Do we need to convert tag names and attribute names to lower case, or does
      SGMLParser already do that?
    * Should attribute values be strip()ed?
      Probably not. SGMLParser probably strips them already unless they really do
      have spaces as in "  quoted  ". But that's speculation.
    """</FONT>

    <FONT COLOR=#1111CC>## Init and reading ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, name):
        <FONT COLOR=black><B>assert</B></FONT> <FONT COLOR=#FF0000>'\n'</FONT> <FONT COLOR=black><B>not</B></FONT> <FONT COLOR=black><B>in</B></FONT> name
        self._name = name
        self._attrs = {}
        self._children = []
        self._subtags = []

    <FONT COLOR=black><B>def</B></FONT> readAttr(self, name, value):
        <FONT COLOR=#FF0000>"""
        Sets an attribute of the tag with the given name and value. An assertion
        fails if an attribute is set twice.
        """</FONT>
        <FONT COLOR=black><B>assert</B></FONT> <FONT COLOR=black><B>not</B></FONT> self._attrs.has_key(name), <FONT COLOR=#FF0000>'name = %r, attrs = %r'</FONT> % (name, attrs)
        self._attrs[name] = value

    <FONT COLOR=black><B>def</B></FONT> addChild(self, child):
        <FONT COLOR=#FF0000>"""
        Adds a child to the receiver. The child will be another tag or a string
        (CDATA).
        """</FONT>
        <FONT COLOR=black><B>assert</B></FONT> isinstance(child, HTMLTag) <FONT COLOR=black><B>or</B></FONT> type(child) <FONT COLOR=black><B>is</B></FONT> types.StringType, \
            <FONT COLOR=#FF0000>'Invalid child: %r'</FONT> % child
        self._children.append(child)
        <FONT COLOR=black><B>if</B></FONT> isinstance(child, HTMLTag):
            self._subtags.append(child)


    <FONT COLOR=#1111CC>## Access ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> name(self):
        <FONT COLOR=black><B>return</B></FONT> self._name

    <FONT COLOR=black><B>def</B></FONT> attr(self, name, default=NoDefault):
        <FONT COLOR=black><B>if</B></FONT> default <FONT COLOR=black><B>is</B></FONT> NoDefault:
            <FONT COLOR=black><B>return</B></FONT> self._attrs[name]
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> self._attrs.get(name, default)

    <FONT COLOR=black><B>def</B></FONT> hasAttr(self, name):
        <FONT COLOR=black><B>return</B></FONT> self._attrs.has_key(name)

    <FONT COLOR=black><B>def</B></FONT> attrs(self):
        <FONT COLOR=black><B>return</B></FONT> self._attrs

    <FONT COLOR=black><B>def</B></FONT> numAttrs(self):
        <FONT COLOR=black><B>return</B></FONT> len(self._attrs)

    <FONT COLOR=black><B>def</B></FONT> childAt(self, index):
        <FONT COLOR=black><B>return</B></FONT> self._children[index]

    <FONT COLOR=black><B>def</B></FONT> numChildren(self):
        <FONT COLOR=black><B>return</B></FONT> len(self._children)

    <FONT COLOR=black><B>def</B></FONT> children(self):
        <FONT COLOR=black><B>return</B></FONT> self._children

    <FONT COLOR=black><B>def</B></FONT> subtagAt(self, index):
        <FONT COLOR=black><B>return</B></FONT> self._subtags[index]

    <FONT COLOR=black><B>def</B></FONT> numSubtags(self):
        <FONT COLOR=black><B>return</B></FONT> len(self._subtags)

    <FONT COLOR=black><B>def</B></FONT> subtags(self):
        <FONT COLOR=black><B>return</B></FONT> self._subtags


    <FONT COLOR=#1111CC>## Printing ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> pprint(self, out=None, indent=0):
        <FONT COLOR=black><B>if</B></FONT> out <FONT COLOR=black><B>is</B></FONT> None:
            out = sys.stdout
        wr = out.write
        spacer = <FONT COLOR=#FF0000>' '</FONT>*4*indent
        wr(<FONT COLOR=#FF0000>'%s&lt;%s&gt;\n'</FONT> % (spacer, self._name))
        <FONT COLOR=black><B>for</B></FONT> key, value <FONT COLOR=black><B>in</B></FONT> self._attrs.items():
            wr(<FONT COLOR=#FF0000>'%s  %s = %s\n'</FONT> % (spacer, key.ljust(12), value))
        indent = indent+1
        <FONT COLOR=black><B>for</B></FONT> child <FONT COLOR=black><B>in</B></FONT> self._children:
            <FONT COLOR=black><B>if</B></FONT> isinstance(child, HTMLTag):
                child.pprint(out, indent)
            <FONT COLOR=black><B>else</B></FONT>:
                wr(<FONT COLOR=#FF0000>'%s    %s\n'</FONT> % (spacer, child))
        wr(<FONT COLOR=#FF0000>'%s&lt;/%s&gt;\n'</FONT> % (spacer, self._name))
        <FONT COLOR=#1111CC># ^^^</FONT>
        <FONT COLOR=#1111CC># Printing a closing tag for an empty tag (such as &lt;br&gt;)</FONT>
        <FONT COLOR=#1111CC># doesn't make much sense, but then it's a good reminder that</FONT>
        <FONT COLOR=#1111CC># certain tags like &lt;p&gt; are closed immediately.</FONT>

    <FONT COLOR=black><B>def</B></FONT> __repr__(self):
        <FONT COLOR=#1111CC>#return </FONT><FONT COLOR=#FF0000>'&lt;%s, %i attrs, %i children&gt;'</FONT> % (self._name, len(self._attrs),
        <FONT COLOR=#1111CC>#len(self._children))</FONT>
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>'&lt;%s&gt;'</FONT> % self._name


    <FONT COLOR=#1111CC>## Searching ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> tagWithMatchingAttr(self, name, value, default=NoDefault):
        <FONT COLOR=#FF0000>"""
        Performs a depth-first search for a tag with an attribute that matches the
        given value. If the tag cannot be found, a KeyError will be raised *unless* a
        default value was specified, which is then returned.
            tag = tag.tagWithMatchingAttr('bgcolor', '#FFFF', None)
        """</FONT>
        tag = self._tagWithMatchingAttr(name, value)
        <FONT COLOR=black><B>if</B></FONT> tag <FONT COLOR=black><B>is</B></FONT> None:
            <FONT COLOR=black><B>if</B></FONT> default <FONT COLOR=black><B>is</B></FONT> NoDefault:
                <FONT COLOR=black><B>raise</B></FONT> HTMLTagAttrLookupError(<FONT COLOR=#FF0000>'name = %r, value = %r'</FONT> % (name, value), name=name, value=value)
            <FONT COLOR=black><B>else</B></FONT>:
                <FONT COLOR=black><B>return</B></FONT> default
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> tag


    <FONT COLOR=black><B>def</B></FONT> tagWithId(self, id, default=NoDefault):
        <FONT COLOR=#FF0000>"""
        Finds and returns the tag with the given id. As in:
            &lt;td id=foo&gt; bar &lt;/td&gt;
        This is just a cover for:
            tagWithMatchingAttr('id', id, default)
        But searching for id's is so popular (at least in regression testing web
        sites) that this convenience method is provided.
        Why is it so popular? Because by attaching ids to logical portions of your
        HTML, your regression test suite can quickly zero in on them for examination.
        """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self.tagWithMatchingAttr(<FONT COLOR=#FF0000>'id'</FONT>, id, default)


    <FONT COLOR=#1111CC>## Self utility ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> _tagWithMatchingAttr(self, name, value):
        <FONT COLOR=#FF0000>"""
        Performs a depth-first search for a tag with an attribute that matches the
        given value. Returns None if the tag cannot be found.
        The method tagWithMatchingAttr() (e.g., sans underscore) is more commonly
        used.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> self._attrs.get(name, None)==value:
            <FONT COLOR=black><B>return</B></FONT> self
        <FONT COLOR=black><B>for</B></FONT> tag <FONT COLOR=black><B>in</B></FONT> self._subtags:
            matchingTag = tag._tagWithMatchingAttr(name, value)
            <FONT COLOR=black><B>if</B></FONT> matchingTag:
                <FONT COLOR=black><B>return</B></FONT> matchingTag
        <FONT COLOR=black><B>return</B></FONT> None


<FONT COLOR=black><B>class</B></FONT> HTMLReader(SGMLParser):
    <FONT COLOR=#FF0000>"""
    NOTES

    * Special attention is required regarding tags like &lt;p&gt; and &lt;li&gt; which
      sometimes are closed and sometimes not. HTMLReader can deal with both situations
      (closed and not) provided that:
        * the file doesn't change conventions for a given tag
        * the reader knows ahead of time what to expect

    Be default, HTMLReader assumes that &lt;p&gt; and &lt;li&gt; will be closed with &lt;/p&gt; and
    &lt;/li&gt; as the official HTML spec, as well as upcomer XHTML, encourage or require,
    respectively.

    But if your files don't close certain tags that are supposed to be required,
    you can do this:
        HTMLReader(extraEmptyTags=['p', 'li'])
    or:
        reader.extendEmptyTags(['p', 'li'])

    Or just set them entirely:
        HTMLReader(emptyTags=['br', 'hr', 'p'])
        reader.setEmptyTags(['br', 'hr', 'p'])
    Although there are quite a few. Consider the DefaultEmptyTags global list
    (which is used to initialize the reader's tags) which contains about 16 tag
    names.

    If an HTML file doesn't conform to the reader's expectation, you will get an
    except (see more below for details).

    If your HTML file doesn't contain root &lt;html&gt; ... &lt;/html&gt; tags wrapping
    everything, a fake root tag will be constructed for you, unless you pass
    in fakeRootTagIfNeeded=0.

    Besides fixing your reader manually, you could conceivably loop through the
    permutations of the various empty tags to see if one of them resulted in a
    correct read.

    Or you could fix the HTML.

    * The reader ignores extra preceding and trailing whitespace by stripping it
      from strings. I suppose this is a little harsher than reducing spans of
      preceding and trailing whitespace down to one space, which is what really
      happens in an HTML browser.

    * The reader will not read past the closing &lt;/html&gt; tag.

    * The reader is picky about the correctness of the HTML you feed it. If tags
      are not closed, overlap (instead of nest) or left unfinished, an exception is
      thrown. These include HTMLTagUnbalancedError, HTMLTagIncompleteError and
      HTMLNotAllowedError which all inherit HTMLTagError.

      This pickiness can be quite useful for the validation of the HTML of your
      own applications.

      I believe it is possible that others kinds of HTML errors could raise
      exceptions from sgmlib.SGMLParser (from which HTMLReader inherits),
      although in practice, I have not seen them.


    TO DO

    * Could the "empty" tag issue be dealt with more sophistication by
      automatically closing &lt;p&gt; and &lt;li&gt; (e.g., popping them off the _tagStack) when
      other major tags were encountered such as &lt;p&gt;, &lt;li&gt;, &lt;table&gt;, &lt;center&gt;, etc.?

    * Readers don't handle processing instructions: &lt;? foobar ?&gt;.

    * The tagContainmentConfig class var can certainly be expanded for even better
      validation.
    """</FONT>

    <FONT COLOR=#1111CC>## Init ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, emptyTags=None, extraEmptyTags=None, fakeRootTagIfNeeded=1):
        SGMLParser.__init__(self)
        self._filename  = None
        self._rootTag   = None
        self._fakeRootTagIfNeeded = fakeRootTagIfNeeded
        self._usedFakeRootTag = 0
        self._tagStack  = []
        self._finished  = 0

        <FONT COLOR=#1111CC># Options</FONT>
        self._printsStack = 0
        self._ignoreWS   = 1
        self._endingTag  = <FONT COLOR=#FF0000>'html'</FONT>

        <FONT COLOR=#1111CC># Handle optional args</FONT>
        <FONT COLOR=black><B>if</B></FONT> emptyTags <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None:
            self.setEmptyTags(emptyTags)
        <FONT COLOR=black><B>else</B></FONT>:
            self.setEmptyTags(DefaultEmptyTags)
        <FONT COLOR=black><B>if</B></FONT> extraEmptyTags <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None:
            self.extendEmptyTags(extraEmptyTags)


    <FONT COLOR=#1111CC>## Reading ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> readFileNamed(self, filename, retainRootTag=1):
        <FONT COLOR=#FF0000>"""
        Reads the given file. Relies on readString(). See that method for more
        information.
        """</FONT>
        self._filename = filename
        contents = open(filename).read()
        <FONT COLOR=black><B>return</B></FONT> self.readString(contents, retainRootTag)

    <FONT COLOR=black><B>def</B></FONT> readString(self, string, retainRootTag=1):
        <FONT COLOR=#FF0000>"""
        Reads the given string, storing the results and returning the root tag. You
        could continue to use HTMLReader object or disregard it and simply use the root
        tag.
        """</FONT>
        self._rootTag  = None
        self._tagStack = []
        self._finished = 0
        self.reset()
        self._lineNumber = 1
        self.computeTagContainmentConfig()
        <FONT COLOR=black><B>try</B></FONT>:
            <FONT COLOR=black><B>for</B></FONT> line <FONT COLOR=black><B>in</B></FONT> string.split(<FONT COLOR=#FF0000>'\n'</FONT>):
                self.feed(line+<FONT COLOR=#FF0000>'\n'</FONT>)
                self._lineNumber += 1
            self.close()
        <FONT COLOR=black><B>finally</B></FONT>:
            self.reset()
        <FONT COLOR=black><B>if</B></FONT> retainRootTag:
            <FONT COLOR=black><B>return</B></FONT> self._rootTag
        <FONT COLOR=black><B>else</B></FONT>:
            tag = self._rootTag
            self._rootTag = None
            <FONT COLOR=black><B>return</B></FONT> tag


    <FONT COLOR=#1111CC>## Printing ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> pprint(self, out=None):
        <FONT COLOR=#FF0000>"""
        Pretty prints the tag, its attributes and all its children.
        Indentation is used for subtags.
        Print 'Empty.' if there is no root tag.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> self._rootTag:
            self._rootTag.pprint(out)
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>if</B></FONT> out <FONT COLOR=black><B>is</B></FONT> None:
                out = sys.stdout
            out.write(<FONT COLOR=#FF0000>'Empty.'</FONT>)


    <FONT COLOR=#1111CC>## Access ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> rootTag(self):
        <FONT COLOR=#FF0000>"""
        Returns the root tag. May return None if no HTML has been read yet, or if the
        last invocation of one of the read methods was passed retainRootTag=0.
        """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._rootTag

    <FONT COLOR=black><B>def</B></FONT> filename(self):
        <FONT COLOR=#FF0000>"""
        Returns the filename that was read, or None if no file was processed.
        """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._filename

    <FONT COLOR=black><B>def</B></FONT> emptyTags(self):
        <FONT COLOR=#FF0000>"""
        Returns a list of empty tags. See also: class docs and setEmptyTags().
        """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._emptyTagList

    <FONT COLOR=black><B>def</B></FONT> setEmptyTags(self, tagList):
        <FONT COLOR=#FF0000>"""
        Sets the HTML tags that are considered empty such as &lt;br&gt; and &lt;hr&gt;.
        The default is found in the global, DefaultEmptyTags, and is fairly thorough,
        but does not include &lt;p&gt;, &lt;li&gt; and some other tags that HTML authors often use
        as empty tags.
        """</FONT>
        self._emptyTagList = list(tagList)
        self._updateEmptyTagDict()

    <FONT COLOR=black><B>def</B></FONT> extendEmptyTags(self, tagList):
        <FONT COLOR=#FF0000>"""
        Extends the current list of empty tags with the given list.
        """</FONT>
        self._emptyTagList.extend(tagList)
        self._updateEmptyTagDict()


    <FONT COLOR=#1111CC>## Debugging ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> printsStack(self):
        <FONT COLOR=black><B>return</B></FONT> self._printsStack

    <FONT COLOR=black><B>def</B></FONT> setPrintsStack(self, flag):
        <FONT COLOR=#FF0000>"""
        Sets the boolean value of the "prints stack" option. This is a debugging
        option which will print the internal tag stack during HTML processing. The
        default value is 0.
        """</FONT>
        self._printsStack = flag


    <FONT COLOR=#1111CC>## Command line ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> main(self, args=None):
        <FONT COLOR=#FF0000>"""
        The command line equivalent of readFileNamed().
        Invoked when HTMLTag is run as a program.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> args <FONT COLOR=black><B>is</B></FONT> None:
            args = sys.argv
        <FONT COLOR=black><B>if</B></FONT> len(args)&lt;2:
            self.usage()
        <FONT COLOR=black><B>return</B></FONT> self.readFileNamed(args[1])

    <FONT COLOR=black><B>def</B></FONT> usage(self):
        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'HTMLTag: usage:  HTMLTag &lt;html file&gt;'</FONT>
        sys.exit(1)


    <FONT COLOR=#1111CC>## SGMLParser handlers ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> handle_data(self, data):
        <FONT COLOR=black><B>if</B></FONT> self._finished:
            <FONT COLOR=black><B>return</B></FONT>
        <FONT COLOR=black><B>assert</B></FONT> type(data) <FONT COLOR=black><B>is</B></FONT> types.StringType
        <FONT COLOR=black><B>if</B></FONT> self._ignoreWS:
            data = data.strip()
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> data:
                <FONT COLOR=black><B>return</B></FONT>
        self._tagStack[-1].addChild(data)

    <FONT COLOR=black><B>def</B></FONT> handle_pi(self, data):
        <FONT COLOR=black><B>raise</B></FONT> HTMLTagProcessingInstructionError, <FONT COLOR=#FF0000>'Was not expecting a processing instruction: %r'</FONT> % data

    <FONT COLOR=black><B>def</B></FONT> unknown_starttag(self, name, attrs):
        <FONT COLOR=black><B>if</B></FONT> self._finished:
            <FONT COLOR=black><B>return</B></FONT>
        tag = HTMLTag(name)
        <FONT COLOR=black><B>for</B></FONT> attrName, value <FONT COLOR=black><B>in</B></FONT> attrs:
            tag.readAttr(attrName, value)
        <FONT COLOR=black><B>if</B></FONT> self._emptyTagDict.has_key(name):
            <FONT COLOR=#1111CC># We'll never have any children. Boo hoo.</FONT>
            <FONT COLOR=black><B>assert</B></FONT> self._rootTag, <FONT COLOR=#FF0000>'Cannot start HTML with an empty tag: %r'</FONT> % tag
            self._tagStack[-1].addChild(tag)
            empty = 1
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=#1111CC># We could have children, so we go on the stack</FONT>
            <FONT COLOR=#1111CC># Also, if this is the first tag, then make it the root.</FONT>
            <FONT COLOR=#1111CC># If it's the first tag and it isn't an &lt;html&gt; tag,</FONT>
            <FONT COLOR=#1111CC># create a fake "container" html tag.</FONT>
            <FONT COLOR=black><B>if</B></FONT> self._tagStack:
                lastTag = self._tagStack[-1]
                <FONT COLOR=#1111CC># is this legal?</FONT>
                tagConfig = self._tagContainmentConfig.get(lastTag.name())
                <FONT COLOR=black><B>if</B></FONT> tagConfig:
                    tagConfig.encounteredTag(name, self._lineNumber)
                <FONT COLOR=#1111CC># tell last tag about his new child</FONT>
                lastTag.addChild(tag)
            <FONT COLOR=black><B>elif</B></FONT> name != <FONT COLOR=#FF0000>'html'</FONT> <FONT COLOR=black><B>and</B></FONT> self._fakeRootTagIfNeeded:
                self._rootTag = HTMLTag(<FONT COLOR=#FF0000>'html'</FONT>)
                self._tagStack.append(self._rootTag)
                self._tagStack[-1].addChild(tag)
                self._usedFakeRootTag = 1
            <FONT COLOR=black><B>else</B></FONT>:
                self._rootTag = tag
            self._tagStack.append(tag)
            empty = 0
        <FONT COLOR=black><B>if</B></FONT> self._printsStack:
            prefix = (<FONT COLOR=#FF0000>'START'</FONT>, <FONT COLOR=#FF0000>'-----'</FONT>)[empty]
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'%s %s: %r'</FONT> % (prefix, name.ljust(6), self._tagStack)

    <FONT COLOR=black><B>def</B></FONT> unknown_endtag(self, name):
        <FONT COLOR=black><B>if</B></FONT> self._finished:
            <FONT COLOR=black><B>return</B></FONT>
        <FONT COLOR=black><B>if</B></FONT> name==self._endingTag:
            self._finished = 1
        openingTag = self._tagStack.pop()
        <FONT COLOR=black><B>if</B></FONT> self._printsStack:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'END   %s: %r'</FONT> % (name.ljust(6), self._tagStack)
        <FONT COLOR=black><B>if</B></FONT> openingTag.name()!=name:
            <FONT COLOR=black><B>raise</B></FONT> HTMLTagUnbalancedError(<FONT COLOR=#FF0000>'line %i: opening is %r, but closing is %r'</FONT> % \
                (self._lineNumber, openingTag.name(), name), line=self._lineNumber, opening=openingTag.name(), closing=name)

    <FONT COLOR=black><B>def</B></FONT> close(self):
        <FONT COLOR=black><B>if</B></FONT> len(self._tagStack)&gt;0 <FONT COLOR=black><B>and</B></FONT> <FONT COLOR=black><B>not</B></FONT> (len(self._tagStack)==1 <FONT COLOR=black><B>and</B></FONT> self._usedFakeRootTag):
            <FONT COLOR=black><B>raise</B></FONT> HTMLTagIncompleteError(<FONT COLOR=#FF0000>'line %i: tagStack = %r'</FONT> % (self._lineNumber, self._tagStack), line=self._lineNumber, tagStack=repr(self._tagStack))
        SGMLParser.close(self)


    <FONT COLOR=#1111CC>## Self utility ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> _updateEmptyTagDict(self):
        <FONT COLOR=#FF0000>"""
        Creates a dictionary out of the empty tag list for quick look up. e.g., we are
        simulating a "set".
        """</FONT>
        dict = {}
        <FONT COLOR=black><B>for</B></FONT> tag <FONT COLOR=black><B>in</B></FONT> self._emptyTagList:
            dict[tag] = 1
        self._emptyTagDict = dict

    <FONT COLOR=#1111CC># The following dict defines for various tags either:</FONT>
    <FONT COLOR=#1111CC>#    + the complete set of tags that can be contained within</FONT>
    <FONT COLOR=#1111CC>#    - a set of tags that cannot be contained within</FONT>
    <FONT COLOR=#1111CC># This information helps HTMLReader detect some types of errors</FONT>
    <FONT COLOR=#1111CC># earlier and other types of errors, it would never detect.</FONT>
    tagContainmentConfig = {
        <FONT COLOR=#FF0000>'html'</FONT>:   <FONT COLOR=#FF0000>'canOnlyHave head body'</FONT>,
        <FONT COLOR=#FF0000>'head'</FONT>:   <FONT COLOR=#FF0000>'cannotHave  html head body'</FONT>,
        <FONT COLOR=#FF0000>'body'</FONT>:   <FONT COLOR=#FF0000>'cannotHave  html head body'</FONT>,
        <FONT COLOR=#FF0000>'table'</FONT>:  <FONT COLOR=#FF0000>'canOnlyHave tr thead tbody tfoot a'</FONT>,  <FONT COLOR=#1111CC># a because in IE you can wrap a row in &lt;a&gt; to make the entire row clickable</FONT>
        <FONT COLOR=#FF0000>'tr'</FONT>:     <FONT COLOR=#FF0000>'canOnlyHave th td'</FONT>,
        <FONT COLOR=#FF0000>'td'</FONT>:     <FONT COLOR=#FF0000>'cannotHave  td tr'</FONT>,
        <FONT COLOR=#FF0000>'select'</FONT>: <FONT COLOR=#FF0000>'canOnlyHave option'</FONT>,
    }

    <FONT COLOR=black><B>def</B></FONT> computeTagContainmentConfig(self):
        config = {}
        <FONT COLOR=black><B>for</B></FONT> key, value <FONT COLOR=black><B>in</B></FONT> self.tagContainmentConfig.items():
            <FONT COLOR=black><B>if</B></FONT> isinstance(value, StringType):
                value = value.split()
                configClass = configClassForName.get(value[0])
                <FONT COLOR=black><B>if</B></FONT> configClass <FONT COLOR=black><B>is</B></FONT> None:
                    <FONT COLOR=black><B>raise</B></FONT> KeyError, <FONT COLOR=#FF0000>'Unknown config name %r for value %r in %s.tagContainmentConfig'</FONT> % (key, value, self.__class__.__name__)
                config[key] = configClass(key, value[1:])
            <FONT COLOR=black><B>else</B></FONT>:
                <FONT COLOR=black><B>assert</B></FONT> isinstance(value, TagConfig), <FONT COLOR=#FF0000>'key=%r, value=%r'</FONT> % (key, value)
                config[key] = value
        self._tagContainmentConfig = config


    <FONT COLOR=#1111CC>## Optimizations ##</FONT>

    <FONT COLOR=black><B>if</B></FONT> runFast:
        finish_starttag = unknown_starttag
        finish_endtag = unknown_endtag


<FONT COLOR=black><B>class</B></FONT> TagConfig:

    <FONT COLOR=black><B>def</B></FONT> __init__(self, name, tags):
        self.name = name
        <FONT COLOR=#1111CC># turn list of tags into a dict/set for fast lookup (e.g., avoid linear searches)</FONT>
        dict = {}
        <FONT COLOR=black><B>for</B></FONT> tag <FONT COLOR=black><B>in</B></FONT> tags:
            dict[tag] = 1
        self.tags = dict

    <FONT COLOR=black><B>def</B></FONT> encounteredTag(self, tag, lineNum):
        <FONT COLOR=black><B>raise</B></FONT> SubclassResponsiblityError, self.__class__


<FONT COLOR=black><B>class</B></FONT> TagCanOnlyHaveConfig(TagConfig):

    <FONT COLOR=black><B>def</B></FONT> encounteredTag(self, tag, lineNum):
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self.tags.has_key(tag.lower()):
            <FONT COLOR=black><B>raise</B></FONT> HTMLNotAllowedError(<FONT COLOR=#FF0000>'line %i: the tag %r is not allowed in %r which can only have %r.'</FONT> % (
                lineNum, tag, self.name, self.tags.keys()), line=lineNum, encounteredTag=tag, containingTag=self.name, canOnlyHave=self.tags.keys())


<FONT COLOR=black><B>class</B></FONT> TagCannotHaveConfig(TagConfig):

    <FONT COLOR=black><B>def</B></FONT> encounteredTag(self, tag, lineNum):
        <FONT COLOR=black><B>if</B></FONT> self.tags.has_key(tag.lower()):
            <FONT COLOR=black><B>raise</B></FONT> HTMLNotAllowedError(<FONT COLOR=#FF0000>'line %i: The tag %r is not allowed in %r which cannot have %r.'</FONT> % (
                lineNum, tag, self.name, self.tags.keys()), line=lineNum, enounteredTag=tag, containingTag=self.name, cannotHave=self.tags.keys())


configClassForName = {
    <FONT COLOR=#FF0000>'canOnlyHave'</FONT>:   TagCanOnlyHaveConfig,
    <FONT COLOR=#FF0000>'cannotHave'</FONT>: TagCannotHaveConfig,
}


<FONT COLOR=black><B>if</B></FONT> __name__==<FONT COLOR=#FF0000>'__main__'</FONT>:
    html = HTMLReader().main()
    html.pprint()
</PRE>
                  <!--footer-->
                  </BODY>
