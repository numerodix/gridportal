<HTML><HEAD><TITLE>WebUtils/Cookie.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=#1111CC>#!/usr/bin/env python</FONT>
<FONT COLOR=#1111CC>#</FONT>

<FONT COLOR=#1111CC>####</FONT>
<FONT COLOR=#1111CC># Copyright 2000 by Timothy O'Malley &lt;timo@alum.mit.edu&gt;</FONT>
<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC>#                All Rights Reserved</FONT>
<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC># Permission to use, copy, modify, and distribute this software</FONT>
<FONT COLOR=#1111CC># and its documentation for any purpose and without fee is hereby</FONT>
<FONT COLOR=#1111CC># granted, provided that the above copyright notice appear in all</FONT>
<FONT COLOR=#1111CC># copies and that both that copyright notice and this permission</FONT>
<FONT COLOR=#1111CC># notice appear in supporting documentation, and that the name of</FONT>
<FONT COLOR=#1111CC># Timothy O'Malley  not be used in advertising or publicity</FONT>
<FONT COLOR=#1111CC># pertaining to distribution of the software without specific, written</FONT>
<FONT COLOR=#1111CC># prior permission.</FONT>
<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC># Timothy O'Malley DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS</FONT>
<FONT COLOR=#1111CC># SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY</FONT>
<FONT COLOR=#1111CC># AND FITNESS, IN NO EVENT SHALL Timothy O'Malley BE LIABLE FOR</FONT>
<FONT COLOR=#1111CC># ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</FONT>
<FONT COLOR=#1111CC># WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,</FONT>
<FONT COLOR=#1111CC># WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS</FONT>
<FONT COLOR=#1111CC># ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR</FONT>
<FONT COLOR=#1111CC># PERFORMANCE OF THIS SOFTWARE.</FONT>
<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC>####</FONT>
<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC># Id: Cookie.py,v 2.29 2000/08/23 05:28:49 timo Exp</FONT>
<FONT COLOR=#1111CC>#   by Timothy O'Malley &lt;timo@alum.mit.edu&gt;</FONT>
<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC>#  Cookie.py is a Python module for the handling of HTTP</FONT>
<FONT COLOR=#1111CC>#  cookies as a Python dictionary.  See RFC 2109 for more</FONT>
<FONT COLOR=#1111CC>#  information on cookies.</FONT>
<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC>#  The original idea to treat Cookies as a dictionary came from</FONT>
<FONT COLOR=#1111CC>#  Dave Mitchell (davem@magnet.com) in 1995, when he released the</FONT>
<FONT COLOR=#1111CC>#  first version of nscookie.py.</FONT>
<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC>#  This version of Cookie.py was taken from Python 2.2a4, then modified</FONT>
<FONT COLOR=#1111CC>#  slightly so that it will work in all versions of Python from 1.5.2 up.</FONT>
<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC>####</FONT>

r<FONT COLOR=#FF0000>"""
Here's a sample session to show how to use this module.
At the moment, this is the only documentation.

The Basics
----------

Importing is easy..

   &gt;&gt;&gt; import Cookie

Most of the time you start by creating a cookie.  Cookies come in
three flavors, each with slighly different encoding semanitcs, but
more on that later.

   &gt;&gt;&gt; C = Cookie.SimpleCookie()
   &gt;&gt;&gt; C = Cookie.SerialCookie()
   &gt;&gt;&gt; C = Cookie.SmartCookie()

[Note: Long-time users of Cookie.py will remember using
Cookie.Cookie() to create an Cookie object.  Although deprecated, it
is still supported by the code.  See the Backward Compatibility notes
for more information.]

Once you've created your Cookie, you can add values just as if it were
a dictionary.

   &gt;&gt;&gt; C = Cookie.SmartCookie()
   &gt;&gt;&gt; C["fig"] = "newton"
   &gt;&gt;&gt; C["sugar"] = "wafer"
   &gt;&gt;&gt; print C
   Set-Cookie: fig=newton;
   Set-Cookie: sugar=wafer;

Notice that the printable representation of a Cookie is the
appropriate format for a Set-Cookie: header.  This is the
default behavior.  You can change the header and printed
attributes by using the the .output() function

   &gt;&gt;&gt; C = Cookie.SmartCookie()
   &gt;&gt;&gt; C["rocky"] = "road"
   &gt;&gt;&gt; C["rocky"]["path"] = "/cookie"
   &gt;&gt;&gt; print C.output(header="Cookie:")
   Cookie: rocky=road; Path=/cookie;
   &gt;&gt;&gt; print C.output(attrs=[], header="Cookie:")
   Cookie: rocky=road;

The load() method of a Cookie extracts cookies from a string.  In a
CGI script, you would use this method to extract the cookies from the
HTTP_COOKIE environment variable.

   &gt;&gt;&gt; C = Cookie.SmartCookie()
   &gt;&gt;&gt; C.load("chips=ahoy; vienna=finger")
   &gt;&gt;&gt; print C
   Set-Cookie: chips=ahoy;
   Set-Cookie: vienna=finger;

The load() method is darn-tootin smart about identifying cookies
within a string.  Escaped quotation marks, nested semicolons, and other
such trickeries do not confuse it.

   &gt;&gt;&gt; C = Cookie.SmartCookie()
   &gt;&gt;&gt; C.load('keebler="E=everybody; L=\\"Loves\\"; fudge=\\012;";')
   &gt;&gt;&gt; print C
   Set-Cookie: keebler="E=everybody; L=\"Loves\"; fudge=\012;";

Each element of the Cookie also supports all of the RFC 2109
Cookie attributes.  Here's an example which sets the Path
attribute.

   &gt;&gt;&gt; C = Cookie.SmartCookie()
   &gt;&gt;&gt; C["oreo"] = "doublestuff"
   &gt;&gt;&gt; C["oreo"]["path"] = "/"
   &gt;&gt;&gt; print C
   Set-Cookie: oreo=doublestuff; Path=/;

Each dictionary element has a 'value' attribute, which gives you
back the value associated with the key.

   &gt;&gt;&gt; C = Cookie.SmartCookie()
   &gt;&gt;&gt; C["twix"] = "none for you"
   &gt;&gt;&gt; C["twix"].value
   'none for you'


A Bit More Advanced
-------------------

As mentioned before, there are three different flavors of Cookie
objects, each with different encoding/decoding semantics.  This
section briefly discusses the differences.

SimpleCookie

The SimpleCookie expects that all values should be standard strings.
Just to be sure, SimpleCookie invokes the str() builtin to convert
the value to a string, when the values are set dictionary-style.

   &gt;&gt;&gt; C = Cookie.SimpleCookie()
   &gt;&gt;&gt; C["number"] = 7
   &gt;&gt;&gt; C["string"] = "seven"
   &gt;&gt;&gt; C["number"].value
   '7'
   &gt;&gt;&gt; C["string"].value
   'seven'
   &gt;&gt;&gt; print C
   Set-Cookie: number=7;
   Set-Cookie: string=seven;


SerialCookie

The SerialCookie expects that all values should be serialized using
cPickle (or pickle, if cPickle isn't available).  As a result of
serializing, SerialCookie can save almost any Python object to a
value, and recover the exact same object when the cookie has been
returned.  (SerialCookie can yield some strange-looking cookie
values, however.)

   &gt;&gt;&gt; C = Cookie.SerialCookie()
   &gt;&gt;&gt; C["number"] = 7
   &gt;&gt;&gt; C["string"] = "seven"
   &gt;&gt;&gt; C["number"].value
   7
   &gt;&gt;&gt; C["string"].value
   'seven'
   &gt;&gt;&gt; print C
   Set-Cookie: number="I7\012.";
   Set-Cookie: string="S'seven'\012p1\012.";

Be warned, however, if SerialCookie cannot de-serialize a value (because
it isn't a valid pickle'd object), IT WILL RAISE AN EXCEPTION.


SmartCookie

The SmartCookie combines aspects of each of the other two flavors.
When setting a value in a dictionary-fashion, the SmartCookie will
serialize (ala cPickle) the value *if and only if* it isn't a
Python string.  String objects are *not* serialized.  Similarly,
when the load() method parses out values, it attempts to de-serialize
the value.  If it fails, then it fallsback to treating the value
as a string.

   &gt;&gt;&gt; C = Cookie.SmartCookie()
   &gt;&gt;&gt; C["number"] = 7
   &gt;&gt;&gt; C["string"] = "seven"
   &gt;&gt;&gt; C["number"].value
   7
   &gt;&gt;&gt; C["string"].value
   'seven'
   &gt;&gt;&gt; print C
   Set-Cookie: number="I7\012.";
   Set-Cookie: string=seven;


Backwards Compatibility
-----------------------

In order to keep compatibilty with earlier versions of Cookie.py,
it is still possible to use Cookie.Cookie() to create a Cookie.  In
fact, this simply returns a SmartCookie.

   &gt;&gt;&gt; C = Cookie.Cookie()
   &gt;&gt;&gt; print C.__class__.__name__
   SmartCookie


Finis.
"""</FONT>  <FONT COLOR=#1111CC>#"</FONT>
<FONT COLOR=#1111CC>#     ^</FONT>
<FONT COLOR=#1111CC>#     |----helps out font-lock</FONT>

<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC># Import our required modules</FONT>
<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=black><B>import</B></FONT> string
<FONT COLOR=black><B>from</B></FONT> UserDict <FONT COLOR=black><B>import</B></FONT> UserDict

<FONT COLOR=black><B>try</B></FONT>:
    <FONT COLOR=black><B>from</B></FONT> cPickle <FONT COLOR=black><B>import</B></FONT> dumps, loads
<FONT COLOR=black><B>except</B></FONT> ImportError:
    <FONT COLOR=black><B>from</B></FONT> pickle <FONT COLOR=black><B>import</B></FONT> dumps, loads

<FONT COLOR=black><B>try</B></FONT>:
    <FONT COLOR=black><B>import</B></FONT> re
<FONT COLOR=black><B>except</B></FONT> ImportError:
    <FONT COLOR=black><B>raise</B></FONT> ImportError, <FONT COLOR=#FF0000>"Cookie.py requires 're' from Python 1.5 or later"</FONT>

__all__ = [<FONT COLOR=#FF0000>"CookieError"</FONT>,<FONT COLOR=#FF0000>"BaseCookie"</FONT>,<FONT COLOR=#FF0000>"SimpleCookie"</FONT>,<FONT COLOR=#FF0000>"SerialCookie"</FONT>,
           <FONT COLOR=#FF0000>"SmartCookie"</FONT>,<FONT COLOR=#FF0000>"Cookie"</FONT>]

<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC># Define an exception visible to External modules</FONT>
<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=black><B>class</B></FONT> CookieError(Exception):
    <FONT COLOR=black><B>pass</B></FONT>


<FONT COLOR=#1111CC># These quoting routines conform to the RFC2109 specification, which in</FONT>
<FONT COLOR=#1111CC># turn references the character definitions from RFC2068.  They provide</FONT>
<FONT COLOR=#1111CC># a two-way quoting algorithm.  Any non-text character is translated</FONT>
<FONT COLOR=#1111CC># into a 4 character sequence: a forward-slash followed by the</FONT>
<FONT COLOR=#1111CC># three-digit octal equivalent of the character.  Any '\' or '"' is</FONT>
<FONT COLOR=#1111CC># quoted with a preceeding '\' slash.</FONT>
<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC># These are taken from RFC2068 and RFC2109.</FONT>
<FONT COLOR=#1111CC>#       _LegalChars       is the list of chars which don't require "'s</FONT>
<FONT COLOR=#1111CC>#       _Translator       hash-table for fast quoting</FONT>
<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=black><B>try</B></FONT>:
    _LegalChars       = string.ascii_letters + string.digits + <FONT COLOR=#FF0000>"!#$%&'*+-.^_`|~"</FONT>
<FONT COLOR=black><B>except</B></FONT> AttributeError:
    _LegalChars       = string.letters + string.digits + <FONT COLOR=#FF0000>"!#$%&'*+-.^_`|~"</FONT>
_Translator       = {
    <FONT COLOR=#FF0000>'\000'</FONT> : <FONT COLOR=#FF0000>'\\000'</FONT>,  <FONT COLOR=#FF0000>'\001'</FONT> : <FONT COLOR=#FF0000>'\\001'</FONT>,  <FONT COLOR=#FF0000>'\002'</FONT> : <FONT COLOR=#FF0000>'\\002'</FONT>,
    <FONT COLOR=#FF0000>'\003'</FONT> : <FONT COLOR=#FF0000>'\\003'</FONT>,  <FONT COLOR=#FF0000>'\004'</FONT> : <FONT COLOR=#FF0000>'\\004'</FONT>,  <FONT COLOR=#FF0000>'\005'</FONT> : <FONT COLOR=#FF0000>'\\005'</FONT>,
    <FONT COLOR=#FF0000>'\006'</FONT> : <FONT COLOR=#FF0000>'\\006'</FONT>,  <FONT COLOR=#FF0000>'\007'</FONT> : <FONT COLOR=#FF0000>'\\007'</FONT>,  <FONT COLOR=#FF0000>'\010'</FONT> : <FONT COLOR=#FF0000>'\\010'</FONT>,
    <FONT COLOR=#FF0000>'\011'</FONT> : <FONT COLOR=#FF0000>'\\011'</FONT>,  <FONT COLOR=#FF0000>'\012'</FONT> : <FONT COLOR=#FF0000>'\\012'</FONT>,  <FONT COLOR=#FF0000>'\013'</FONT> : <FONT COLOR=#FF0000>'\\013'</FONT>,
    <FONT COLOR=#FF0000>'\014'</FONT> : <FONT COLOR=#FF0000>'\\014'</FONT>,  <FONT COLOR=#FF0000>'\015'</FONT> : <FONT COLOR=#FF0000>'\\015'</FONT>,  <FONT COLOR=#FF0000>'\016'</FONT> : <FONT COLOR=#FF0000>'\\016'</FONT>,
    <FONT COLOR=#FF0000>'\017'</FONT> : <FONT COLOR=#FF0000>'\\017'</FONT>,  <FONT COLOR=#FF0000>'\020'</FONT> : <FONT COLOR=#FF0000>'\\020'</FONT>,  <FONT COLOR=#FF0000>'\021'</FONT> : <FONT COLOR=#FF0000>'\\021'</FONT>,
    <FONT COLOR=#FF0000>'\022'</FONT> : <FONT COLOR=#FF0000>'\\022'</FONT>,  <FONT COLOR=#FF0000>'\023'</FONT> : <FONT COLOR=#FF0000>'\\023'</FONT>,  <FONT COLOR=#FF0000>'\024'</FONT> : <FONT COLOR=#FF0000>'\\024'</FONT>,
    <FONT COLOR=#FF0000>'\025'</FONT> : <FONT COLOR=#FF0000>'\\025'</FONT>,  <FONT COLOR=#FF0000>'\026'</FONT> : <FONT COLOR=#FF0000>'\\026'</FONT>,  <FONT COLOR=#FF0000>'\027'</FONT> : <FONT COLOR=#FF0000>'\\027'</FONT>,
    <FONT COLOR=#FF0000>'\030'</FONT> : <FONT COLOR=#FF0000>'\\030'</FONT>,  <FONT COLOR=#FF0000>'\031'</FONT> : <FONT COLOR=#FF0000>'\\031'</FONT>,  <FONT COLOR=#FF0000>'\032'</FONT> : <FONT COLOR=#FF0000>'\\032'</FONT>,
    <FONT COLOR=#FF0000>'\033'</FONT> : <FONT COLOR=#FF0000>'\\033'</FONT>,  <FONT COLOR=#FF0000>'\034'</FONT> : <FONT COLOR=#FF0000>'\\034'</FONT>,  <FONT COLOR=#FF0000>'\035'</FONT> : <FONT COLOR=#FF0000>'\\035'</FONT>,
    <FONT COLOR=#FF0000>'\036'</FONT> : <FONT COLOR=#FF0000>'\\036'</FONT>,  <FONT COLOR=#FF0000>'\037'</FONT> : <FONT COLOR=#FF0000>'\\037'</FONT>,

    <FONT COLOR=#FF0000>'"'</FONT> : <FONT COLOR=#FF0000>'\\"'</FONT>,       <FONT COLOR=#FF0000>'\\'</FONT> : <FONT COLOR=#FF0000>'\\\\'</FONT>,

    <FONT COLOR=#FF0000>'\177'</FONT> : <FONT COLOR=#FF0000>'\\177'</FONT>,  <FONT COLOR=#FF0000>'\200'</FONT> : <FONT COLOR=#FF0000>'\\200'</FONT>,  <FONT COLOR=#FF0000>'\201'</FONT> : <FONT COLOR=#FF0000>'\\201'</FONT>,
    <FONT COLOR=#FF0000>'\202'</FONT> : <FONT COLOR=#FF0000>'\\202'</FONT>,  <FONT COLOR=#FF0000>'\203'</FONT> : <FONT COLOR=#FF0000>'\\203'</FONT>,  <FONT COLOR=#FF0000>'\204'</FONT> : <FONT COLOR=#FF0000>'\\204'</FONT>,
    <FONT COLOR=#FF0000>'\205'</FONT> : <FONT COLOR=#FF0000>'\\205'</FONT>,  <FONT COLOR=#FF0000>'\206'</FONT> : <FONT COLOR=#FF0000>'\\206'</FONT>,  <FONT COLOR=#FF0000>'\207'</FONT> : <FONT COLOR=#FF0000>'\\207'</FONT>,
    <FONT COLOR=#FF0000>'\210'</FONT> : <FONT COLOR=#FF0000>'\\210'</FONT>,  <FONT COLOR=#FF0000>'\211'</FONT> : <FONT COLOR=#FF0000>'\\211'</FONT>,  <FONT COLOR=#FF0000>'\212'</FONT> : <FONT COLOR=#FF0000>'\\212'</FONT>,
    <FONT COLOR=#FF0000>'\213'</FONT> : <FONT COLOR=#FF0000>'\\213'</FONT>,  <FONT COLOR=#FF0000>'\214'</FONT> : <FONT COLOR=#FF0000>'\\214'</FONT>,  <FONT COLOR=#FF0000>'\215'</FONT> : <FONT COLOR=#FF0000>'\\215'</FONT>,
    <FONT COLOR=#FF0000>'\216'</FONT> : <FONT COLOR=#FF0000>'\\216'</FONT>,  <FONT COLOR=#FF0000>'\217'</FONT> : <FONT COLOR=#FF0000>'\\217'</FONT>,  <FONT COLOR=#FF0000>'\220'</FONT> : <FONT COLOR=#FF0000>'\\220'</FONT>,
    <FONT COLOR=#FF0000>'\221'</FONT> : <FONT COLOR=#FF0000>'\\221'</FONT>,  <FONT COLOR=#FF0000>'\222'</FONT> : <FONT COLOR=#FF0000>'\\222'</FONT>,  <FONT COLOR=#FF0000>'\223'</FONT> : <FONT COLOR=#FF0000>'\\223'</FONT>,
    <FONT COLOR=#FF0000>'\224'</FONT> : <FONT COLOR=#FF0000>'\\224'</FONT>,  <FONT COLOR=#FF0000>'\225'</FONT> : <FONT COLOR=#FF0000>'\\225'</FONT>,  <FONT COLOR=#FF0000>'\226'</FONT> : <FONT COLOR=#FF0000>'\\226'</FONT>,
    <FONT COLOR=#FF0000>'\227'</FONT> : <FONT COLOR=#FF0000>'\\227'</FONT>,  <FONT COLOR=#FF0000>'\230'</FONT> : <FONT COLOR=#FF0000>'\\230'</FONT>,  <FONT COLOR=#FF0000>'\231'</FONT> : <FONT COLOR=#FF0000>'\\231'</FONT>,
    <FONT COLOR=#FF0000>'\232'</FONT> : <FONT COLOR=#FF0000>'\\232'</FONT>,  <FONT COLOR=#FF0000>'\233'</FONT> : <FONT COLOR=#FF0000>'\\233'</FONT>,  <FONT COLOR=#FF0000>'\234'</FONT> : <FONT COLOR=#FF0000>'\\234'</FONT>,
    <FONT COLOR=#FF0000>'\235'</FONT> : <FONT COLOR=#FF0000>'\\235'</FONT>,  <FONT COLOR=#FF0000>'\236'</FONT> : <FONT COLOR=#FF0000>'\\236'</FONT>,  <FONT COLOR=#FF0000>'\237'</FONT> : <FONT COLOR=#FF0000>'\\237'</FONT>,
    <FONT COLOR=#FF0000>'\240'</FONT> : <FONT COLOR=#FF0000>'\\240'</FONT>,  <FONT COLOR=#FF0000>'\241'</FONT> : <FONT COLOR=#FF0000>'\\241'</FONT>,  <FONT COLOR=#FF0000>'\242'</FONT> : <FONT COLOR=#FF0000>'\\242'</FONT>,
    <FONT COLOR=#FF0000>'\243'</FONT> : <FONT COLOR=#FF0000>'\\243'</FONT>,  <FONT COLOR=#FF0000>'\244'</FONT> : <FONT COLOR=#FF0000>'\\244'</FONT>,  <FONT COLOR=#FF0000>'\245'</FONT> : <FONT COLOR=#FF0000>'\\245'</FONT>,
    <FONT COLOR=#FF0000>'\246'</FONT> : <FONT COLOR=#FF0000>'\\246'</FONT>,  <FONT COLOR=#FF0000>'\247'</FONT> : <FONT COLOR=#FF0000>'\\247'</FONT>,  <FONT COLOR=#FF0000>'\250'</FONT> : <FONT COLOR=#FF0000>'\\250'</FONT>,
    <FONT COLOR=#FF0000>'\251'</FONT> : <FONT COLOR=#FF0000>'\\251'</FONT>,  <FONT COLOR=#FF0000>'\252'</FONT> : <FONT COLOR=#FF0000>'\\252'</FONT>,  <FONT COLOR=#FF0000>'\253'</FONT> : <FONT COLOR=#FF0000>'\\253'</FONT>,
    <FONT COLOR=#FF0000>'\254'</FONT> : <FONT COLOR=#FF0000>'\\254'</FONT>,  <FONT COLOR=#FF0000>'\255'</FONT> : <FONT COLOR=#FF0000>'\\255'</FONT>,  <FONT COLOR=#FF0000>'\256'</FONT> : <FONT COLOR=#FF0000>'\\256'</FONT>,
    <FONT COLOR=#FF0000>'\257'</FONT> : <FONT COLOR=#FF0000>'\\257'</FONT>,  <FONT COLOR=#FF0000>'\260'</FONT> : <FONT COLOR=#FF0000>'\\260'</FONT>,  <FONT COLOR=#FF0000>'\261'</FONT> : <FONT COLOR=#FF0000>'\\261'</FONT>,
    <FONT COLOR=#FF0000>'\262'</FONT> : <FONT COLOR=#FF0000>'\\262'</FONT>,  <FONT COLOR=#FF0000>'\263'</FONT> : <FONT COLOR=#FF0000>'\\263'</FONT>,  <FONT COLOR=#FF0000>'\264'</FONT> : <FONT COLOR=#FF0000>'\\264'</FONT>,
    <FONT COLOR=#FF0000>'\265'</FONT> : <FONT COLOR=#FF0000>'\\265'</FONT>,  <FONT COLOR=#FF0000>'\266'</FONT> : <FONT COLOR=#FF0000>'\\266'</FONT>,  <FONT COLOR=#FF0000>'\267'</FONT> : <FONT COLOR=#FF0000>'\\267'</FONT>,
    <FONT COLOR=#FF0000>'\270'</FONT> : <FONT COLOR=#FF0000>'\\270'</FONT>,  <FONT COLOR=#FF0000>'\271'</FONT> : <FONT COLOR=#FF0000>'\\271'</FONT>,  <FONT COLOR=#FF0000>'\272'</FONT> : <FONT COLOR=#FF0000>'\\272'</FONT>,
    <FONT COLOR=#FF0000>'\273'</FONT> : <FONT COLOR=#FF0000>'\\273'</FONT>,  <FONT COLOR=#FF0000>'\274'</FONT> : <FONT COLOR=#FF0000>'\\274'</FONT>,  <FONT COLOR=#FF0000>'\275'</FONT> : <FONT COLOR=#FF0000>'\\275'</FONT>,
    <FONT COLOR=#FF0000>'\276'</FONT> : <FONT COLOR=#FF0000>'\\276'</FONT>,  <FONT COLOR=#FF0000>'\277'</FONT> : <FONT COLOR=#FF0000>'\\277'</FONT>,  <FONT COLOR=#FF0000>'\300'</FONT> : <FONT COLOR=#FF0000>'\\300'</FONT>,
    <FONT COLOR=#FF0000>'\301'</FONT> : <FONT COLOR=#FF0000>'\\301'</FONT>,  <FONT COLOR=#FF0000>'\302'</FONT> : <FONT COLOR=#FF0000>'\\302'</FONT>,  <FONT COLOR=#FF0000>'\303'</FONT> : <FONT COLOR=#FF0000>'\\303'</FONT>,
    <FONT COLOR=#FF0000>'\304'</FONT> : <FONT COLOR=#FF0000>'\\304'</FONT>,  <FONT COLOR=#FF0000>'\305'</FONT> : <FONT COLOR=#FF0000>'\\305'</FONT>,  <FONT COLOR=#FF0000>'\306'</FONT> : <FONT COLOR=#FF0000>'\\306'</FONT>,
    <FONT COLOR=#FF0000>'\307'</FONT> : <FONT COLOR=#FF0000>'\\307'</FONT>,  <FONT COLOR=#FF0000>'\310'</FONT> : <FONT COLOR=#FF0000>'\\310'</FONT>,  <FONT COLOR=#FF0000>'\311'</FONT> : <FONT COLOR=#FF0000>'\\311'</FONT>,
    <FONT COLOR=#FF0000>'\312'</FONT> : <FONT COLOR=#FF0000>'\\312'</FONT>,  <FONT COLOR=#FF0000>'\313'</FONT> : <FONT COLOR=#FF0000>'\\313'</FONT>,  <FONT COLOR=#FF0000>'\314'</FONT> : <FONT COLOR=#FF0000>'\\314'</FONT>,
    <FONT COLOR=#FF0000>'\315'</FONT> : <FONT COLOR=#FF0000>'\\315'</FONT>,  <FONT COLOR=#FF0000>'\316'</FONT> : <FONT COLOR=#FF0000>'\\316'</FONT>,  <FONT COLOR=#FF0000>'\317'</FONT> : <FONT COLOR=#FF0000>'\\317'</FONT>,
    <FONT COLOR=#FF0000>'\320'</FONT> : <FONT COLOR=#FF0000>'\\320'</FONT>,  <FONT COLOR=#FF0000>'\321'</FONT> : <FONT COLOR=#FF0000>'\\321'</FONT>,  <FONT COLOR=#FF0000>'\322'</FONT> : <FONT COLOR=#FF0000>'\\322'</FONT>,
    <FONT COLOR=#FF0000>'\323'</FONT> : <FONT COLOR=#FF0000>'\\323'</FONT>,  <FONT COLOR=#FF0000>'\324'</FONT> : <FONT COLOR=#FF0000>'\\324'</FONT>,  <FONT COLOR=#FF0000>'\325'</FONT> : <FONT COLOR=#FF0000>'\\325'</FONT>,
    <FONT COLOR=#FF0000>'\326'</FONT> : <FONT COLOR=#FF0000>'\\326'</FONT>,  <FONT COLOR=#FF0000>'\327'</FONT> : <FONT COLOR=#FF0000>'\\327'</FONT>,  <FONT COLOR=#FF0000>'\330'</FONT> : <FONT COLOR=#FF0000>'\\330'</FONT>,
    <FONT COLOR=#FF0000>'\331'</FONT> : <FONT COLOR=#FF0000>'\\331'</FONT>,  <FONT COLOR=#FF0000>'\332'</FONT> : <FONT COLOR=#FF0000>'\\332'</FONT>,  <FONT COLOR=#FF0000>'\333'</FONT> : <FONT COLOR=#FF0000>'\\333'</FONT>,
    <FONT COLOR=#FF0000>'\334'</FONT> : <FONT COLOR=#FF0000>'\\334'</FONT>,  <FONT COLOR=#FF0000>'\335'</FONT> : <FONT COLOR=#FF0000>'\\335'</FONT>,  <FONT COLOR=#FF0000>'\336'</FONT> : <FONT COLOR=#FF0000>'\\336'</FONT>,
    <FONT COLOR=#FF0000>'\337'</FONT> : <FONT COLOR=#FF0000>'\\337'</FONT>,  <FONT COLOR=#FF0000>'\340'</FONT> : <FONT COLOR=#FF0000>'\\340'</FONT>,  <FONT COLOR=#FF0000>'\341'</FONT> : <FONT COLOR=#FF0000>'\\341'</FONT>,
    <FONT COLOR=#FF0000>'\342'</FONT> : <FONT COLOR=#FF0000>'\\342'</FONT>,  <FONT COLOR=#FF0000>'\343'</FONT> : <FONT COLOR=#FF0000>'\\343'</FONT>,  <FONT COLOR=#FF0000>'\344'</FONT> : <FONT COLOR=#FF0000>'\\344'</FONT>,
    <FONT COLOR=#FF0000>'\345'</FONT> : <FONT COLOR=#FF0000>'\\345'</FONT>,  <FONT COLOR=#FF0000>'\346'</FONT> : <FONT COLOR=#FF0000>'\\346'</FONT>,  <FONT COLOR=#FF0000>'\347'</FONT> : <FONT COLOR=#FF0000>'\\347'</FONT>,
    <FONT COLOR=#FF0000>'\350'</FONT> : <FONT COLOR=#FF0000>'\\350'</FONT>,  <FONT COLOR=#FF0000>'\351'</FONT> : <FONT COLOR=#FF0000>'\\351'</FONT>,  <FONT COLOR=#FF0000>'\352'</FONT> : <FONT COLOR=#FF0000>'\\352'</FONT>,
    <FONT COLOR=#FF0000>'\353'</FONT> : <FONT COLOR=#FF0000>'\\353'</FONT>,  <FONT COLOR=#FF0000>'\354'</FONT> : <FONT COLOR=#FF0000>'\\354'</FONT>,  <FONT COLOR=#FF0000>'\355'</FONT> : <FONT COLOR=#FF0000>'\\355'</FONT>,
    <FONT COLOR=#FF0000>'\356'</FONT> : <FONT COLOR=#FF0000>'\\356'</FONT>,  <FONT COLOR=#FF0000>'\357'</FONT> : <FONT COLOR=#FF0000>'\\357'</FONT>,  <FONT COLOR=#FF0000>'\360'</FONT> : <FONT COLOR=#FF0000>'\\360'</FONT>,
    <FONT COLOR=#FF0000>'\361'</FONT> : <FONT COLOR=#FF0000>'\\361'</FONT>,  <FONT COLOR=#FF0000>'\362'</FONT> : <FONT COLOR=#FF0000>'\\362'</FONT>,  <FONT COLOR=#FF0000>'\363'</FONT> : <FONT COLOR=#FF0000>'\\363'</FONT>,
    <FONT COLOR=#FF0000>'\364'</FONT> : <FONT COLOR=#FF0000>'\\364'</FONT>,  <FONT COLOR=#FF0000>'\365'</FONT> : <FONT COLOR=#FF0000>'\\365'</FONT>,  <FONT COLOR=#FF0000>'\366'</FONT> : <FONT COLOR=#FF0000>'\\366'</FONT>,
    <FONT COLOR=#FF0000>'\367'</FONT> : <FONT COLOR=#FF0000>'\\367'</FONT>,  <FONT COLOR=#FF0000>'\370'</FONT> : <FONT COLOR=#FF0000>'\\370'</FONT>,  <FONT COLOR=#FF0000>'\371'</FONT> : <FONT COLOR=#FF0000>'\\371'</FONT>,
    <FONT COLOR=#FF0000>'\372'</FONT> : <FONT COLOR=#FF0000>'\\372'</FONT>,  <FONT COLOR=#FF0000>'\373'</FONT> : <FONT COLOR=#FF0000>'\\373'</FONT>,  <FONT COLOR=#FF0000>'\374'</FONT> : <FONT COLOR=#FF0000>'\\374'</FONT>,
    <FONT COLOR=#FF0000>'\375'</FONT> : <FONT COLOR=#FF0000>'\\375'</FONT>,  <FONT COLOR=#FF0000>'\376'</FONT> : <FONT COLOR=#FF0000>'\\376'</FONT>,  <FONT COLOR=#FF0000>'\377'</FONT> : <FONT COLOR=#FF0000>'\\377'</FONT>
    }

<FONT COLOR=black><B>def</B></FONT> _quote(str, LegalChars=_LegalChars,
    join=string.join, idmap=string._idmap, translate=string.translate):
    <FONT COLOR=#1111CC>#</FONT>
    <FONT COLOR=#1111CC># If the string does not need to be double-quoted,</FONT>
    <FONT COLOR=#1111CC># then just return the string.  Otherwise, surround</FONT>
    <FONT COLOR=#1111CC># the string in doublequotes and precede quote (with a \)</FONT>
    <FONT COLOR=#1111CC># special characters.</FONT>
    <FONT COLOR=#1111CC>#</FONT>
    <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=#FF0000>""</FONT> == translate(str, idmap, LegalChars):
        <FONT COLOR=black><B>return</B></FONT> str
    <FONT COLOR=black><B>else</B></FONT>:
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>'"'</FONT> + join( map(_Translator.get, str, str), <FONT COLOR=#FF0000>""</FONT> ) + <FONT COLOR=#FF0000>'"'</FONT>
<FONT COLOR=#1111CC># end _quote</FONT>


_OctalPatt = re.compile(r<FONT COLOR=#FF0000>"\\[0-3][0-7][0-7]"</FONT>)
_QuotePatt = re.compile(r<FONT COLOR=#FF0000>"[\\]."</FONT>)

<FONT COLOR=black><B>def</B></FONT> _unquote(str, join=string.join, atoi=string.atoi):
    <FONT COLOR=#1111CC># If there aren't any doublequotes,</FONT>
    <FONT COLOR=#1111CC># then there can't be any special characters.  See RFC 2109.</FONT>
    <FONT COLOR=black><B>if</B></FONT>  len(str) &lt; 2:
        <FONT COLOR=black><B>return</B></FONT> str
    <FONT COLOR=black><B>if</B></FONT> str[0] != <FONT COLOR=#FF0000>'"'</FONT> <FONT COLOR=black><B>or</B></FONT> str[-1] != <FONT COLOR=#FF0000>'"'</FONT>:
        <FONT COLOR=black><B>return</B></FONT> str

    <FONT COLOR=#1111CC># We have to assume that we must decode this string.</FONT>
    <FONT COLOR=#1111CC># Down to work.</FONT>

    <FONT COLOR=#1111CC># Remove the "s</FONT>
    str = str[1:-1]

    <FONT COLOR=#1111CC># Check for special sequences.  Examples:</FONT>
    <FONT COLOR=#1111CC>#    \012 --&gt; \n</FONT>
    <FONT COLOR=#1111CC>#    \"   --&gt; "</FONT>
    <FONT COLOR=#1111CC>#</FONT>
    i = 0
    n = len(str)
    res = []
    <FONT COLOR=black><B>while</B></FONT> 0 &lt;= i &lt; n:
        Omatch = _OctalPatt.search(str, i)
        Qmatch = _QuotePatt.search(str, i)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> Omatch <FONT COLOR=black><B>and</B></FONT> <FONT COLOR=black><B>not</B></FONT> Qmatch:              <FONT COLOR=#1111CC># Neither matched</FONT>
            res.append(str[i:])
            <FONT COLOR=black><B>break</B></FONT>
        <FONT COLOR=#1111CC># else:</FONT>
        j = k = -1
        <FONT COLOR=black><B>if</B></FONT> Omatch: j = Omatch.start(0)
        <FONT COLOR=black><B>if</B></FONT> Qmatch: k = Qmatch.start(0)
        <FONT COLOR=black><B>if</B></FONT> Qmatch <FONT COLOR=black><B>and</B></FONT> ( <FONT COLOR=black><B>not</B></FONT> Omatch <FONT COLOR=black><B>or</B></FONT> k &lt; j ):     <FONT COLOR=#1111CC># QuotePatt matched</FONT>
            res.append(str[i:k])
            res.append(str[k+1])
            i = k+2
        <FONT COLOR=black><B>else</B></FONT>:                                      <FONT COLOR=#1111CC># OctalPatt matched</FONT>
            res.append(str[i:j])
            res.append( chr( atoi(str[j+1:j+4], 8) ) )
            i = j+4
    <FONT COLOR=black><B>return</B></FONT> join(res, <FONT COLOR=#FF0000>""</FONT>)
<FONT COLOR=#1111CC># end _unquote</FONT>

<FONT COLOR=#1111CC># The _getdate() routine is used to set the expiration time in</FONT>
<FONT COLOR=#1111CC># the cookie's HTTP header.      By default, _getdate() returns the</FONT>
<FONT COLOR=#1111CC># current time in the appropriate "expires" format for a</FONT>
<FONT COLOR=#1111CC># Set-Cookie header.     The one optional argument is an offset from</FONT>
<FONT COLOR=#1111CC># now, in seconds.      For example, an offset of -3600 means "one hour ago".</FONT>
<FONT COLOR=#1111CC># The offset may be a floating point number.</FONT>
<FONT COLOR=#1111CC>#</FONT>

_weekdayname = [<FONT COLOR=#FF0000>'Mon'</FONT>, <FONT COLOR=#FF0000>'Tue'</FONT>, <FONT COLOR=#FF0000>'Wed'</FONT>, <FONT COLOR=#FF0000>'Thu'</FONT>, <FONT COLOR=#FF0000>'Fri'</FONT>, <FONT COLOR=#FF0000>'Sat'</FONT>, <FONT COLOR=#FF0000>'Sun'</FONT>]

_monthname = [None,
              <FONT COLOR=#FF0000>'Jan'</FONT>, <FONT COLOR=#FF0000>'Feb'</FONT>, <FONT COLOR=#FF0000>'Mar'</FONT>, <FONT COLOR=#FF0000>'Apr'</FONT>, <FONT COLOR=#FF0000>'May'</FONT>, <FONT COLOR=#FF0000>'Jun'</FONT>,
              <FONT COLOR=#FF0000>'Jul'</FONT>, <FONT COLOR=#FF0000>'Aug'</FONT>, <FONT COLOR=#FF0000>'Sep'</FONT>, <FONT COLOR=#FF0000>'Oct'</FONT>, <FONT COLOR=#FF0000>'Nov'</FONT>, <FONT COLOR=#FF0000>'Dec'</FONT>]

<FONT COLOR=black><B>def</B></FONT> _getdate(future=0, weekdayname=_weekdayname, monthname=_monthname):
    <FONT COLOR=black><B>from</B></FONT> time <FONT COLOR=black><B>import</B></FONT> gmtime, time
    now = time()
    year, month, day, hh, mm, ss, wd, y, z = gmtime(now + future)
    <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>"%s, %02d-%3s-%4d %02d:%02d:%02d GMT"</FONT> % \
           (weekdayname[wd], day, monthname[month], year, hh, mm, ss)


<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC># A class to hold ONE key,value pair.</FONT>
<FONT COLOR=#1111CC># In a cookie, each such pair may have several attributes.</FONT>
<FONT COLOR=#1111CC>#       so this class is used to keep the attributes associated</FONT>
<FONT COLOR=#1111CC>#       with the appropriate key,value pair.</FONT>
<FONT COLOR=#1111CC># This class also includes a coded_value attribute, which</FONT>
<FONT COLOR=#1111CC>#       is used to hold the network representation of the</FONT>
<FONT COLOR=#1111CC>#       value.  This is most useful when Python objects are</FONT>
<FONT COLOR=#1111CC>#       pickled for network transit.</FONT>
<FONT COLOR=#1111CC>#</FONT>

<FONT COLOR=black><B>class</B></FONT> Morsel(UserDict):
    <FONT COLOR=#1111CC># RFC 2109 lists these attributes as reserved:</FONT>
    <FONT COLOR=#1111CC>#   path       comment         domain</FONT>
    <FONT COLOR=#1111CC>#   max-age    secure      version</FONT>
    <FONT COLOR=#1111CC>#</FONT>
    <FONT COLOR=#1111CC># For historical reasons, these attributes are also reserved:</FONT>
    <FONT COLOR=#1111CC>#   expires</FONT>
    <FONT COLOR=#1111CC>#</FONT>
    <FONT COLOR=#1111CC># This dictionary provides a mapping from the lowercase</FONT>
    <FONT COLOR=#1111CC># variant on the left to the appropriate traditional</FONT>
    <FONT COLOR=#1111CC># formatting on the right.</FONT>
    _reserved = { <FONT COLOR=#FF0000>"expires"</FONT> : <FONT COLOR=#FF0000>"expires"</FONT>,
                   <FONT COLOR=#FF0000>"path"</FONT>        : <FONT COLOR=#FF0000>"Path"</FONT>,
                   <FONT COLOR=#FF0000>"comment"</FONT> : <FONT COLOR=#FF0000>"Comment"</FONT>,
                   <FONT COLOR=#FF0000>"domain"</FONT>      : <FONT COLOR=#FF0000>"Domain"</FONT>,
                   <FONT COLOR=#FF0000>"max-age"</FONT> : <FONT COLOR=#FF0000>"Max-Age"</FONT>,
                   <FONT COLOR=#FF0000>"secure"</FONT>      : <FONT COLOR=#FF0000>"secure"</FONT>,
                   <FONT COLOR=#FF0000>"version"</FONT> : <FONT COLOR=#FF0000>"Version"</FONT>,
                   }
    _reserved_keys = _reserved.keys()

    <FONT COLOR=black><B>def</B></FONT> __init__(self):
        <FONT COLOR=#1111CC># Set defaults</FONT>
        self.key = self.value = self.coded_value = None
        UserDict.__init__(self)

        <FONT COLOR=#1111CC># Set default attributes</FONT>
        <FONT COLOR=black><B>for</B></FONT> K <FONT COLOR=black><B>in</B></FONT> self._reserved_keys:
            UserDict.__setitem__(self, K, <FONT COLOR=#FF0000>""</FONT>)
    <FONT COLOR=#1111CC># end __init__</FONT>

    <FONT COLOR=black><B>def</B></FONT> __setitem__(self, K, V):
        K = string.lower(K)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> K <FONT COLOR=black><B>in</B></FONT> self._reserved_keys:
            <FONT COLOR=black><B>raise</B></FONT> CookieError(<FONT COLOR=#FF0000>"Invalid Attribute %s"</FONT> % K)
        UserDict.__setitem__(self, K, V)
    <FONT COLOR=#1111CC># end __setitem__</FONT>

    <FONT COLOR=black><B>def</B></FONT> isReservedKey(self, K):
        <FONT COLOR=black><B>return</B></FONT> string.lower(K) <FONT COLOR=black><B>in</B></FONT> self._reserved_keys
    <FONT COLOR=#1111CC># end isReservedKey</FONT>

    <FONT COLOR=black><B>def</B></FONT> set(self, key, val, coded_val,
            LegalChars=_LegalChars,
            idmap=string._idmap, translate=string.translate ):
        <FONT COLOR=#1111CC># First we verify that the key isn't a reserved word</FONT>
        <FONT COLOR=#1111CC># Second we make sure it only contains legal characters</FONT>
        <FONT COLOR=black><B>if</B></FONT> string.lower(key) <FONT COLOR=black><B>in</B></FONT> self._reserved_keys:
            <FONT COLOR=black><B>raise</B></FONT> CookieError(<FONT COLOR=#FF0000>"Attempt to set a reserved key: %s"</FONT> % key)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=#FF0000>""</FONT> != translate(key, idmap, LegalChars):
            <FONT COLOR=black><B>raise</B></FONT> CookieError(<FONT COLOR=#FF0000>"Illegal key value: %s"</FONT> % key)

        <FONT COLOR=#1111CC># It's a good key, so save it.</FONT>
        self.key                 = key
        self.value               = val
        self.coded_value         = coded_val
    <FONT COLOR=#1111CC># end set</FONT>

    <FONT COLOR=black><B>def</B></FONT> output(self, attrs=None, header = <FONT COLOR=#FF0000>"Set-Cookie:"</FONT>):
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>"%s %s"</FONT> % ( header, self.OutputString(attrs) )

    __str__ = output

    <FONT COLOR=black><B>def</B></FONT> __repr__(self):
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>'&lt;%s: %s=%s&gt;'</FONT> % (self.__class__.__name__,
                                self.key, repr(self.value) )

    <FONT COLOR=black><B>def</B></FONT> js_output(self, attrs=None):
        <FONT COLOR=#1111CC># Print javascript</FONT>
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>"""
        &lt;SCRIPT LANGUAGE="JavaScript"&gt;
        &lt;!-- begin hiding
        document.cookie = \"%s\"
        // end hiding --&gt;
        &lt;/script&gt;
        """</FONT> % ( self.OutputString(attrs), )
    <FONT COLOR=#1111CC># end js_output()</FONT>

    <FONT COLOR=black><B>def</B></FONT> OutputString(self, attrs=None):
        <FONT COLOR=#1111CC># Build up our result</FONT>
        <FONT COLOR=#1111CC>#</FONT>
        result = []
        RA = result.append

        <FONT COLOR=#1111CC># First, the key=value pair</FONT>
        RA(<FONT COLOR=#FF0000>"%s=%s;"</FONT> % (self.key, self.coded_value))

        <FONT COLOR=#1111CC># Now add any defined attributes</FONT>
        <FONT COLOR=black><B>if</B></FONT> attrs <FONT COLOR=black><B>is</B></FONT> None:
            attrs = self._reserved_keys
        items = self.items()
        items.sort()
        <FONT COLOR=black><B>for</B></FONT> K,V <FONT COLOR=black><B>in</B></FONT> items:
            <FONT COLOR=black><B>if</B></FONT> V == <FONT COLOR=#FF0000>""</FONT>: <FONT COLOR=black><B>continue</B></FONT>
            <FONT COLOR=black><B>if</B></FONT> K <FONT COLOR=black><B>not</B></FONT> <FONT COLOR=black><B>in</B></FONT> attrs: <FONT COLOR=black><B>continue</B></FONT>
            <FONT COLOR=black><B>if</B></FONT> K == <FONT COLOR=#FF0000>"expires"</FONT> <FONT COLOR=black><B>and</B></FONT> type(V) == type(1):
                RA(<FONT COLOR=#FF0000>"%s=%s;"</FONT> % (self._reserved[K], _getdate(V)))
            <FONT COLOR=black><B>elif</B></FONT> K == <FONT COLOR=#FF0000>"max-age"</FONT> <FONT COLOR=black><B>and</B></FONT> type(V) == type(1):
                RA(<FONT COLOR=#FF0000>"%s=%d;"</FONT> % (self._reserved[K], V))
            <FONT COLOR=black><B>elif</B></FONT> K == <FONT COLOR=#FF0000>"secure"</FONT>:
                RA(<FONT COLOR=#FF0000>"%s;"</FONT> % self._reserved[K])
            <FONT COLOR=black><B>else</B></FONT>:
                RA(<FONT COLOR=#FF0000>"%s=%s;"</FONT> % (self._reserved[K], V))

        <FONT COLOR=#1111CC># Return the result</FONT>
        <FONT COLOR=black><B>return</B></FONT> string.join(result, <FONT COLOR=#FF0000>" "</FONT>)
    <FONT COLOR=#1111CC># end OutputString</FONT>
<FONT COLOR=#1111CC># end Morsel class</FONT>



<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC># Pattern for finding cookie</FONT>
<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC># This used to be strict parsing based on the RFC2109 and RFC2068</FONT>
<FONT COLOR=#1111CC># specifications.  I have since discovered that MSIE 3.0x doesn't</FONT>
<FONT COLOR=#1111CC># follow the character rules outlined in those specs.  As a</FONT>
<FONT COLOR=#1111CC># result, the parsing rules here are less strict.</FONT>
<FONT COLOR=#1111CC>#</FONT>

_LegalCharsPatt  = r<FONT COLOR=#FF0000>"[\w\d!#%&'~_`&gt;&lt;@,:/\$\*\+\-\.\^\|\)\(\?\}\{\=]"</FONT>
_CookiePattern = re.compile(
    r<FONT COLOR=#FF0000>"(?x)"</FONT>                       <FONT COLOR=#1111CC># This is a Verbose pattern</FONT>
    r<FONT COLOR=#FF0000>"(?P&lt;key&gt;"</FONT>                   <FONT COLOR=#1111CC># Start of group 'key'</FONT>
    <FONT COLOR=#FF0000>""</FONT>+ _LegalCharsPatt +<FONT COLOR=#FF0000>"+?"</FONT>     <FONT COLOR=#1111CC># Any word of at least one letter, nongreedy</FONT>
    r<FONT COLOR=#FF0000>")"</FONT>                          <FONT COLOR=#1111CC># End of group 'key'</FONT>
    r<FONT COLOR=#FF0000>"\s*=\s*"</FONT>                    <FONT COLOR=#1111CC># Equal Sign</FONT>
    r<FONT COLOR=#FF0000>"(?P&lt;val&gt;"</FONT>                   <FONT COLOR=#1111CC># Start of group 'val'</FONT>
    r<FONT COLOR=#FF0000>'"(?:[^\\"]|\\.)*"'</FONT>            <FONT COLOR=#1111CC># Any doublequoted string</FONT>
    r<FONT COLOR=#FF0000>"|"</FONT>                            <FONT COLOR=#1111CC># or</FONT>
    <FONT COLOR=#FF0000>""</FONT>+ _LegalCharsPatt +<FONT COLOR=#FF0000>"*"</FONT>        <FONT COLOR=#1111CC># Any word or empty string</FONT>
    r<FONT COLOR=#FF0000>")"</FONT>                          <FONT COLOR=#1111CC># End of group 'val'</FONT>
    r<FONT COLOR=#FF0000>"\s*;?"</FONT>                      <FONT COLOR=#1111CC># Probably ending in a semi-colon</FONT>
    )


<FONT COLOR=#1111CC># At long last, here is the cookie class.</FONT>
<FONT COLOR=#1111CC>#   Using this class is almost just like using a dictionary.</FONT>
<FONT COLOR=#1111CC># See this module's docstring for example usage.</FONT>
<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=black><B>class</B></FONT> BaseCookie(UserDict):
    <FONT COLOR=#1111CC># A container class for a set of Morsels</FONT>
    <FONT COLOR=#1111CC>#</FONT>

    <FONT COLOR=black><B>def</B></FONT> value_decode(self, val):
        <FONT COLOR=#FF0000>"""real_value, coded_value = value_decode(STRING)
        Called prior to setting a cookie's value from the network
        representation.  The VALUE is the value read from HTTP
        header.
        Override this function to modify the behavior of cookies.
        """</FONT>
        <FONT COLOR=black><B>return</B></FONT> val, val
    <FONT COLOR=#1111CC># end value_encode</FONT>

    <FONT COLOR=black><B>def</B></FONT> value_encode(self, val):
        <FONT COLOR=#FF0000>"""real_value, coded_value = value_encode(VALUE)
        Called prior to setting a cookie's value from the dictionary
        representation.  The VALUE is the value being assigned.
        Override this function to modify the behavior of cookies.
        """</FONT>
        strval = str(val)
        <FONT COLOR=black><B>return</B></FONT> strval, strval
    <FONT COLOR=#1111CC># end value_encode</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, input=None):
        UserDict.__init__(self)
        <FONT COLOR=black><B>if</B></FONT> input: self.load(input)
    <FONT COLOR=#1111CC># end __init__</FONT>

    <FONT COLOR=black><B>def</B></FONT> __set(self, key, real_value, coded_value):
        <FONT COLOR=#FF0000>"""Private method for setting a cookie's value"""</FONT>
        M = self.get(key, Morsel())
        M.set(key, real_value, coded_value)
        UserDict.__setitem__(self, key, M)
    <FONT COLOR=#1111CC># end __set</FONT>

    <FONT COLOR=black><B>def</B></FONT> __setitem__(self, key, value):
        <FONT COLOR=#FF0000>"""Dictionary style assignment."""</FONT>
        rval, cval = self.value_encode(value)
        self.__set(key, rval, cval)
    <FONT COLOR=#1111CC># end __setitem__</FONT>

    <FONT COLOR=black><B>def</B></FONT> output(self, attrs=None, header=<FONT COLOR=#FF0000>"Set-Cookie:"</FONT>, sep=<FONT COLOR=#FF0000>"\n"</FONT>):
        <FONT COLOR=#FF0000>"""Return a string suitable for HTTP."""</FONT>
        result = []
        items = self.items()
        items.sort()
        <FONT COLOR=black><B>for</B></FONT> K,V <FONT COLOR=black><B>in</B></FONT> items:
            result.append( V.output(attrs, header) )
        <FONT COLOR=black><B>return</B></FONT> string.join(result, sep)
    <FONT COLOR=#1111CC># end output</FONT>

    __str__ = output

    <FONT COLOR=black><B>def</B></FONT> __repr__(self):
        L = []
        items = self.items()
        items.sort()
        <FONT COLOR=black><B>for</B></FONT> K,V <FONT COLOR=black><B>in</B></FONT> items:
            L.append( <FONT COLOR=#FF0000>'%s=%s'</FONT> % (K,repr(V.value) ) )
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>'&lt;%s: %s&gt;'</FONT> % (self.__class__.__name__, string.join(L))

    <FONT COLOR=black><B>def</B></FONT> js_output(self, attrs=None):
        <FONT COLOR=#FF0000>"""Return a string suitable for JavaScript."""</FONT>
        result = []
        items = self.items()
        items.sort()
        <FONT COLOR=black><B>for</B></FONT> K,V <FONT COLOR=black><B>in</B></FONT> items:
            result.append( V.js_output(attrs) )
        <FONT COLOR=black><B>return</B></FONT> string.join(result, <FONT COLOR=#FF0000>""</FONT>)
    <FONT COLOR=#1111CC># end js_output</FONT>

    <FONT COLOR=black><B>def</B></FONT> load(self, rawdata):
        <FONT COLOR=#FF0000>"""Load cookies from a string (presumably HTTP_COOKIE) or
        from a dictionary.  Loading cookies from a dictionary 'd'
        is equivalent to calling:
            map(Cookie.__setitem__, d.keys(), d.values())
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> type(rawdata) == type(<FONT COLOR=#FF0000>""</FONT>):
            self.__ParseString(rawdata)
        <FONT COLOR=black><B>else</B></FONT>:
            self.update(rawdata)
        <FONT COLOR=black><B>return</B></FONT>
    <FONT COLOR=#1111CC># end load()</FONT>

    <FONT COLOR=black><B>def</B></FONT> __ParseString(self, str, patt=_CookiePattern):
        i = 0            <FONT COLOR=#1111CC># Our starting point</FONT>
        n = len(str)     <FONT COLOR=#1111CC># Length of string</FONT>
        M = None         <FONT COLOR=#1111CC># current morsel</FONT>

        <FONT COLOR=black><B>while</B></FONT> 0 &lt;= i &lt; n:
            <FONT COLOR=#1111CC># Start looking for a cookie</FONT>
            match = patt.search(str, i)
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> match: <FONT COLOR=black><B>break</B></FONT>          <FONT COLOR=#1111CC># No more cookies</FONT>

            K,V = match.group(<FONT COLOR=#FF0000>"key"</FONT>), match.group(<FONT COLOR=#FF0000>"val"</FONT>)
            i = match.end(0)

            <FONT COLOR=#1111CC># Parse the key, value in case it's metainfo</FONT>
            <FONT COLOR=black><B>if</B></FONT> K[0] == <FONT COLOR=#FF0000>"$"</FONT>:
                <FONT COLOR=#1111CC># We ignore attributes which pertain to the cookie</FONT>
                <FONT COLOR=#1111CC># mechanism as a whole.  See RFC 2109.</FONT>
                <FONT COLOR=#1111CC># (Does anyone care?)</FONT>
                <FONT COLOR=black><B>if</B></FONT> M:
                    M[ K[1:] ] = V
            <FONT COLOR=black><B>elif</B></FONT> string.lower(K) <FONT COLOR=black><B>in</B></FONT> Morsel._reserved_keys:
                <FONT COLOR=black><B>if</B></FONT> M:
                    M[ K ] = _unquote(V)
            <FONT COLOR=black><B>else</B></FONT>:
                rval, cval = self.value_decode(V)
                self.__set(K, rval, cval)
                M = self[K]
    <FONT COLOR=#1111CC># end __ParseString</FONT>
<FONT COLOR=#1111CC># end BaseCookie class</FONT>

<FONT COLOR=black><B>class</B></FONT> SimpleCookie(BaseCookie):
    <FONT COLOR=#FF0000>"""SimpleCookie
    SimpleCookie supports strings as cookie values.  When setting
    the value using the dictionary assignment notation, SimpleCookie
    calls the builtin str() to convert the value to a string.  Values
    received from HTTP are kept as strings.
    """</FONT>
    <FONT COLOR=black><B>def</B></FONT> value_decode(self, val):
        <FONT COLOR=black><B>return</B></FONT> _unquote( val ), val
    <FONT COLOR=black><B>def</B></FONT> value_encode(self, val):
        strval = str(val)
        <FONT COLOR=black><B>return</B></FONT> strval, _quote( strval )
<FONT COLOR=#1111CC># end SimpleCookie</FONT>

<FONT COLOR=black><B>class</B></FONT> SerialCookie(BaseCookie):
    <FONT COLOR=#FF0000>"""SerialCookie
    SerialCookie supports arbitrary objects as cookie values. All
    values are serialized (using cPickle) before being sent to the
    client.  All incoming values are assumed to be valid Pickle
    representations.  IF AN INCOMING VALUE IS NOT IN A VALID PICKLE
    FORMAT, THEN AN EXCEPTION WILL BE RAISED.

    Note: Large cookie values add overhead because they must be
    retransmitted on every HTTP transaction.

    Note: HTTP has a 2k limit on the size of a cookie.  This class
    does not check for this limit, so be careful!!!
    """</FONT>
    <FONT COLOR=black><B>def</B></FONT> value_decode(self, val):
        <FONT COLOR=#1111CC># This could raise an exception!</FONT>
        <FONT COLOR=black><B>return</B></FONT> loads( _unquote(val) ), val
    <FONT COLOR=black><B>def</B></FONT> value_encode(self, val):
        <FONT COLOR=black><B>return</B></FONT> val, _quote( dumps(val) )
<FONT COLOR=#1111CC># end SerialCookie</FONT>

<FONT COLOR=black><B>class</B></FONT> SmartCookie(BaseCookie):
    <FONT COLOR=#FF0000>"""SmartCookie
    SmartCookie supports arbitrary objects as cookie values.  If the
    object is a string, then it is quoted.  If the object is not a
    string, however, then SmartCookie will use cPickle to serialize
    the object into a string representation.

    Note: Large cookie values add overhead because they must be
    retransmitted on every HTTP transaction.

    Note: HTTP has a 2k limit on the size of a cookie.  This class
    does not check for this limit, so be careful!!!
    """</FONT>
    <FONT COLOR=black><B>def</B></FONT> value_decode(self, val):
        strval = _unquote(val)
        <FONT COLOR=black><B>try</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> loads(strval), val
        <FONT COLOR=black><B>except</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> strval, val
    <FONT COLOR=black><B>def</B></FONT> value_encode(self, val):
        <FONT COLOR=black><B>if</B></FONT> type(val) == type(<FONT COLOR=#FF0000>""</FONT>):
            <FONT COLOR=black><B>return</B></FONT> val, _quote(val)
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> val, _quote( dumps(val) )
<FONT COLOR=#1111CC># end SmartCookie</FONT>


<FONT COLOR=#1111CC>###########################################################</FONT>
<FONT COLOR=#1111CC># Backwards Compatibility:  Don't break any existing code!</FONT>

<FONT COLOR=#1111CC># We provide Cookie() as an alias for SmartCookie()</FONT>
Cookie = SmartCookie

<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC>###########################################################</FONT>

<FONT COLOR=black><B>def</B></FONT> _test():
    <FONT COLOR=black><B>import</B></FONT> doctest, Cookie
    <FONT COLOR=black><B>return</B></FONT> doctest.testmod(Cookie)

<FONT COLOR=black><B>if</B></FONT> __name__ == <FONT COLOR=#FF0000>"__main__"</FONT>:
    _test()


<FONT COLOR=#1111CC>#Local Variables:</FONT>
<FONT COLOR=#1111CC>#tab-width: 4</FONT>
<FONT COLOR=#1111CC>#end:</FONT>
</PRE>
                  <!--footer-->
                  </BODY>
