<HTML><HEAD><TITLE>MiscUtils/__init__.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=#1111CC># MiscUtils component</FONT>
<FONT COLOR=#1111CC># Webware for Python</FONT>
<FONT COLOR=#1111CC># See Docs/index.html</FONT>

__all__ = [<FONT COLOR=#FF0000>'Configurable'</FONT>, <FONT COLOR=#FF0000>'DBPool'</FONT>, <FONT COLOR=#FF0000>'DataTable'</FONT>, <FONT COLOR=#FF0000>'DictForArgs'</FONT>, <FONT COLOR=#FF0000>'Error'</FONT>, <FONT COLOR=#FF0000>'Funcs'</FONT>, <FONT COLOR=#FF0000>'MixIn'</FONT>, <FONT COLOR=#FF0000>'NamedValueAccess'</FONT>, <FONT COLOR=#FF0000>'PropertiesObject'</FONT>, <FONT COLOR=#FF0000>'unittest'</FONT>]


<FONT COLOR=black><B>try</B></FONT>:
    AbstractError  <FONT COLOR=#1111CC># Python might build this in some day.</FONT>
<FONT COLOR=black><B>except</B></FONT> NameError:
    <FONT COLOR=black><B>class</B></FONT> AbstractError(NotImplementedError):
        <FONT COLOR=#FF0000>"""
        This exception is raised by abstract methods in abstract classes. It
        is a special case of NotImplementedError, that indicates that the
        implementation won't ever be provided at that location in the future
        --instead the subclass should provide it.

        Typical usage:

            from MiscUtils import AbstractError

            class Foo:
                def bar(self):
                    raise AbstractError, self.__class__

        Note that added the self.__class__ makes the resulting exception
        *much* more useful.
        """</FONT>
        <FONT COLOR=black><B>pass</B></FONT>

<FONT COLOR=#1111CC># @@ 2002-11-10 ce: SubclassResponsibilityError is deprecated in favor of AbstractError, post 0.7</FONT>
SubclassResponsibilityError = AbstractError


<FONT COLOR=black><B>class</B></FONT> NoDefault:
    <FONT COLOR=#FF0000>"""
    This provides a singleton "thing" which can be used to initialize
    the "default=" arguments for different retrieval methods. For
    example:

        from MiscUtils import NoDefault
        def bar(self, name, default=NoDefault):
            if default is NoDefault:
                return self._bars[name]  # will raise exception for invalid key
            else:
                return self._bars.get(name, default)

    The value None does not suffice for "default=" because it does not
    indicate whether or not a value was passed.

    Consistently using this singleton is valuable due to subclassing
    situations:

        def bar(self, name, default=NoDefault):
            if someCondition:
                return self.specialBar(name)
            else:
                return SuperClass.bar(name, default)

    It's also useful if one method that uses "default=NoDefault" relies
    on another object and method to which it must pass the default.
    (This is similar to the subclassing situation.)
    """</FONT>
    <FONT COLOR=black><B>pass</B></FONT>


<FONT COLOR=black><B>def</B></FONT> InstallInWebKit(appServer):
    <FONT COLOR=black><B>pass</B></FONT>
</PRE>
                  <!--footer-->
                  </BODY>
