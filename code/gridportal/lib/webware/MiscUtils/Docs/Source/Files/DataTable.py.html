<HTML><HEAD><TITLE>MiscUtils/DataTable.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=#FF0000>"""
DataTable.py


INTRODUCTION

This class is useful for representing a table of data arranged by named
columns, where each row in the table can be thought of as a record:

    name   phoneNumber
    ------ -----------
    Chuck  893-3498
    Bill   893-0439
    John   893-5901

This data often comes from delimited text files which typically
have well defined columns or fields with several rows each of which can
be thought of as a record.

Using a DataTable can be as easy as using lists and dictionaries:

    table = DataTable('users.csv')
    for row in table:
        print row['name'], row['phoneNumber']

Or even:

    table = DataTable('users.csv')
    for row in table:
        print '%(name)s %(phoneNumber)s' % row

The above print statement relies on the fact that rows can be treated
like dictionaries, using the column headings as keys.

You can also treat a row like an array:

    table = DataTable('something.tabbed', delimiter='\t')
    for row in table:
        for item in row:
            print item,
        print


COLUMNS

Column headings can have a type specification like so:
    name, age:int, zip:int

Possible types include string, int, float and datetime. However,
datetime is not well supported right now.

String is assumed if no type is specified but you can set that
assumption when you create the table:

        table = DataTable(headings, defaultType='float')

Using types like int and float will cause DataTable to actually
convert the string values (perhaps read from a file) to these types
so that you can use them in natural operations. For example:

    if row['age']&gt;120:
        self.flagData(row, 'age looks high')

As you can see, each row can be accessed as a dictionary with keys
according the column headings. Names are case sensitive.


ADDING ROWS

Like Python lists, data tables have an append() method. You can append
TableRecords, or you pass a dictionary, list or object, in which case a
TableRecord is created based on given values. See the method docs below
for more details.


FILES

By default, the files that DataTable reads from are expected to be
comma-separated value files.

Limited comments are supported: A comment is any line whose very first
character is a #. This allows you to easily comment out lines in your
data files without having to remove them.

Whitespace around field values is stripped.

You can control all this behavior through the arguments found in the
initializer and the various readFoo() methods:

    ...delimiter=',', allowComments=1, stripWhite=1

For example:

    table = DataTable('foo.tabbed', delimiter='\t', allowComments=0, stripWhite=0)

You should access these parameters by their name since additional ones
could appear in the future, thereby changing the order.

If you are creating these text files, we recommend the
comma-separated-value format, or CSV. This format is better defined
than the tab delimited format, and can easily be edited and manipulated
by popular spreadsheets and databases.


TABLES FROM SCRATCH

Here's an example that constructs a table from scratch:

    table = DataTable(['name', 'age:int'])
    table.append(['John', 80])
    table.append({'name': 'John', 'age': 80})
    print table


QUERIES

A simple query mechanism is supported for equality of fields:

    matches = table.recordsEqualTo({'uid': 5})
    if matches:
        for match in matches:
            print match
    else:
        print 'No matches.'


COMMON USES

* Programs can keep configuration and other data in simple comma-
separated text files and use DataTable to access them. For example, a
web site could read it's sidebar links from such a file, thereby
allowing people who don't know Python (or even HTML) to edit these
links without having to understand other implementation parts of the
site.

* Servers can use DataTable to read and write log files.


FROM THE COMMAND LINE

The only purpose in invoking DataTable from the command line is to see
if it will read a file:

&gt; python DataTable.py foo.csv

The data table is printed to stdout.


CACHING

DataTable uses "pickle caching" so that it can read .csv files faster
on subsequent loads. You can disable this across the board with:
    from MiscUtils.DataTable import DataTable
    DataTable.usePickleCache = 0

Or per instance by passing "usePickleCache=0" to the constructor.

See the docstring of PickleCache.py for more information.


MORE DOCS

Some of the methods in this module have worthwhile doc strings to look
at. See below.


TO DO

* Allow callback parameter or setting for parsing CSV records.
* Perhaps TableRecord should inherit UserList and UserDict and override methods as appropriate...?
* Better support for datetime.
* _types and BlankValues aren't really packaged, advertised or
  documented for customization by the user of this module.
* DataTable:
    * Parameterize the TextColumn class.
    * Parameterize the TableRecord class.
    * More list-like methods such as insert()
    * writeFileNamed() is flawed: it doesn't write the table column
      type
    * Should it inherit from UserList?
* Add error checking that a column name is not a number (which could
  cause problems).
* Look for various @@ tags through out the code.

"""</FONT>


<FONT COLOR=black><B>import</B></FONT> string, sys
<FONT COLOR=black><B>from</B></FONT> CSVParser <FONT COLOR=black><B>import</B></FONT> CSVParser
<FONT COLOR=black><B>from</B></FONT> string <FONT COLOR=black><B>import</B></FONT> join, replace, split, strip
<FONT COLOR=black><B>from</B></FONT> types <FONT COLOR=black><B>import</B></FONT> *
<FONT COLOR=black><B>from</B></FONT> MiscUtils <FONT COLOR=black><B>import</B></FONT> NoDefault
<FONT COLOR=black><B>try</B></FONT>:
    <FONT COLOR=black><B>from</B></FONT> mx.DateTime <FONT COLOR=black><B>import</B></FONT> DateTimeType, DateTimeFrom
<FONT COLOR=black><B>except</B></FONT> ImportError:
    <FONT COLOR=black><B>pass</B></FONT>

<FONT COLOR=#1111CC>## Types ##</FONT>

DateTimeType = <FONT COLOR=#FF0000>"&lt;custom-type 'datetime'&gt;"</FONT>
ObjectType = <FONT COLOR=#FF0000>"&lt;type 'Object'&gt;"</FONT>

_types = {
    <FONT COLOR=#FF0000>'string'</FONT>:   StringType,
    <FONT COLOR=#FF0000>'int'</FONT>:      IntType,
    <FONT COLOR=#FF0000>'long'</FONT>:     LongType,
    <FONT COLOR=#FF0000>'float'</FONT>:    FloatType,
    <FONT COLOR=#FF0000>'datetime'</FONT>: DateTimeType,
    <FONT COLOR=#FF0000>'object'</FONT>:   ObjectType,
}


<FONT COLOR=#1111CC>## Classes ##</FONT>


<FONT COLOR=black><B>class</B></FONT> DataTableError(Exception):
    <FONT COLOR=black><B>pass</B></FONT>


<FONT COLOR=black><B>class</B></FONT> TableColumn:
    <FONT COLOR=#FF0000>"""
    A table column represents a column of the table including name and
    type.

    It does not contain the actual values of the column. These are
    stored individually in the rows.
    """</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, spec):

        <FONT COLOR=#1111CC># spec is a string such as 'name' or 'name:type'</FONT>
        fields = split(spec, <FONT COLOR=#FF0000>':'</FONT>)
        <FONT COLOR=black><B>if</B></FONT> len(fields)&gt;2:
            <FONT COLOR=black><B>raise</B></FONT> DataTableError, <FONT COLOR=#FF0000>'Invalid column spec %s'</FONT> % repr(spec)
        self._name = fields[0]

        <FONT COLOR=black><B>if</B></FONT> len(fields)==1:
            self._type = None
        <FONT COLOR=black><B>else</B></FONT>:
            self.setType(fields[1])

    <FONT COLOR=black><B>def</B></FONT> name(self):
        <FONT COLOR=black><B>return</B></FONT> self._name

    <FONT COLOR=black><B>def</B></FONT> type(self):
        <FONT COLOR=black><B>return</B></FONT> self._type

    <FONT COLOR=black><B>def</B></FONT> setType(self, type):
        <FONT COLOR=#FF0000>""" Sets the type (by a string containing the name) of the heading. Usually invoked by DataTable to set the default type for columns whose types were not specified. """</FONT>
        <FONT COLOR=black><B>if</B></FONT> type==None:
            self._type = None
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>try</B></FONT>:
                self._type = _types[type]
            <FONT COLOR=black><B>except</B></FONT>:
                <FONT COLOR=black><B>raise</B></FONT> DataTableError, <FONT COLOR=#FF0000>'Unknown type %s'</FONT> % repr(type)

    <FONT COLOR=black><B>def</B></FONT> __repr__(self):
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>'&lt;TableColumn %s with %s at %x&gt;'</FONT> % (
            repr(self._name), repr(self._type), id(self))

    <FONT COLOR=black><B>def</B></FONT> __str__(self):
        <FONT COLOR=black><B>return</B></FONT> self._name


    <FONT COLOR=#1111CC>## Utilities ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> valueForRawValue(self, rawValue):
        <FONT COLOR=#FF0000>""" The rawValue is typically a string or value already of the appropriate type. TableRecord invokes this method to ensure that values (especially strings that come from files) are the correct types (e.g., ints are ints and floats are floats). """</FONT>
        <FONT COLOR=#1111CC># @@ 2000-07-23 ce: an if-else ladder? perhaps these should be dispatched messages or a class hier</FONT>
        <FONT COLOR=black><B>if</B></FONT> self._type <FONT COLOR=black><B>is</B></FONT> StringType:
            value = str(rawValue)
        <FONT COLOR=black><B>elif</B></FONT> self._type <FONT COLOR=black><B>is</B></FONT> IntType:
            <FONT COLOR=black><B>if</B></FONT> rawValue==<FONT COLOR=#FF0000>''</FONT>:
                value = 0
            <FONT COLOR=black><B>else</B></FONT>:
                value = int(rawValue)
        <FONT COLOR=black><B>elif</B></FONT> self._type <FONT COLOR=black><B>is</B></FONT> LongType:
            <FONT COLOR=black><B>if</B></FONT> rawValue==<FONT COLOR=#FF0000>''</FONT>:
                value = 0
            <FONT COLOR=black><B>else</B></FONT>:
                value = long(rawValue)
        <FONT COLOR=black><B>elif</B></FONT> self._type <FONT COLOR=black><B>is</B></FONT> FloatType:
            <FONT COLOR=black><B>if</B></FONT> rawValue==<FONT COLOR=#FF0000>''</FONT>:
                value = 0.0
            <FONT COLOR=black><B>else</B></FONT>:
                value = float(rawValue)
        <FONT COLOR=black><B>elif</B></FONT> self._type <FONT COLOR=black><B>is</B></FONT> DateTimeType:
            value = DateTimeFrom(rawValue)
        <FONT COLOR=black><B>elif</B></FONT> self._type <FONT COLOR=black><B>is</B></FONT> ObjectType:
            value = rawValue
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>raise</B></FONT> DataTableError, <FONT COLOR=#FF0000>'Unknown column type "%s"'</FONT> % self._type
        <FONT COLOR=black><B>return</B></FONT> value


<FONT COLOR=black><B>class</B></FONT> DataTable:
    <FONT COLOR=#FF0000>"""
    See the doc string for this module.
    """</FONT>

    usePickleCache = 1


    <FONT COLOR=#1111CC>## Init ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, filenameOrHeadings=None, delimiter=<FONT COLOR=#FF0000>','</FONT>, allowComments=1, stripWhite=1, defaultType=<FONT COLOR=#FF0000>'string'</FONT>, usePickleCache=None):
        <FONT COLOR=black><B>if</B></FONT> usePickleCache <FONT COLOR=black><B>is</B></FONT> None:
            self.usePickleCache = self.usePickleCache  <FONT COLOR=#1111CC># grab the class-level attr</FONT>
        <FONT COLOR=black><B>else</B></FONT>:
            self.usePickleCache = usePickleCache
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> _types.has_key(defaultType):
            <FONT COLOR=black><B>raise</B></FONT> DataTableError, <FONT COLOR=#FF0000>'Unknown type for default type: %s'</FONT> % repr(defaultType)
        self._defaultType = defaultType
        self._filename = None
        self._headings = []
        self._rows = []
        <FONT COLOR=black><B>if</B></FONT> filenameOrHeadings:
            <FONT COLOR=black><B>if</B></FONT> type(filenameOrHeadings) <FONT COLOR=black><B>is</B></FONT> StringType:
                self.readFileNamed(filenameOrHeadings, delimiter, allowComments, stripWhite)
            <FONT COLOR=black><B>else</B></FONT>:
                self.setHeadings(filenameOrHeadings)


    <FONT COLOR=#1111CC>## File I/O ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> readFileNamed(self, filename, delimiter=<FONT COLOR=#FF0000>','</FONT>, allowComments=1, stripWhite=1):
        self._filename = filename
        data = None
        <FONT COLOR=black><B>if</B></FONT> self.usePickleCache:
            <FONT COLOR=black><B>from</B></FONT> PickleCache <FONT COLOR=black><B>import</B></FONT> readPickleCache, writePickleCache
            data = readPickleCache(filename, pickleVersion=1, source=<FONT COLOR=#FF0000>'MiscUtils.DataTable'</FONT>)
        <FONT COLOR=black><B>if</B></FONT> data <FONT COLOR=black><B>is</B></FONT> None:
            file = open(self._filename, <FONT COLOR=#FF0000>'r'</FONT>)
            self.readFile(file, delimiter, allowComments, stripWhite)
            file.close()
            <FONT COLOR=black><B>if</B></FONT> self.usePickleCache:
                writePickleCache(self, filename, pickleVersion=1, source=<FONT COLOR=#FF0000>'MiscUtils.DataTable'</FONT>)
        <FONT COLOR=black><B>else</B></FONT>:
            self.__dict__ = data.__dict__
        <FONT COLOR=black><B>return</B></FONT> self

    <FONT COLOR=black><B>def</B></FONT> readFile(self, file, delimiter=<FONT COLOR=#FF0000>','</FONT>, allowComments=1, stripWhite=1):
        <FONT COLOR=black><B>return</B></FONT> self.readLines(file.readlines(), delimiter, allowComments, stripWhite)

    <FONT COLOR=black><B>def</B></FONT> readString(self, string, delimiter=<FONT COLOR=#FF0000>','</FONT>, allowComments=1, stripWhite=1):
        <FONT COLOR=black><B>return</B></FONT> self.readLines(split(string, <FONT COLOR=#FF0000>'\n'</FONT>), delimiter, allowComments, stripWhite)

    <FONT COLOR=black><B>def</B></FONT> readLines(self, lines, delimiter=<FONT COLOR=#FF0000>','</FONT>, allowComments=1, stripWhite=1):
        haveReadHeadings = 0
        parse = CSVParser(fieldSep=delimiter, allowComments=allowComments, stripWhitespace=stripWhite).parse
        <FONT COLOR=black><B>for</B></FONT> line <FONT COLOR=black><B>in</B></FONT> lines:
            <FONT COLOR=#1111CC># process a row, either headings or data</FONT>
            values = parse(line)
            <FONT COLOR=black><B>if</B></FONT> values:
                <FONT COLOR=black><B>if</B></FONT> haveReadHeadings:
                    row = TableRecord(self, values)
                    self._rows.append(row)
                <FONT COLOR=black><B>else</B></FONT>:
                    self.setHeadings(values)
                    self.createNameToIndexMap()
                    haveReadHeadings = 1
        <FONT COLOR=black><B>if</B></FONT> values <FONT COLOR=black><B>is</B></FONT> None:
            <FONT COLOR=black><B>raise</B></FONT> DataTableError, <FONT COLOR=#FF0000>"Unfinished multiline record."</FONT>
        <FONT COLOR=black><B>return</B></FONT> self

    <FONT COLOR=black><B>def</B></FONT> save(self):
        self.writeFileNamed(self._filename)

    <FONT COLOR=black><B>def</B></FONT> writeFileNamed(self, filename):
        file = open(filename, <FONT COLOR=#FF0000>'w'</FONT>)
        self.writeFile(file)
        file.close()

    <FONT COLOR=black><B>def</B></FONT> writeFile(self, file):
        <FONT COLOR=#FF0000>"""
        @@ 2000-07-20 ce: This doesn't write the column types (like :int) back out.
        @@ 2000-07-21 ce: It's notable that a blank numeric value gets read as zero and written out that way. Also, values None are written as blanks.
        """</FONT>

        <FONT COLOR=#1111CC># write headings</FONT>
        file.write(join(map(<FONT COLOR=black><B>lambda</B></FONT> h: str(h), self._headings), <FONT COLOR=#FF0000>','</FONT>))
        file.write(<FONT COLOR=#FF0000>'\n'</FONT>)

        <FONT COLOR=black><B>def</B></FONT> ValueWritingMapper(item):
            <FONT COLOR=#1111CC># So that None gets written as a blank and everything else as a string</FONT>
            <FONT COLOR=black><B>if</B></FONT> item <FONT COLOR=black><B>is</B></FONT> None:
                <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>''</FONT>
            <FONT COLOR=black><B>else</B></FONT>:
                <FONT COLOR=black><B>return</B></FONT> str(item)

        <FONT COLOR=#1111CC># write rows</FONT>
        <FONT COLOR=black><B>for</B></FONT> row <FONT COLOR=black><B>in</B></FONT> self._rows:
            file.write(join(map(ValueWritingMapper, row), <FONT COLOR=#FF0000>','</FONT>))
            file.write(<FONT COLOR=#FF0000>'\n'</FONT>)

    <FONT COLOR=black><B>def</B></FONT> commit(self):
        <FONT COLOR=black><B>if</B></FONT> self._changed:
            self.save()
            self._changed = 0


    <FONT COLOR=#1111CC>## Headings ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> heading(self, index):
        <FONT COLOR=black><B>if</B></FONT> type(key) <FONT COLOR=black><B>is</B></FONT> StringType:
            key = self._nameToIndexMap[key]
        <FONT COLOR=black><B>return</B></FONT> self._headings[index]

    <FONT COLOR=black><B>def</B></FONT> hasHeading(self, name):
        <FONT COLOR=black><B>return</B></FONT> self._nameToIndexMap.has_key(name)

    <FONT COLOR=black><B>def</B></FONT> numHeadings(self):
        <FONT COLOR=black><B>return</B></FONT> len(self._headings)

    <FONT COLOR=black><B>def</B></FONT> headings(self):
        <FONT COLOR=black><B>return</B></FONT> self._headings

    <FONT COLOR=black><B>def</B></FONT> setHeadings(self, headings):
        <FONT COLOR=#FF0000>""" Headings can be a list of strings (like ['name', 'age:int']) or a list of TableColumns or None. """</FONT>
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> headings:
            self._headings = []
        <FONT COLOR=black><B>elif</B></FONT> type(headings[0]) <FONT COLOR=black><B>is</B></FONT> StringType:
            self._headings = map(<FONT COLOR=black><B>lambda</B></FONT> h: TableColumn(h), headings)
        <FONT COLOR=black><B>elif</B></FONT> isinstance(headings[0], TableColumn):
            self._headings = list(headings)
        <FONT COLOR=black><B>for</B></FONT> heading <FONT COLOR=black><B>in</B></FONT> self._headings:
            <FONT COLOR=black><B>if</B></FONT> heading.type() <FONT COLOR=black><B>is</B></FONT> None:
                heading.setType(self._defaultType)
        self.createNameToIndexMap()


    <FONT COLOR=#1111CC>## Row access (list like) ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __len__(self):
        <FONT COLOR=black><B>return</B></FONT> len(self._rows)

    <FONT COLOR=black><B>def</B></FONT> __getitem__(self, index):
        <FONT COLOR=black><B>return</B></FONT> self._rows[index]

    <FONT COLOR=black><B>def</B></FONT> append(self, object):
        <FONT COLOR=#FF0000>""" If object is not a TableRecord, then one is created, passing the object to initialize the TableRecord. Therefore, object can be a TableRecord, list, dictionary or object. See TableRecord for details. """</FONT>

        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> isinstance(object, TableRecord):
            object = TableRecord(self, object)
        self._rows.append(object)
        self._changed = 1


    <FONT COLOR=#1111CC>## Queries ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> recordsEqualTo(self, dict):
        records = []
        keys = dict.keys()
        <FONT COLOR=black><B>for</B></FONT> record <FONT COLOR=black><B>in</B></FONT> self._rows:
            matches = 1
            <FONT COLOR=black><B>for</B></FONT> key <FONT COLOR=black><B>in</B></FONT> keys:
                <FONT COLOR=black><B>if</B></FONT> record[key]!=dict[key]:
                    matches = 0
                    <FONT COLOR=black><B>break</B></FONT>
            <FONT COLOR=black><B>if</B></FONT> matches:
                records.append(record)
        <FONT COLOR=black><B>return</B></FONT> records


    <FONT COLOR=#1111CC>## As a string ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __repr__(self):
        <FONT COLOR=#1111CC># Initial info</FONT>
        s = [<FONT COLOR=#FF0000>'DataTable: %s\n%d rows\n'</FONT> % (self._filename, len(self._rows))]

        <FONT COLOR=#1111CC># Headings</FONT>
        s.append(<FONT COLOR=#FF0000>'     '</FONT>)
        s.append(join(map(<FONT COLOR=black><B>lambda</B></FONT> h: str(h), self._headings), <FONT COLOR=#FF0000>', '</FONT>))
        s.append(<FONT COLOR=#FF0000>'\n'</FONT>)

        <FONT COLOR=#1111CC># Records</FONT>
        i = 0
        <FONT COLOR=black><B>for</B></FONT> row <FONT COLOR=black><B>in</B></FONT> self._rows:
            s.append(<FONT COLOR=#FF0000>'%3d. '</FONT> % i)
            s.append(join(map(<FONT COLOR=black><B>lambda</B></FONT> r: str(r), row), <FONT COLOR=#FF0000>', '</FONT>))
            s.append(<FONT COLOR=#FF0000>'\n'</FONT>)
            i = i + 1
        <FONT COLOR=black><B>return</B></FONT> join(s, <FONT COLOR=#FF0000>''</FONT>)


    <FONT COLOR=#1111CC>## As a dictionary ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> dictKeyedBy(self, key):
        <FONT COLOR=#FF0000>""" Returns a dictionary containing the contents of the table indexed by the particular key. This is useful for tables that have a column which represents a unique key (such as a name, serial number, etc.). """</FONT>
        dict = {}
        <FONT COLOR=black><B>for</B></FONT> row <FONT COLOR=black><B>in</B></FONT> self:
            dict[row[key]] = row
        <FONT COLOR=black><B>return</B></FONT> dict


    <FONT COLOR=#1111CC>## Misc access ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> filename(self):
        <FONT COLOR=black><B>return</B></FONT> self._filename

    <FONT COLOR=black><B>def</B></FONT> nameToIndexMap(self):
        <FONT COLOR=#FF0000>""" Table rows keep a reference to this map in order to speed up index-by-names (as in row['name']). """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._nameToIndexMap


    <FONT COLOR=#1111CC>## Self utilities ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> createNameToIndexMap(self):
        <FONT COLOR=#FF0000>"""
        Invoked by self to create the nameToIndexMap after the table's
        headings have been read/initialized.
        """</FONT>
        map = {}
        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> range(len(self._headings)):
            map[self._headings[i].name()] = i
        self._nameToIndexMap = map


<FONT COLOR=#1111CC># @@ 2000-07-20 ce: perhaps for each type we could specify a function to convert from string values to the values of the type</FONT>

BlankValues = {
    StringType:   <FONT COLOR=#FF0000>''</FONT>,
    IntType:      0,
    FloatType:    0.0,
    DateTimeType: <FONT COLOR=#FF0000>''</FONT>,
}


<FONT COLOR=black><B>class</B></FONT> TableRecord:

    <FONT COLOR=#1111CC>## Init ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, table, values=None):
        <FONT COLOR=#FF0000>"""
        Dispatches control to one of the other init methods based on the type of values.  Values can be one of three things:
            1. A TableRecord
            2. A list
            3. A dictionary
            4. Any object responding to hasValueForKey() and valueForKey().
        """</FONT>
        self._headings = table.headings()
        self._nameToIndexMap = table.nameToIndexMap()
        <FONT COLOR=#1111CC># @@ 2000-07-20 ce: Take out the headings arg to the init method since we have an attribute for that</FONT>

        <FONT COLOR=black><B>if</B></FONT> values <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None:
            valuesType = type(values)
            <FONT COLOR=black><B>if</B></FONT> valuesType <FONT COLOR=black><B>is</B></FONT> ListType  <FONT COLOR=black><B>or</B></FONT>  valuesType <FONT COLOR=black><B>is</B></FONT> TupleType:
                <FONT COLOR=#1111CC># @@ 2000-07-20 ce: check for required attributes instead</FONT>
                self.initFromSequence(values)
            <FONT COLOR=black><B>elif</B></FONT> valuesType <FONT COLOR=black><B>is</B></FONT> DictType:
                self.initFromDict(values)
            <FONT COLOR=black><B>elif</B></FONT> valuesType <FONT COLOR=black><B>is</B></FONT> InstanceType:
                self.initFromObject(value)
            <FONT COLOR=black><B>else</B></FONT>:
                <FONT COLOR=black><B>raise</B></FONT> DataTableError, <FONT COLOR=#FF0000>'Unknown type for values %s.'</FONT> % valuesType

    <FONT COLOR=black><B>def</B></FONT> initFromSequence(self, values):
        <FONT COLOR=black><B>if</B></FONT> len(self._headings)&lt;len(values):
            <FONT COLOR=black><B>raise</B></FONT> DataTableError, (<FONT COLOR=#FF0000>'There are more values than headings.\nheadings(%d, %s)\nvalues(%d, %s)'</FONT> % (len(self._headings), self._headings, len(values), values))
        self._values = []
        numHeadings = len(self._headings)
        numValues = len(values)
        <FONT COLOR=black><B>assert</B></FONT> numValues&lt;=numHeadings
        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> range(numHeadings):
            heading = self._headings[i]
            <FONT COLOR=black><B>if</B></FONT> i&gt;=numValues:
                self._values.append(BlankValues[heading.type()])
            <FONT COLOR=black><B>else</B></FONT>:
                self._values.append(heading.valueForRawValue(values[i]))

    <FONT COLOR=black><B>def</B></FONT> initFromDict(self, dict):
        self._values = []
        <FONT COLOR=black><B>for</B></FONT> heading <FONT COLOR=black><B>in</B></FONT> self._headings:
            name = heading.name()
            <FONT COLOR=black><B>if</B></FONT> dict.has_key(name):
                self._values.append(heading.valueForRawValue(dict[name]))
            <FONT COLOR=black><B>else</B></FONT>:
                self._values.append(BlankValues[heading.type()])

    <FONT COLOR=black><B>def</B></FONT> initFromObject(self, object):
        <FONT COLOR=#FF0000>"""
        The object is expected to response to hasValueForKey(name) and
        valueForKey(name) for each of the headings in the table. It's
        alright if the object returns 0 for hasValueForKey(). In that
        case, a "blank" value is assumed (such as zero or an empty
        string). If hasValueForKey() returns 1, then valueForKey() must
        return a value.
        """</FONT>
        self._values = []
        <FONT COLOR=black><B>for</B></FONT> heading <FONT COLOR=black><B>in</B></FONT> self._headings:
            name = heading.name()
            <FONT COLOR=black><B>if</B></FONT> object.hasValueForKey(name):
                self._values.append(heading.valueForRawValue(object.valueForKey(name)))
            <FONT COLOR=black><B>else</B></FONT>:
                self._values.append(BlankValues[heading.type()])


    <FONT COLOR=#1111CC>## Accessing like a sequence or dictionary ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __len__(self):
        <FONT COLOR=black><B>return</B></FONT> len(self._values)

    <FONT COLOR=black><B>def</B></FONT> __getitem__(self, key):
        <FONT COLOR=black><B>if</B></FONT> type(key) <FONT COLOR=black><B>is</B></FONT> StringType:
            key = self._nameToIndexMap[key]
        <FONT COLOR=black><B>return</B></FONT> self._values[key]

    <FONT COLOR=black><B>def</B></FONT> __setitem__(self, key, value):
        <FONT COLOR=black><B>if</B></FONT> type(key) <FONT COLOR=black><B>is</B></FONT> StringType:
            key = self._nameToIndexMap[key]
        self._values[key] = value

    <FONT COLOR=black><B>def</B></FONT> __repr__(self):
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>'%s'</FONT> % self._values

    <FONT COLOR=black><B>def</B></FONT> get(self, key, default=None):
        index = self._nameToIndexMap.get(key, None)
        <FONT COLOR=black><B>if</B></FONT> index <FONT COLOR=black><B>is</B></FONT> None:
            <FONT COLOR=black><B>return</B></FONT> default
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> self._values[index]

    <FONT COLOR=black><B>def</B></FONT> has_key(self, key):
        <FONT COLOR=black><B>return</B></FONT> self._nameToIndexMap.has_key(key)

    <FONT COLOR=black><B>def</B></FONT> keys(self):
        <FONT COLOR=black><B>return</B></FONT> self._nameToIndexMap.keys()

    <FONT COLOR=black><B>def</B></FONT> values(self):
        <FONT COLOR=black><B>return</B></FONT> self._values

    <FONT COLOR=black><B>def</B></FONT> items(self):
        items = []
        <FONT COLOR=black><B>for</B></FONT> key <FONT COLOR=black><B>in</B></FONT> self.keys():
            items.append((key, self[key]))
        <FONT COLOR=black><B>return</B></FONT> items


    <FONT COLOR=#1111CC>## Additional access ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> asList(self):
        <FONT COLOR=#FF0000>"""
        Returns a sequence whose values are the same at the record's
        and in the order defined by the table.
        """</FONT>
        <FONT COLOR=#1111CC># It just so happens that our implementation already has this</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._values[:]

    <FONT COLOR=black><B>def</B></FONT> asDict(self):
        <FONT COLOR=#FF0000>""" Returns a dictionary whose key-values match the table record. """</FONT>
        dict = {}
        nameToIndexMap = self._nameToIndexMap
        <FONT COLOR=black><B>for</B></FONT> key <FONT COLOR=black><B>in</B></FONT> nameToIndexMap.keys():
            dict[key] = self._values[nameToIndexMap[key]]
        <FONT COLOR=black><B>return</B></FONT> dict


    <FONT COLOR=#1111CC>## valueForFoo() family ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> valueForKey(self, key, default=NoDefault):
        <FONT COLOR=black><B>if</B></FONT> default <FONT COLOR=black><B>is</B></FONT> NoDefault:
            <FONT COLOR=black><B>return</B></FONT> self[key]
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> self.get(key, default)

    <FONT COLOR=black><B>def</B></FONT> valueForAttr(self, attr, default=NoDefault):
        <FONT COLOR=black><B>return</B></FONT> self.valueForKey(attr[<FONT COLOR=#FF0000>'Name'</FONT>], default)



<FONT COLOR=black><B>def</B></FONT> main(args=None):
    <FONT COLOR=black><B>if</B></FONT> args <FONT COLOR=black><B>is</B></FONT> None:
        args = sys.argv
    <FONT COLOR=black><B>for</B></FONT> arg <FONT COLOR=black><B>in</B></FONT> args[1:]:
        dt = DataTable(arg)
        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'*** %s ***'</FONT> % arg
        <FONT COLOR=black><B>print</B></FONT> dt
        <FONT COLOR=black><B>print</B></FONT>


<FONT COLOR=black><B>if</B></FONT> __name__==<FONT COLOR=#FF0000>'__main__'</FONT>:
    main()
</PRE>
                  <!--footer-->
                  </BODY>
