<HTML><HEAD><TITLE>MiscUtils/PickleCache.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=#FF0000>"""
PickleCache provides tools for keeping fast-loading cached versions of
files so that subsequent loads are faster. This is similar to how Python
silently caches .pyc files next to .py files.

The typical scenario is that you have a type of text file that gets
"translated" to Pythonic data (dictionaries, tuples, instances, ints,
etc.). By caching the Python data on disk in pickle format, you can
avoid the expensive translation on subsequent reads of the file.

Two real life cases are MiscUtils.DataTable, which loads and represents
comma-separated files, and MiddleKit which has an object model file.
So for examples on using this module, load up the following files and
search for "Pickle":
    Webware/MiscUtils/DataTable.py
    MiddleKit/Core/Model.py

The cached file is named the same as the original file with
'.pickle.cache' suffixed. The utility of '.pickle' is to denote the file
format and the utilty of '.cache' is to provide '*.cache' as a simple
pattern that can be removed, ignored by backup scripts, etc.

The treatment of the cached file is silent and friendly just like
Python's approach to .pyc files. If it cannot be read or written for
various reasons (cache is out of date, permissions are bad, wrong python
version, etc.), then it will be silently ignored.


GRANULARITY

In constructing the test suite, I discovered that if the source file is
newly written less than 1 second after the cached file, then the fact
that the source file is newer will not be detected and the cache will
still be used. I believe this is a limitation of the granularity of
os.path.getmtime(). If anyone knows of a more granular solution, please
let me know.

This would only be a problem in programmatic situations where the source
file was rapidly being written and read. I think that's fairly rare.


PYTHON VERSION

These operations do nothing if you don't have Python 2.2 or greater.


SEE ALSO
    http://www.python.org/doc/current/lib/module-pickle.html

- wordwrap bar --------------------------------------------------------
"""</FONT>

verbose = 0


<FONT COLOR=black><B>import</B></FONT> os, sys, time
<FONT COLOR=black><B>from</B></FONT> types <FONT COLOR=black><B>import</B></FONT> DictType
<FONT COLOR=black><B>from</B></FONT> pprint <FONT COLOR=black><B>import</B></FONT> pprint
<FONT COLOR=black><B>try</B></FONT>:
    <FONT COLOR=black><B>from</B></FONT> cPickle <FONT COLOR=black><B>import</B></FONT> load, dump
<FONT COLOR=black><B>except</B></FONT> ImportError:
    <FONT COLOR=black><B>from</B></FONT> pickle <FONT COLOR=black><B>import</B></FONT> load, dump

havePython22OrGreater = sys.version_info[0]&gt;2 <FONT COLOR=black><B>or</B></FONT> (sys.version_info[0]==2 <FONT COLOR=black><B>and</B></FONT> sys.version_info[1]&gt;=2)


s =<FONT COLOR=#FF0000>"""
def readPickleCache(filename, pickleVersion=1, source=None, verbose=None):
    return _reader.read(filename, pickleVersion, source, verbose)

def writePickleCache(data, filename, pickleVersion=1, source=None, verbose=None):
    return _writer.write(data, filename, pickleVersion, source, verbose)
"""</FONT>


<FONT COLOR=black><B>class</B></FONT> PickleCache:
    <FONT COLOR=#FF0000>"""
    Just a simple abstract base class for PickleCacheReader and
    PickleCacheWriter.
    """</FONT>
    verbose = verbose

    <FONT COLOR=black><B>def</B></FONT> picklePath(self, filename):
        <FONT COLOR=black><B>return</B></FONT> filename + <FONT COLOR=#FF0000>'.pickle.cache'</FONT>


<FONT COLOR=black><B>class</B></FONT> PickleCacheReader(PickleCache):

    <FONT COLOR=black><B>def</B></FONT> read(self, filename, pickleVersion=1, source=None, verbose=None):
        <FONT COLOR=#FF0000>"""
        Returns the data from the pickle cache version of the filename, if it can read. Otherwise returns None which also indicates that writePickleCache() should be subsequently called after the original file is read.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> verbose <FONT COLOR=black><B>is</B></FONT> None:
            v = self.verbose
        <FONT COLOR=black><B>else</B></FONT>:
            v = verbose
        <FONT COLOR=black><B>if</B></FONT> v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; PickleCacheReader.read() - verbose is on'</FONT>
        <FONT COLOR=black><B>assert</B></FONT> filename

        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> os.path.exists(filename):
            <FONT COLOR=#1111CC>#if </FONT>v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'cannot find %r'</FONT> % filename
            open(filename) <FONT COLOR=#1111CC># to get a properly constructed IOError</FONT>

        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> havePython22OrGreater:
            <FONT COLOR=#1111CC>#if </FONT>v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'Python version is too old for this. Returning None.'</FONT>
            <FONT COLOR=black><B>return</B></FONT> None

        didReadPickle = 0
        shouldDeletePickle = 0

        data = None

        picklePath = self.picklePath(filename)
        <FONT COLOR=black><B>if</B></FONT> os.path.exists(picklePath):
            <FONT COLOR=black><B>if</B></FONT> os.path.getmtime(picklePath)&lt;os.path.getmtime(filename):
                <FONT COLOR=#1111CC>#if </FONT>v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'cache is out of date'</FONT>
                shouldDeletePickle = 1
            <FONT COLOR=black><B>else</B></FONT>:
                <FONT COLOR=black><B>try</B></FONT>:
                    <FONT COLOR=#1111CC>#if </FONT>v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'about to open for read %r'</FONT> % picklePath
                    file = open(picklePath)
                <FONT COLOR=black><B>except</B></FONT> IOError, e:
                    <FONT COLOR=#1111CC>#if </FONT>v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'cannot open cache file: %s: %s'</FONT> % (e.__class__.__name__, e)
                    <FONT COLOR=black><B>pass</B></FONT>
                <FONT COLOR=black><B>else</B></FONT>:
                    <FONT COLOR=black><B>try</B></FONT>:
                        <FONT COLOR=#1111CC>#if </FONT>v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'about to load'</FONT>
                        dict = load(file)
                    <FONT COLOR=black><B>except</B></FONT> EOFError:
                        <FONT COLOR=#1111CC>#if </FONT>v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'EOFError - not loading'</FONT>
                        shouldDeletePickle = 1
                    <FONT COLOR=black><B>else</B></FONT>:
                        file.close()
                        <FONT COLOR=#1111CC>#if </FONT>v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'finished reading'</FONT>
                        <FONT COLOR=black><B>assert</B></FONT> isinstance(dict, DictType), <FONT COLOR=#FF0000>'type=%r dict=%r'</FONT> % (type(dict), dict)
                        <FONT COLOR=black><B>for</B></FONT> key <FONT COLOR=black><B>in</B></FONT> (<FONT COLOR=#FF0000>'source'</FONT>, <FONT COLOR=#FF0000>'data'</FONT>, <FONT COLOR=#FF0000>'pickle version'</FONT>, <FONT COLOR=#FF0000>'python version'</FONT>):
                            <FONT COLOR=black><B>assert</B></FONT> dict.has_key(key), key
                        <FONT COLOR=black><B>if</B></FONT> source <FONT COLOR=black><B>and</B></FONT> dict[<FONT COLOR=#FF0000>'source'</FONT>]!=source:
                            <FONT COLOR=#1111CC>#if </FONT>v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'not from required source (%s): %s'</FONT> % (source, dict[<FONT COLOR=#FF0000>'source'</FONT>])
                            shouldDeletePickle = 1
                        <FONT COLOR=black><B>elif</B></FONT> dict[<FONT COLOR=#FF0000>'pickle version'</FONT>]!=pickleVersion:
                            <FONT COLOR=#1111CC>#if </FONT>v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'pickle version (%i) does not match expected (%i)'</FONT> % (dict[<FONT COLOR=#FF0000>'pickle version'</FONT>], pickleVersion)
                            shouldDeletePickle = 1
                        <FONT COLOR=black><B>elif</B></FONT> dict[<FONT COLOR=#FF0000>'python version'</FONT>]!=sys.version_info:
                            <FONT COLOR=#1111CC>#if </FONT>v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'python version %s does not match current %s'</FONT> % (dict[<FONT COLOR=#FF0000>'python version'</FONT>], sys.version_info)
                            shouldDeletePickle = 1
                        <FONT COLOR=black><B>else</B></FONT>:
                            <FONT COLOR=#1111CC>#if </FONT>v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'all tests pass. accepting data'</FONT>
                            <FONT COLOR=black><B>if</B></FONT> v&gt;1:
                                <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'display full dict:'</FONT>
                                pprint(dict)
                            data = dict[<FONT COLOR=#FF0000>'data'</FONT>]
                            didReadPickle = 1

        <FONT COLOR=#1111CC># delete the pickle file if suggested by previous conditions</FONT>
        <FONT COLOR=black><B>if</B></FONT> shouldDeletePickle:
            <FONT COLOR=black><B>try</B></FONT>:
                <FONT COLOR=#1111CC>#if </FONT>v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'attempting to remove pickle cache file'</FONT>
                os.remove(picklePath)
            <FONT COLOR=black><B>except</B></FONT> OSError, e:
                <FONT COLOR=black><B>if</B></FONT> v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'failed to remove: %s: %s'</FONT> % (e.__class__.__name__, e)
                <FONT COLOR=black><B>pass</B></FONT>

        <FONT COLOR=black><B>if</B></FONT> v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'done reading data'</FONT>; <FONT COLOR=black><B>print</B></FONT>

        <FONT COLOR=black><B>return</B></FONT> data


<FONT COLOR=black><B>class</B></FONT> PickleCacheWriter(PickleCache):

    writeSleepInterval = 0.1

    <FONT COLOR=black><B>def</B></FONT> write(self, data, filename, pickleVersion=1, source=None, verbose=None):
        <FONT COLOR=black><B>if</B></FONT> verbose <FONT COLOR=black><B>is</B></FONT> None:
            v = self.verbose
        <FONT COLOR=black><B>else</B></FONT>:
            v = verbose
        <FONT COLOR=black><B>if</B></FONT> v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; PickleCacheWriter.write() - verbose is on'</FONT>
        <FONT COLOR=black><B>assert</B></FONT> filename
        sourceTimestamp = os.path.getmtime(filename)

        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> havePython22OrGreater:
            <FONT COLOR=#1111CC>#if </FONT>v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'Python version is too old for this. Returning None.'</FONT>
            <FONT COLOR=black><B>return</B></FONT> None

        picklePath = self.picklePath(filename)
        dict = {
            <FONT COLOR=#FF0000>'source'</FONT>: source,
            <FONT COLOR=#FF0000>'python version'</FONT>: sys.version_info,
            <FONT COLOR=#FF0000>'pickle version'</FONT>: pickleVersion,
            <FONT COLOR=#FF0000>'data'</FONT>: data,
        }
        <FONT COLOR=black><B>if</B></FONT> v&gt;1:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'display full dict:'</FONT>
            pprint(dict)
        <FONT COLOR=black><B>try</B></FONT>:
            <FONT COLOR=black><B>if</B></FONT> v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'about to open for write %r'</FONT> % picklePath
            file = open(picklePath, <FONT COLOR=#FF0000>'w'</FONT>)
        <FONT COLOR=black><B>except</B></FONT> IOError, e:
            <FONT COLOR=black><B>if</B></FONT> v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'error. not writing. %s: %s'</FONT> % (e.__class__.__name__, e)
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>while</B></FONT> 1:
                dump(dict, file, 1)   <FONT COLOR=#1111CC># 1 = binary format</FONT>
                file.close()
                <FONT COLOR=#1111CC># make sure the cache has a newer timestamp, otherwise the cache will</FONT>
                <FONT COLOR=#1111CC># just get ignored and rewritten next time.</FONT>
                <FONT COLOR=black><B>if</B></FONT> os.path.getmtime(picklePath)==sourceTimestamp:
                    <FONT COLOR=black><B>if</B></FONT> v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'timestamps are identical. sleeping %0.2f seconds'</FONT> % self.writeSleepInterval
                    time.sleep(self.writeSleepInterval)
                    file = open(picklePath, <FONT COLOR=#FF0000>'w'</FONT>)
                <FONT COLOR=black><B>else</B></FONT>:
                    <FONT COLOR=black><B>break</B></FONT>

        <FONT COLOR=black><B>if</B></FONT> v: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'done writing data'</FONT>; <FONT COLOR=black><B>print</B></FONT>


<FONT COLOR=#1111CC># define module level convenience functions, readPickleCache and writePickleCache:</FONT>

_reader = PickleCacheReader(); readPickleCache  = _reader.read
_writer = PickleCacheWriter(); writePickleCache = _writer.write
</PRE>
                  <!--footer-->
                  </BODY>
