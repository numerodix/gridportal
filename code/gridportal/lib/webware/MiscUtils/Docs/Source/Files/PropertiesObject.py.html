<HTML><HEAD><TITLE>MiscUtils/PropertiesObject.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=black><B>from</B></FONT> UserDict <FONT COLOR=black><B>import</B></FONT> UserDict
<FONT COLOR=black><B>import</B></FONT> os, string, sys, types

<FONT COLOR=black><B>class</B></FONT> WillNotRunError(Exception): <FONT COLOR=black><B>pass</B></FONT>


<FONT COLOR=black><B>class</B></FONT> PropertiesObject(UserDict):
    <FONT COLOR=#FF0000>"""
    A PropertiesObject represents, in a dictionary-like fashion, the values found in a Properties.py file. That file is always included with a Webware component to advertise its name, version, status, etc. Note that a Webware component is a Python package that follows additional conventions. Also, the top level Webware directory contains a Properties.py.

    Component properties are often used for:
        * generation of documentation
        * runtime examination of components, especially prior to loading

    PropertiesObject provides additional keys:
        * filename - the filename from which the properties were read
        * versionString - a nicely printable string of the version
        * requiredPyVersionString - like versionString but for requiredPyVersion instead
        * willRun - 1 if the component will run. So far that means having the right Python version.
        * willNotRunReason - defined only if willRun is 0. contains a readable error message

    Using a PropertiesObject is better than investigating the Properties.py file directly, because the rules for determining derived keys and any future convenience methods will all be provided here.

    Usage example:
        from MiscUtils.PropertiesObject import PropertiesObject
        props = PropertiesObject(filename)
        for item in props.items():
            print '%s: %s' % item

    Note: We don't normally suffix a class name with "Object" as we have with this class, however, the name Properties.py is already used in our containing package and all other packages.
    """</FONT>


    <FONT COLOR=#1111CC>## Init and reading ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, filename=None):
        UserDict.__init__(self)
        <FONT COLOR=black><B>if</B></FONT> filename:
            self.readFileNamed(filename)

    <FONT COLOR=black><B>def</B></FONT> readFileNamed(self, filename):
        self[<FONT COLOR=#FF0000>'filename'</FONT>] = filename
        results = {}
        <FONT COLOR=black><B>exec</B></FONT> open(filename) <FONT COLOR=black><B>in</B></FONT> results
        <FONT COLOR=#1111CC># @@ 2001-01-20 ce: try "...in self"</FONT>
        self.update(results)
        self.cleanPrivateItems()
        self.createDerivedItems()


    <FONT COLOR=#1111CC>## Self utility ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> cleanPrivateItems(self):
        <FONT COLOR=#FF0000>""" Removes items whose keys start with a double underscore, such as __builtins__. """</FONT>
        <FONT COLOR=black><B>for</B></FONT> key <FONT COLOR=black><B>in</B></FONT> self.keys():
            <FONT COLOR=black><B>if</B></FONT> key[:2]==<FONT COLOR=#FF0000>'__'</FONT>:
                <FONT COLOR=black><B>del</B></FONT> self[key]

    <FONT COLOR=black><B>def</B></FONT> createDerivedItems(self):
        self.createVersionString()
        self.createRequiredPyVersionString()
        self.createWillRun()

    <FONT COLOR=black><B>def</B></FONT> _versionString(self, version):
        <FONT COLOR=#FF0000>""" For a sequence containing version information such as (2, 0, 0, 'pre'), this returns a printable string such as '2.0-pre'. The micro version number is only excluded from the string if it is zero. """</FONT>
        ver = map(<FONT COLOR=black><B>lambda</B></FONT> x: str(x), version)
        <FONT COLOR=black><B>if</B></FONT> ver[2]==<FONT COLOR=#FF0000>'0'</FONT>: <FONT COLOR=#1111CC># e.g., if minor version is 0</FONT>
            numbers = ver[:2]
        <FONT COLOR=black><B>else</B></FONT>:
            numbers = ver[:3]
        rest = ver[3:]
        numbers = string.join(numbers, <FONT COLOR=#FF0000>'.'</FONT>)
        rest = string.join(rest, <FONT COLOR=#FF0000>'-'</FONT>)
        <FONT COLOR=black><B>if</B></FONT> rest:
            <FONT COLOR=black><B>return</B></FONT> numbers + rest
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> numbers

    <FONT COLOR=black><B>def</B></FONT> createVersionString(self):
        self[<FONT COLOR=#FF0000>'versionString'</FONT>] = self._versionString(self[<FONT COLOR=#FF0000>'version'</FONT>])

    <FONT COLOR=black><B>def</B></FONT> createRequiredPyVersionString(self):
        self[<FONT COLOR=#FF0000>'requiredPyVersionString'</FONT>] = self._versionString(self[<FONT COLOR=#FF0000>'requiredPyVersion'</FONT>])

    <FONT COLOR=black><B>def</B></FONT> createWillRun(self):
        self[<FONT COLOR=#FF0000>'willRun'</FONT>] = 0
        <FONT COLOR=black><B>try</B></FONT>:
            <FONT COLOR=#1111CC># Invoke each of the checkFoo() methods</FONT>
            <FONT COLOR=black><B>for</B></FONT> key <FONT COLOR=black><B>in</B></FONT> self.willRunKeys():
                methodName = <FONT COLOR=#FF0000>'check'</FONT> + string.upper(key[0]) + key[1:]
                method = getattr(self, methodName)
                method()
        <FONT COLOR=black><B>except</B></FONT> WillNotRunError, msg:
            self[<FONT COLOR=#FF0000>'willNotRunReason'</FONT>] = msg
            <FONT COLOR=black><B>return</B></FONT>
        self[<FONT COLOR=#FF0000>'willRun'</FONT>] = 1  <FONT COLOR=#1111CC># we passed all the tests</FONT>

    <FONT COLOR=black><B>def</B></FONT> willRunKeys(self):
        <FONT COLOR=#FF0000>""" Returns a list of keys whose values should be examined in order to determine if the component will run. Used by createWillRun(). """</FONT>
        <FONT COLOR=black><B>return</B></FONT> [<FONT COLOR=#FF0000>'requiredPyVersion'</FONT>, <FONT COLOR=#FF0000>'requiredOpSys'</FONT>, <FONT COLOR=#FF0000>'deniedOpSys'</FONT>, <FONT COLOR=#FF0000>'willRunFunc'</FONT>]

    <FONT COLOR=black><B>def</B></FONT> checkRequiredPyVersion(self):
        pyVer = getattr(sys, <FONT COLOR=#FF0000>'version_info'</FONT>, None)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> pyVer:
            <FONT COLOR=#1111CC># Prior 2.0 there was no version_info</FONT>
            <FONT COLOR=#1111CC># So we parse it out of .version which is a string</FONT>
            pyVer = string.split(sys.version)[0]
            pyVer = string.split(pyVer, <FONT COLOR=#FF0000>'.'</FONT>)
            pyVer = map(<FONT COLOR=black><B>lambda</B></FONT> x: int(x), pyVer)
        <FONT COLOR=black><B>if</B></FONT> tuple(pyVer)&lt;tuple(self[<FONT COLOR=#FF0000>'requiredPyVersion'</FONT>]):
            <FONT COLOR=black><B>raise</B></FONT> WillNotRunError, <FONT COLOR=#FF0000>'Required python ver is %s, but actual ver is %s.'</FONT> % (self[<FONT COLOR=#FF0000>'requiredPyVersion'</FONT>], pyVer)

    <FONT COLOR=black><B>def</B></FONT> checkRequiredOpSys(self):
        requiredOpSys = self.get(<FONT COLOR=#FF0000>'requiredOpSys'</FONT>, None)
        <FONT COLOR=black><B>if</B></FONT> requiredOpSys:
            <FONT COLOR=#1111CC># We accept a string or list of strings</FONT>
            <FONT COLOR=black><B>if</B></FONT> type(requiredOpSys)==types.StringType:
                requiredOpSys = [requiredOpSys]
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> os.name <FONT COLOR=black><B>in</B></FONT> requiredOpSys:
                <FONT COLOR=black><B>raise</B></FONT> WillNotRunError, <FONT COLOR=#FF0000>'Required op sys is %s, but actual op sys is %s.'</FONT> % (requiredOpSys, os.name)

    <FONT COLOR=black><B>def</B></FONT> checkDeniedOpSys(self):
        deniedOpSys = self.get(<FONT COLOR=#FF0000>'deniedOpSys'</FONT>, None)
        <FONT COLOR=black><B>if</B></FONT> deniedOpSys:
            <FONT COLOR=#1111CC># We accept a string or list of strings</FONT>
            <FONT COLOR=black><B>if</B></FONT> type(deniedOpSys)==types.StringType:
                deniedOpSys = [deniedOpSys]
            <FONT COLOR=black><B>if</B></FONT> os.name <FONT COLOR=black><B>in</B></FONT> deniedOpSys:
                <FONT COLOR=black><B>raise</B></FONT> WillNotRunError, <FONT COLOR=#FF0000>'Will not run on op sys %s and actual op sys is %s.'</FONT> % (deniedOpSys, os.name)

    <FONT COLOR=black><B>def</B></FONT> checkRequiredSoftware(self):
        <FONT COLOR=#FF0000>""" Not implemented. No op right now. """</FONT>
        <FONT COLOR=#1111CC># Check required software</FONT>
        <FONT COLOR=#1111CC># @@ 2001-01-24 ce: TBD</FONT>
        <FONT COLOR=#1111CC># Issues include:</FONT>
        <FONT COLOR=#1111CC>#     - order of dependencies</FONT>
        <FONT COLOR=#1111CC>#     - circular dependencies</FONT>
        <FONT COLOR=#1111CC>#     - examining Properties and willRun of dependencies</FONT>
        reqSoft = self.get(<FONT COLOR=#FF0000>'requiredSoftware'</FONT>, None)
        <FONT COLOR=black><B>if</B></FONT> reqSoft:
            <FONT COLOR=black><B>for</B></FONT> soft <FONT COLOR=black><B>in</B></FONT> reqSoft:
                <FONT COLOR=#1111CC># type, name, version</FONT>
                <FONT COLOR=black><B>pass</B></FONT>

    <FONT COLOR=black><B>def</B></FONT> checkWillRunFunc(self):
        willRunFunc = self.get(<FONT COLOR=#FF0000>'willRunFunc'</FONT>, None)
        <FONT COLOR=black><B>if</B></FONT> willRunFunc:
            whyNotMsg = willRunFunc()
            <FONT COLOR=black><B>if</B></FONT> whyNotMsg:
                <FONT COLOR=black><B>raise</B></FONT> WillNotRunError, whyNotMsg
</PRE>
                  <!--footer-->
                  </BODY>
