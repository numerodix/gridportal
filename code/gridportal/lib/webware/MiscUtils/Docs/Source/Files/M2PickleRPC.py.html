<HTML><HEAD><TITLE>MiscUtils/M2PickleRPC.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=#FF0000>"""
M2Crypto-enhanced transport for PickleRPC

This lets you use M2Crypto for SSL encryption.

Based on m2xmlrpclib.py which is
    Copyright (c) 1999-2002 Ng Pheng Siong. All rights reserved
"""</FONT>

<FONT COLOR=black><B>from</B></FONT> PickleRPC <FONT COLOR=black><B>import</B></FONT> Transport
<FONT COLOR=black><B>import</B></FONT> base64, string, sys
<FONT COLOR=black><B>from</B></FONT> M2Crypto <FONT COLOR=black><B>import</B></FONT> SSL, httpslib, m2urllib
<FONT COLOR=black><B>try</B></FONT>:
    <FONT COLOR=black><B>from</B></FONT> cStringIO <FONT COLOR=black><B>import</B></FONT> StringIO
<FONT COLOR=black><B>except</B></FONT> ImportError:
    <FONT COLOR=black><B>from</B></FONT> StringIO <FONT COLOR=black><B>import</B></FONT> StringIO

__version__ = 1   <FONT COLOR=#1111CC># version of M2PickleRPC</FONT>

<FONT COLOR=black><B>class</B></FONT> M2Transport(Transport):
    user_agent = <FONT COLOR=#FF0000>"M2PickleRPC.py/%s - %s"</FONT> % (__version__, Transport.user_agent)

    <FONT COLOR=black><B>def</B></FONT> __init__(self, ssl_context=None):
        <FONT COLOR=black><B>if</B></FONT> ssl_context <FONT COLOR=black><B>is</B></FONT> None:
            self.ssl_ctx=SSL.Context(<FONT COLOR=#FF0000>'sslv23'</FONT>)
        <FONT COLOR=black><B>else</B></FONT>:
            self.ssl_ctx=ssl_context

    <FONT COLOR=black><B>def</B></FONT> make_connection(self, host):
        _host, _port = m2urllib.splitport(host)
        <FONT COLOR=black><B>if</B></FONT> sys.version[0] == <FONT COLOR=#FF0000>'2'</FONT>:
            <FONT COLOR=black><B>return</B></FONT> httpslib.HTTPS(_host, int(_port), ssl_context=self.ssl_ctx)
        <FONT COLOR=black><B>elif</B></FONT> sys.version[:3] ==  <FONT COLOR=#FF0000>'1.5'</FONT>:
            <FONT COLOR=black><B>return</B></FONT> httpslib.HTTPS(self.ssl_ctx, _host, int(_port))
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>raise</B></FONT> RuntimeError, <FONT COLOR=#FF0000>'unsupported Python version'</FONT>

    <FONT COLOR=#1111CC># @@ workarounds below are necessary because M2Crypto seems to</FONT>
    <FONT COLOR=#1111CC># return from fileobject.read() early!  So we have to call it</FONT>
    <FONT COLOR=#1111CC># over and over to get the full data.</FONT>
    
    <FONT COLOR=black><B>def</B></FONT> parse_response(self, f):
        <FONT COLOR=#FF0000>"""
        Workaround M2Crypto issue mentioned above
        """</FONT>
        sio = StringIO()
        <FONT COLOR=black><B>while</B></FONT> 1:
            chunk = f.read()
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> chunk:
                <FONT COLOR=black><B>break</B></FONT>
            sio.write(chunk)
        sio.seek(0)
        <FONT COLOR=black><B>return</B></FONT> Transport.parse_response(self, sio)

    <FONT COLOR=black><B>def</B></FONT> parse_response_gzip(self, f):
        <FONT COLOR=#FF0000>"""
        Workaround M2Crypto issue mentioned above
        """</FONT>
        sio = StringIO()
        <FONT COLOR=black><B>while</B></FONT> 1:
            chunk = f.read()
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> chunk:
                <FONT COLOR=black><B>break</B></FONT>
            sio.write(chunk)
        sio.seek(0)
        <FONT COLOR=black><B>return</B></FONT> Transport.parse_response_gzip(self, sio)

</PRE>
                  <!--footer-->
                  </BODY>
