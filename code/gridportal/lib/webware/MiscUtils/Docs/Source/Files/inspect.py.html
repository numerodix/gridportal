<HTML><HEAD><TITLE>MiscUtils/inspect.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=#FF0000>"""Get useful information from live Python objects.

This module encapsulates the interface provided by the internal special
attributes (func_*, co_*, im_*, tb_*, etc.) in a friendlier fashion.
It also provides some help for examining source code and class layout.

Here are some of the useful functions provided by this module:

    ismodule(), isclass(), ismethod(), isfunction(), istraceback(),
        isframe(), iscode(), isbuiltin(), isroutine() - check object types
    getmembers() - get members of an object that satisfy a given condition

    getfile(), getsourcefile(), getsource() - find an object's source code
    getdoc(), getcomments() - get documentation on an object
    getmodule() - determine the module that an object came from
    getclasstree() - arrange classes so as to represent their hierarchy

    getargspec(), getargvalues() - get info about function arguments
    formatargspec(), formatargvalues() - format an argument spec
    getouterframes(), getinnerframes() - get info about frames
    currentframe() - get the current stack frame
    stack(), trace() - get info about frames on the stack or in a traceback
"""</FONT>

<FONT COLOR=#1111CC># This module is in the public domain.  No warranties.</FONT>

__author__ = <FONT COLOR=#FF0000>'Ka-Ping Yee &lt;ping@lfw.org&gt;'</FONT>
__date__ = <FONT COLOR=#FF0000>'1 Jan 2001'</FONT>

<FONT COLOR=black><B>import</B></FONT> sys, os, types, string, re, dis, imp, tokenize

<FONT COLOR=#1111CC># ----------------------------------------------------------- type-checking</FONT>
<FONT COLOR=black><B>def</B></FONT> ismodule(object):
    <FONT COLOR=#FF0000>"""Return true if the object is a module.

    Module objects provide these attributes:
        __doc__         documentation string
        __file__        filename (missing for built-in modules)"""</FONT>
    <FONT COLOR=black><B>return</B></FONT> type(object) <FONT COLOR=black><B>is</B></FONT> types.ModuleType

<FONT COLOR=black><B>def</B></FONT> isclass(object):
    <FONT COLOR=#FF0000>"""Return true if the object is a class.

    Class objects provide these attributes:
        __doc__         documentation string
        __module__      name of module in which this class was defined"""</FONT>
    <FONT COLOR=black><B>return</B></FONT> type(object) <FONT COLOR=black><B>is</B></FONT> types.ClassType <FONT COLOR=black><B>or</B></FONT> hasattr(object, <FONT COLOR=#FF0000>'__bases__'</FONT>)

<FONT COLOR=black><B>def</B></FONT> ismethod(object):
    <FONT COLOR=#FF0000>"""Return true if the object is an instance method.

    Instance method objects provide these attributes:
        __doc__         documentation string
        __name__        name with which this method was defined
        im_class        class object in which this method belongs
        im_func         function object containing implementation of method
        im_self         instance to which this method is bound, or None"""</FONT>
    <FONT COLOR=black><B>return</B></FONT> type(object) <FONT COLOR=black><B>is</B></FONT> types.MethodType

<FONT COLOR=black><B>def</B></FONT> isfunction(object):
    <FONT COLOR=#FF0000>"""Return true if the object is a user-defined function.

    Function objects provide these attributes:
        __doc__         documentation string
        __name__        name with which this function was defined
        func_code       code object containing compiled function bytecode
        func_defaults   tuple of any default values for arguments
        func_doc        (same as __doc__)
        func_globals    global namespace in which this function was defined
        func_name       (same as __name__)"""</FONT>
    <FONT COLOR=black><B>return</B></FONT> type(object) <FONT COLOR=black><B>in</B></FONT> [types.FunctionType, types.LambdaType]

<FONT COLOR=black><B>def</B></FONT> istraceback(object):
    <FONT COLOR=#FF0000>"""Return true if the object is a traceback.

    Traceback objects provide these attributes:
        tb_frame        frame object at this level
        tb_lasti        index of last attempted instruction in bytecode
        tb_lineno       current line number in Python source code
        tb_next         next inner traceback object (called by this level)"""</FONT>
    <FONT COLOR=black><B>return</B></FONT> type(object) <FONT COLOR=black><B>is</B></FONT> types.TracebackType

<FONT COLOR=black><B>def</B></FONT> isframe(object):
    <FONT COLOR=#FF0000>"""Return true if the object is a frame object.

    Frame objects provide these attributes:
        f_back          next outer frame object (this frame's caller)
        f_builtins      built-in namespace seen by this frame
        f_code          code object being executed in this frame
        f_exc_traceback traceback if raised in this frame, or None
        f_exc_type      exception type if raised in this frame, or None
        f_exc_value     exception value if raised in this frame, or None
        f_globals       global namespace seen by this frame
        f_lasti         index of last attempted instruction in bytecode
        f_lineno        current line number in Python source code
        f_locals        local namespace seen by this frame
        f_restricted    0 or 1 if frame is in restricted execution mode
        f_trace         tracing function for this frame, or None"""</FONT>
    <FONT COLOR=black><B>return</B></FONT> type(object) <FONT COLOR=black><B>is</B></FONT> types.FrameType

<FONT COLOR=black><B>def</B></FONT> iscode(object):
    <FONT COLOR=#FF0000>"""Return true if the object is a code object.

    Code objects provide these attributes:
        co_argcount     number of arguments (not including * or ** args)
        co_code         string of raw compiled bytecode
        co_consts       tuple of constants used in the bytecode
        co_filename     name of file in which this code object was created
        co_firstlineno  number of first line in Python source code
        co_flags        bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
        co_lnotab       encoded mapping of line numbers to bytecode indices
        co_name         name with which this code object was defined
        co_names        tuple of names of local variables
        co_nlocals      number of local variables
        co_stacksize    virtual machine stack space required
        co_varnames     tuple of names of arguments and local variables"""</FONT>
    <FONT COLOR=black><B>return</B></FONT> type(object) <FONT COLOR=black><B>is</B></FONT> types.CodeType

<FONT COLOR=black><B>def</B></FONT> isbuiltin(object):
    <FONT COLOR=#FF0000>"""Return true if the object is a built-in function or method.

    Built-in functions and methods provide these attributes:
        __doc__         documentation string
        __name__        original name of this function or method
        __self__        instance to which a method is bound, or None"""</FONT>
    <FONT COLOR=black><B>return</B></FONT> type(object) <FONT COLOR=black><B>is</B></FONT> types.BuiltinFunctionType

<FONT COLOR=black><B>def</B></FONT> isroutine(object):
    <FONT COLOR=#FF0000>"""Return true if the object is any kind of function or method."""</FONT>
    <FONT COLOR=black><B>return</B></FONT> isbuiltin(object) <FONT COLOR=black><B>or</B></FONT> isfunction(object) <FONT COLOR=black><B>or</B></FONT> ismethod(object)

<FONT COLOR=black><B>def</B></FONT> getmembers(object, predicate=None):
    <FONT COLOR=#FF0000>"""Return all members of an object as (name, value) pairs sorted by name.
    Optionally, only return members that satisfy a given predicate."""</FONT>
    results = []
    <FONT COLOR=black><B>for</B></FONT> key <FONT COLOR=black><B>in</B></FONT> dir(object):
        value = getattr(object, key)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> predicate <FONT COLOR=black><B>or</B></FONT> predicate(value):
            results.append((key, value))
    results.sort()
    <FONT COLOR=black><B>return</B></FONT> results

<FONT COLOR=#1111CC># -------------------------------------------------- source code extraction</FONT>
<FONT COLOR=black><B>def</B></FONT> indentsize(line):
    <FONT COLOR=#FF0000>"""Return the indent size, in spaces, at the start of a line of text."""</FONT>
    expline = string.expandtabs(line)
    <FONT COLOR=black><B>return</B></FONT> len(expline) - len(string.lstrip(expline))

<FONT COLOR=black><B>def</B></FONT> getdoc(object):
    <FONT COLOR=#FF0000>"""Get the documentation string for an object.

    All tabs are expanded to spaces.  To clean up docstrings that are
    indented to line up with blocks of code, any whitespace than can be
    uniformly removed from the second line onwards is removed."""</FONT>
    <FONT COLOR=black><B>if</B></FONT> hasattr(object, <FONT COLOR=#FF0000>'__doc__'</FONT>) <FONT COLOR=black><B>and</B></FONT> object.__doc__:
        lines = string.split(string.expandtabs(object.__doc__), <FONT COLOR=#FF0000>'\n'</FONT>)
        margin = None
        <FONT COLOR=black><B>for</B></FONT> line <FONT COLOR=black><B>in</B></FONT> lines[1:]:
            content = len(string.lstrip(line))
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> content: <FONT COLOR=black><B>continue</B></FONT>
            indent = len(line) - content
            <FONT COLOR=black><B>if</B></FONT> margin <FONT COLOR=black><B>is</B></FONT> None: margin = indent
            <FONT COLOR=black><B>else</B></FONT>: margin = min(margin, indent)
        <FONT COLOR=black><B>if</B></FONT> margin <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None:
            <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> range(1, len(lines)): lines[i] = lines[i][margin:]
        <FONT COLOR=black><B>return</B></FONT> string.join(lines, <FONT COLOR=#FF0000>'\n'</FONT>)

<FONT COLOR=black><B>def</B></FONT> getfile(object):
    <FONT COLOR=#FF0000>"""Work out which source or compiled file an object was defined in."""</FONT>
    <FONT COLOR=black><B>if</B></FONT> ismodule(object):
        <FONT COLOR=black><B>if</B></FONT> hasattr(object, <FONT COLOR=#FF0000>'__file__'</FONT>):
            <FONT COLOR=black><B>return</B></FONT> object.__file__
        <FONT COLOR=black><B>raise</B></FONT> TypeError, <FONT COLOR=#FF0000>'arg is a built-in module'</FONT>
    <FONT COLOR=black><B>if</B></FONT> isclass(object):
        object = sys.modules.get(object.__module__)
        <FONT COLOR=black><B>if</B></FONT> hasattr(object, <FONT COLOR=#FF0000>'__file__'</FONT>):
            <FONT COLOR=black><B>return</B></FONT> object.__file__
        <FONT COLOR=black><B>raise</B></FONT> TypeError, <FONT COLOR=#FF0000>'arg is a built-in class'</FONT>
    <FONT COLOR=black><B>if</B></FONT> ismethod(object):
        object = object.im_func
    <FONT COLOR=black><B>if</B></FONT> isfunction(object):
        object = object.func_code
    <FONT COLOR=black><B>if</B></FONT> istraceback(object):
        object = object.tb_frame
    <FONT COLOR=black><B>if</B></FONT> isframe(object):
        object = object.f_code
    <FONT COLOR=black><B>if</B></FONT> iscode(object):
        <FONT COLOR=black><B>return</B></FONT> object.co_filename
    <FONT COLOR=black><B>raise</B></FONT> TypeError, <FONT COLOR=#FF0000>'arg is not a module, class, method, '</FONT> \
                     <FONT COLOR=#FF0000>'function, traceback, frame, or code object'</FONT>

<FONT COLOR=black><B>def</B></FONT> getmoduleinfo(path):
    <FONT COLOR=#FF0000>"""Get the module name, suffix, mode, and module type for a given file."""</FONT>
    filename = os.path.basename(path)
    suffixes = map(<FONT COLOR=black><B>lambda</B></FONT> (suffix, mode, mtype):
                   (-len(suffix), suffix, mode, mtype), imp.get_suffixes())
    suffixes.sort() <FONT COLOR=#1111CC># try longest suffixes first, in case they overlap</FONT>
    <FONT COLOR=black><B>for</B></FONT> neglen, suffix, mode, mtype <FONT COLOR=black><B>in</B></FONT> suffixes:
        <FONT COLOR=black><B>if</B></FONT> filename[neglen:] == suffix:
            <FONT COLOR=black><B>return</B></FONT> filename[:neglen], suffix, mode, mtype

<FONT COLOR=black><B>def</B></FONT> getmodulename(path):
    <FONT COLOR=#FF0000>"""Return the module name for a given file, or None."""</FONT>
    info = getmoduleinfo(path)
    <FONT COLOR=black><B>if</B></FONT> info: <FONT COLOR=black><B>return</B></FONT> info[0]

<FONT COLOR=black><B>def</B></FONT> getsourcefile(object):
    <FONT COLOR=#FF0000>"""Return the Python source file an object was defined in, if it exists."""</FONT>
    filename = getfile(object)
    <FONT COLOR=black><B>if</B></FONT> string.lower(filename[-4:]) <FONT COLOR=black><B>in</B></FONT> [<FONT COLOR=#FF0000>'.pyc'</FONT>, <FONT COLOR=#FF0000>'.pyo'</FONT>]:
        filename = filename[:-4] + <FONT COLOR=#FF0000>'.py'</FONT>
    <FONT COLOR=black><B>for</B></FONT> suffix, mode, kind <FONT COLOR=black><B>in</B></FONT> imp.get_suffixes():
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=#FF0000>'b'</FONT> <FONT COLOR=black><B>in</B></FONT> mode <FONT COLOR=black><B>and</B></FONT> string.lower(filename[-len(suffix):]) == suffix:
            <FONT COLOR=#1111CC># Looks like a binary file.  We want to only return a text file.</FONT>
            <FONT COLOR=black><B>return</B></FONT> None
    <FONT COLOR=black><B>for</B></FONT> path <FONT COLOR=black><B>in</B></FONT> sys.path:
        <FONT COLOR=black><B>if</B></FONT> os.path.exists(os.path.join(path, filename)):
            <FONT COLOR=black><B>return</B></FONT> os.path.join(path, filename)
    <FONT COLOR=black><B>return</B></FONT> None  <FONT COLOR=#1111CC># file was not found.</FONT>

<FONT COLOR=black><B>def</B></FONT> getabsfile(object):
    <FONT COLOR=#FF0000>"""Return an absolute path to the source or compiled file for an object.

    The idea is for each object to have a unique origin, so this routine
    normalizes the result as much as possible."""</FONT>
    <FONT COLOR=black><B>return</B></FONT> os.path.normcase(
        os.path.abspath(getsourcefile(object) <FONT COLOR=black><B>or</B></FONT> getfile(object)))

modulesbyfile = {}

<FONT COLOR=black><B>def</B></FONT> getmodule(object):
    <FONT COLOR=#FF0000>"""Return the module an object was defined in, or None if not found."""</FONT>
    <FONT COLOR=black><B>if</B></FONT> ismodule(object):
        <FONT COLOR=black><B>return</B></FONT> object
    <FONT COLOR=black><B>if</B></FONT> isclass(object):
        <FONT COLOR=black><B>return</B></FONT> sys.modules.get(object.__module__)
    <FONT COLOR=black><B>try</B></FONT>:
        file = getabsfile(object)
    <FONT COLOR=black><B>except</B></FONT> TypeError:
        <FONT COLOR=black><B>return</B></FONT> None
    <FONT COLOR=black><B>if</B></FONT> modulesbyfile.has_key(file):
        <FONT COLOR=black><B>return</B></FONT> sys.modules[modulesbyfile[file]]
    <FONT COLOR=black><B>for</B></FONT> module <FONT COLOR=black><B>in</B></FONT> sys.modules.values():
        <FONT COLOR=black><B>if</B></FONT> hasattr(module, <FONT COLOR=#FF0000>'__file__'</FONT>):
            modulesbyfile[getabsfile(module)] = module.__name__
    <FONT COLOR=black><B>if</B></FONT> modulesbyfile.has_key(file):
        <FONT COLOR=black><B>return</B></FONT> sys.modules[modulesbyfile[file]]
    main = sys.modules[<FONT COLOR=#FF0000>'__main__'</FONT>]
    <FONT COLOR=black><B>if</B></FONT> hasattr(main, object.__name__):
        mainobject = getattr(main, object.__name__)
        <FONT COLOR=black><B>if</B></FONT> mainobject <FONT COLOR=black><B>is</B></FONT> object:
            <FONT COLOR=black><B>return</B></FONT> main
    builtin = sys.modules[<FONT COLOR=#FF0000>'__builtin__'</FONT>]
    <FONT COLOR=black><B>if</B></FONT> hasattr(builtin, object.__name__):
        builtinobject = getattr(builtin, object.__name__)
        <FONT COLOR=black><B>if</B></FONT> builtinobject <FONT COLOR=black><B>is</B></FONT> object:
            <FONT COLOR=black><B>return</B></FONT> builtin

<FONT COLOR=black><B>def</B></FONT> findsource(object):
    <FONT COLOR=#FF0000>"""Return the entire source file and starting line number for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a list of all the lines
    in the file and the line number indexes a line in that list.  An IOError
    is raised if the source code cannot be retrieved."""</FONT>
    <FONT COLOR=black><B>try</B></FONT>:
        file = open(getsourcefile(object))
    <FONT COLOR=black><B>except</B></FONT> (TypeError, IOError):
        <FONT COLOR=black><B>raise</B></FONT> IOError, <FONT COLOR=#FF0000>'could not get source code'</FONT>
    lines = file.readlines()
    file.close()

    <FONT COLOR=black><B>if</B></FONT> ismodule(object):
        <FONT COLOR=black><B>return</B></FONT> lines, 0

    <FONT COLOR=black><B>if</B></FONT> isclass(object):
        name = object.__name__
        pat = re.compile(r<FONT COLOR=#FF0000>'^\s*class\s*'</FONT> + name + r<FONT COLOR=#FF0000>'\b'</FONT>)
        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> range(len(lines)):
            <FONT COLOR=black><B>if</B></FONT> pat.match(lines[i]): <FONT COLOR=black><B>return</B></FONT> lines, i
        <FONT COLOR=black><B>else</B></FONT>: <FONT COLOR=black><B>raise</B></FONT> IOError, <FONT COLOR=#FF0000>'could not find class definition'</FONT>

    <FONT COLOR=black><B>if</B></FONT> ismethod(object):
        object = object.im_func
    <FONT COLOR=black><B>if</B></FONT> isfunction(object):
        object = object.func_code
    <FONT COLOR=black><B>if</B></FONT> istraceback(object):
        object = object.tb_frame
    <FONT COLOR=black><B>if</B></FONT> isframe(object):
        object = object.f_code
    <FONT COLOR=black><B>if</B></FONT> iscode(object):
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> hasattr(object, <FONT COLOR=#FF0000>'co_firstlineno'</FONT>):
            <FONT COLOR=black><B>raise</B></FONT> IOError, <FONT COLOR=#FF0000>'could not find function definition'</FONT>
        lnum = object.co_firstlineno - 1
        pat = re.compile(r<FONT COLOR=#FF0000>'^\s*def\s'</FONT>)
        <FONT COLOR=black><B>while</B></FONT> lnum &gt; 0:
            <FONT COLOR=black><B>if</B></FONT> pat.match(lines[lnum]): <FONT COLOR=black><B>break</B></FONT>
            lnum = lnum - 1
        <FONT COLOR=black><B>return</B></FONT> lines, lnum

<FONT COLOR=black><B>def</B></FONT> getcomments(object):
    <FONT COLOR=#FF0000>"""Get lines of comments immediately preceding an object's source code."""</FONT>
    <FONT COLOR=black><B>try</B></FONT>: lines, lnum = findsource(object)
    <FONT COLOR=black><B>except</B></FONT> IOError: <FONT COLOR=black><B>return</B></FONT> None

    <FONT COLOR=black><B>if</B></FONT> ismodule(object):
        <FONT COLOR=#1111CC># Look for a comment block at the top of the file.</FONT>
        start = 0
        <FONT COLOR=black><B>if</B></FONT> lines <FONT COLOR=black><B>and</B></FONT> lines[0][:2] == <FONT COLOR=#FF0000>'#!'</FONT>: start = 1
        <FONT COLOR=black><B>while</B></FONT> start &lt; len(lines) <FONT COLOR=black><B>and</B></FONT> string.strip(lines[start]) <FONT COLOR=black><B>in</B></FONT> [<FONT COLOR=#FF0000>''</FONT>, <FONT COLOR=#FF0000>'#'</FONT>]:
            start = start + 1
        <FONT COLOR=black><B>if</B></FONT> start &lt; len(lines) <FONT COLOR=black><B>and</B></FONT> lines[start][:1] == <FONT COLOR=#FF0000>'#'</FONT>:
            comments = []
            end = start
            <FONT COLOR=black><B>while</B></FONT> end &lt; len(lines) <FONT COLOR=black><B>and</B></FONT> lines[end][:1] == <FONT COLOR=#FF0000>'#'</FONT>:
                comments.append(string.expandtabs(lines[end]))
                end = end + 1
            <FONT COLOR=black><B>return</B></FONT> string.join(comments, <FONT COLOR=#FF0000>''</FONT>)

    <FONT COLOR=#1111CC># Look for a preceding block of comments at the same indentation.</FONT>
    <FONT COLOR=black><B>elif</B></FONT> lnum &gt; 0:
        indent = indentsize(lines[lnum])
        end = lnum - 1
        <FONT COLOR=black><B>if</B></FONT> end &gt;= 0 <FONT COLOR=black><B>and</B></FONT> string.lstrip(lines[end])[:1] == <FONT COLOR=#FF0000>'#'</FONT> <FONT COLOR=black><B>and</B></FONT> \
            indentsize(lines[end]) == indent:
            comments = [string.lstrip(string.expandtabs(lines[end]))]
            <FONT COLOR=black><B>if</B></FONT> end &gt; 0:
                end = end - 1
                comment = string.lstrip(string.expandtabs(lines[end]))
                <FONT COLOR=black><B>while</B></FONT> comment[:1] == <FONT COLOR=#FF0000>'#'</FONT> <FONT COLOR=black><B>and</B></FONT> indentsize(lines[end]) == indent:
                    comments[:0] = [comment]
                    end = end - 1
                    <FONT COLOR=black><B>if</B></FONT> end &lt; 0: <FONT COLOR=black><B>break</B></FONT>
                    comment = string.lstrip(string.expandtabs(lines[end]))
            <FONT COLOR=black><B>while</B></FONT> comments <FONT COLOR=black><B>and</B></FONT> string.strip(comments[0]) == <FONT COLOR=#FF0000>'#'</FONT>:
                comments[:1] = []
            <FONT COLOR=black><B>while</B></FONT> comments <FONT COLOR=black><B>and</B></FONT> string.strip(comments[-1]) == <FONT COLOR=#FF0000>'#'</FONT>:
                comments[-1:] = []
            <FONT COLOR=black><B>return</B></FONT> string.join(comments, <FONT COLOR=#FF0000>''</FONT>)

<FONT COLOR=black><B>class</B></FONT> ListReader:
    <FONT COLOR=#FF0000>"""Provide a readline() method to return lines from a list of strings."""</FONT>
    <FONT COLOR=black><B>def</B></FONT> __init__(self, lines):
        self.lines = lines
        self.index = 0

    <FONT COLOR=black><B>def</B></FONT> readline(self):
        i = self.index
        <FONT COLOR=black><B>if</B></FONT> i &lt; len(self.lines):
            self.index = i + 1
            <FONT COLOR=black><B>return</B></FONT> self.lines[i]
        <FONT COLOR=black><B>else</B></FONT>: <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>''</FONT>

<FONT COLOR=black><B>class</B></FONT> EndOfBlock(Exception): <FONT COLOR=black><B>pass</B></FONT>

<FONT COLOR=black><B>class</B></FONT> BlockFinder:
    <FONT COLOR=#FF0000>"""Provide a tokeneater() method to detect the end of a code block."""</FONT>
    <FONT COLOR=black><B>def</B></FONT> __init__(self):
        self.indent = 0
        self.started = 0
        self.last = 0

    <FONT COLOR=black><B>def</B></FONT> tokeneater(self, type, token, (srow, scol), (erow, ecol), line):
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self.started:
            <FONT COLOR=black><B>if</B></FONT> type == tokenize.NAME: self.started = 1
        <FONT COLOR=black><B>elif</B></FONT> type == tokenize.NEWLINE:
            self.last = srow
        <FONT COLOR=black><B>elif</B></FONT> type == tokenize.INDENT:
            self.indent = self.indent + 1
        <FONT COLOR=black><B>elif</B></FONT> type == tokenize.DEDENT:
            self.indent = self.indent - 1
            <FONT COLOR=black><B>if</B></FONT> self.indent == 0: <FONT COLOR=black><B>raise</B></FONT> EndOfBlock, self.last

<FONT COLOR=black><B>def</B></FONT> getblock(lines):
    <FONT COLOR=#FF0000>"""Extract the block of code at the top of the given list of lines."""</FONT>
    <FONT COLOR=black><B>try</B></FONT>:
        tokenize.tokenize(ListReader(lines).readline, BlockFinder().tokeneater)
    <FONT COLOR=black><B>except</B></FONT> EndOfBlock, eob:
        <FONT COLOR=black><B>return</B></FONT> lines[:eob.args[0]]

<FONT COLOR=black><B>def</B></FONT> getsourcelines(object):
    <FONT COLOR=#FF0000>"""Return a list of source lines and starting line number for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a list of the lines
    corresponding to the object and the line number indicates where in the
    original source file the first line of code was found.  An IOError is
    raised if the source code cannot be retrieved."""</FONT>
    lines, lnum = findsource(object)

    <FONT COLOR=black><B>if</B></FONT> ismodule(object): <FONT COLOR=black><B>return</B></FONT> lines, 0
    <FONT COLOR=black><B>else</B></FONT>: <FONT COLOR=black><B>return</B></FONT> getblock(lines[lnum:]), lnum + 1

<FONT COLOR=black><B>def</B></FONT> getsource(object):
    <FONT COLOR=#FF0000>"""Return the text of the source code for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a single string.  An
    IOError is raised if the source code cannot be retrieved."""</FONT>
    lines, lnum = getsourcelines(object)
    <FONT COLOR=black><B>return</B></FONT> string.join(lines, <FONT COLOR=#FF0000>''</FONT>)

<FONT COLOR=#1111CC># --------------------------------------------------- class tree extraction</FONT>
<FONT COLOR=black><B>def</B></FONT> walktree(classes, children, parent):
    <FONT COLOR=#FF0000>"""Recursive helper function for getclasstree()."""</FONT>
    results = []
    classes.sort(<FONT COLOR=black><B>lambda</B></FONT> a, b: cmp(a.__name__, b.__name__))
    <FONT COLOR=black><B>for</B></FONT> c <FONT COLOR=black><B>in</B></FONT> classes:
        results.append((c, c.__bases__))
        <FONT COLOR=black><B>if</B></FONT> children.has_key(c):
            results.append(walktree(children[c], children, c))
    <FONT COLOR=black><B>return</B></FONT> results

<FONT COLOR=black><B>def</B></FONT> getclasstree(classes, unique=0):
    <FONT COLOR=#FF0000>"""Arrange the given list of classes into a hierarchy of nested lists.

    Where a nested list appears, it contains classes derived from the class
    whose entry immediately precedes the list.  Each entry is a 2-tuple
    containing a class and a tuple of its base classes.  If the 'unique'
    argument is true, exactly one entry appears in the returned structure
    for each class in the given list.  Otherwise, classes using multiple
    inheritance and their descendants will appear multiple times."""</FONT>
    children = {}
    roots = []
    <FONT COLOR=black><B>for</B></FONT> c <FONT COLOR=black><B>in</B></FONT> classes:
        <FONT COLOR=black><B>if</B></FONT> c.__bases__:
            <FONT COLOR=black><B>for</B></FONT> parent <FONT COLOR=black><B>in</B></FONT> c.__bases__:
                <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> children.has_key(parent):
                    children[parent] = []
                children[parent].append(c)
                <FONT COLOR=black><B>if</B></FONT> unique <FONT COLOR=black><B>and</B></FONT> parent <FONT COLOR=black><B>in</B></FONT> classes: <FONT COLOR=black><B>break</B></FONT>
        <FONT COLOR=black><B>elif</B></FONT> c <FONT COLOR=black><B>not</B></FONT> <FONT COLOR=black><B>in</B></FONT> roots:
            roots.append(c)
    <FONT COLOR=black><B>for</B></FONT> parent <FONT COLOR=black><B>in</B></FONT> children.keys():
        <FONT COLOR=black><B>if</B></FONT> parent <FONT COLOR=black><B>not</B></FONT> <FONT COLOR=black><B>in</B></FONT> classes:
            roots.append(parent)
    <FONT COLOR=black><B>return</B></FONT> walktree(roots, children, None)

<FONT COLOR=#1111CC># ------------------------------------------------ argument list extraction</FONT>
<FONT COLOR=#1111CC># These constants are from Python's compile.h.</FONT>
CO_OPTIMIZED, CO_NEWLOCALS, CO_VARARGS, CO_VARKEYWORDS = 1, 2, 4, 8

<FONT COLOR=black><B>def</B></FONT> getargs(co):
    <FONT COLOR=#FF0000>"""Get information about the arguments accepted by a code object.

    Three things are returned: (args, varargs, varkw), where 'args' is
    a list of argument names (possibly containing nested lists), and
    'varargs' and 'varkw' are the names of the * and ** arguments or None."""</FONT>
    <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> iscode(co): <FONT COLOR=black><B>raise</B></FONT> TypeError, <FONT COLOR=#FF0000>'arg is not a code object'</FONT>

    code = co.co_code
    nargs = co.co_argcount
    names = co.co_varnames
    args = list(names[:nargs])
    step = 0

    <FONT COLOR=#1111CC># The following acrobatics are for anonymous (tuple) arguments.</FONT>
    <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> range(nargs):
        <FONT COLOR=black><B>if</B></FONT> args[i][:1] <FONT COLOR=black><B>in</B></FONT> [<FONT COLOR=#FF0000>''</FONT>, <FONT COLOR=#FF0000>'.'</FONT>]:
            stack, remain, count = [], [], []
            <FONT COLOR=black><B>while</B></FONT> step &lt; len(code):
                op = ord(code[step])
                step = step + 1
                <FONT COLOR=black><B>if</B></FONT> op &gt;= dis.HAVE_ARGUMENT:
                    opname = dis.opname[op]
                    value = ord(code[step]) + ord(code[step+1])*256
                    step = step + 2
                    <FONT COLOR=black><B>if</B></FONT> opname <FONT COLOR=black><B>in</B></FONT> [<FONT COLOR=#FF0000>'UNPACK_TUPLE'</FONT>, <FONT COLOR=#FF0000>'UNPACK_SEQUENCE'</FONT>]:
                        remain.append(value)
                        count.append(value)
                    <FONT COLOR=black><B>elif</B></FONT> opname == <FONT COLOR=#FF0000>'STORE_FAST'</FONT>:
                        stack.append(names[value])
                        remain[-1] = remain[-1] - 1
                        <FONT COLOR=black><B>while</B></FONT> remain[-1] == 0:
                            remain.pop()
                            size = count.pop()
                            stack[-size:] = [stack[-size:]]
                            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> remain: <FONT COLOR=black><B>break</B></FONT>
                            remain[-1] = remain[-1] - 1
                        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> remain: <FONT COLOR=black><B>break</B></FONT>
            args[i] = stack[0]

    varargs = None
    <FONT COLOR=black><B>if</B></FONT> co.co_flags & CO_VARARGS:
        varargs = co.co_varnames[nargs]
        nargs = nargs + 1
    varkw = None
    <FONT COLOR=black><B>if</B></FONT> co.co_flags & CO_VARKEYWORDS:
        varkw = co.co_varnames[nargs]
    <FONT COLOR=black><B>return</B></FONT> args, varargs, varkw

<FONT COLOR=black><B>def</B></FONT> getargspec(func):
    <FONT COLOR=#FF0000>"""Get the names and default values of a function's arguments.

    A tuple of four things is returned: (args, varargs, varkw, defaults).
    'args' is a list of the argument names (it may contain nested lists).
    'varargs' and 'varkw' are the names of the * and ** arguments or None.
    'defaults' is an n-tuple of the default values of the last n arguments."""</FONT>
    <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> isfunction(func): <FONT COLOR=black><B>raise</B></FONT> TypeError, <FONT COLOR=#FF0000>'arg is not a Python function'</FONT>
    args, varargs, varkw = getargs(func.func_code)
    <FONT COLOR=black><B>return</B></FONT> args, varargs, varkw, func.func_defaults

<FONT COLOR=black><B>def</B></FONT> getargvalues(frame):
    <FONT COLOR=#FF0000>"""Get information about arguments passed into a particular frame.

    A tuple of four things is returned: (args, varargs, varkw, locals).
    'args' is a list of the argument names (it may contain nested lists).
    'varargs' and 'varkw' are the names of the * and ** arguments or None.
    'locals' is the locals dictionary of the given frame."""</FONT>
    args, varargs, varkw = getargs(frame.f_code)
    <FONT COLOR=black><B>return</B></FONT> args, varargs, varkw, frame.f_locals

<FONT COLOR=black><B>def</B></FONT> joinseq(seq):
    <FONT COLOR=black><B>if</B></FONT> len(seq) == 1:
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>'('</FONT> + seq[0] + <FONT COLOR=#FF0000>',)'</FONT>
    <FONT COLOR=black><B>else</B></FONT>:
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>'('</FONT> + string.join(seq, <FONT COLOR=#FF0000>', '</FONT>) + <FONT COLOR=#FF0000>')'</FONT>

<FONT COLOR=black><B>def</B></FONT> strseq(object, convert, join=joinseq):
    <FONT COLOR=#FF0000>"""Recursively walk a sequence, stringifying each element."""</FONT>
    <FONT COLOR=black><B>if</B></FONT> type(object) <FONT COLOR=black><B>in</B></FONT> [types.ListType, types.TupleType]:
        <FONT COLOR=black><B>return</B></FONT> join(map(<FONT COLOR=black><B>lambda</B></FONT> o, c=convert, j=join: strseq(o, c, j), object))
    <FONT COLOR=black><B>else</B></FONT>:
        <FONT COLOR=black><B>return</B></FONT> convert(object)

<FONT COLOR=black><B>def</B></FONT> formatargspec(args, varargs=None, varkw=None, defaults=None,
                  formatarg=str,
                  formatvarargs=<FONT COLOR=black><B>lambda</B></FONT> name: <FONT COLOR=#FF0000>'*'</FONT> + name,
                  formatvarkw=<FONT COLOR=black><B>lambda</B></FONT> name: <FONT COLOR=#FF0000>'**'</FONT> + name,
                  formatvalue=<FONT COLOR=black><B>lambda</B></FONT> value: <FONT COLOR=#FF0000>'='</FONT> + repr(value),
                  join=joinseq):
    <FONT COLOR=#FF0000>"""Format an argument spec from the 4 values returned by getargspec.

    The first four arguments are (args, varargs, varkw, defaults).  The
    other four arguments are the corresponding optional formatting functions
    that are called to turn names and values into strings.  The ninth
    argument is an optional function to format the sequence of arguments."""</FONT>
    specs = []
    <FONT COLOR=black><B>if</B></FONT> defaults:
        firstdefault = len(args) - len(defaults)
    <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> range(len(args)):
        spec = strseq(args[i], formatarg, join)
        <FONT COLOR=black><B>if</B></FONT> defaults <FONT COLOR=black><B>and</B></FONT> i &gt;= firstdefault:
            spec = spec + formatvalue(defaults[i - firstdefault])
        specs.append(spec)
    <FONT COLOR=black><B>if</B></FONT> varargs:
        specs.append(formatvarargs(varargs))
    <FONT COLOR=black><B>if</B></FONT> varkw:
        specs.append(formatvarkw(varkw))
    <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>'('</FONT> + string.join(specs, <FONT COLOR=#FF0000>', '</FONT>) + <FONT COLOR=#FF0000>')'</FONT>

<FONT COLOR=black><B>def</B></FONT> formatargvalues(args, varargs, varkw, locals,
                    formatarg=str,
                    formatvarargs=<FONT COLOR=black><B>lambda</B></FONT> name: <FONT COLOR=#FF0000>'*'</FONT> + name,
                    formatvarkw=<FONT COLOR=black><B>lambda</B></FONT> name: <FONT COLOR=#FF0000>'**'</FONT> + name,
                    formatvalue=<FONT COLOR=black><B>lambda</B></FONT> value: <FONT COLOR=#FF0000>'='</FONT> + repr(value),
                    join=joinseq):
    <FONT COLOR=#FF0000>"""Format an argument spec from the 4 values returned by getargvalues.

    The first four arguments are (args, varargs, varkw, locals).  The
    next four arguments are the corresponding optional formatting functions
    that are called to turn names and values into strings.  The ninth
    argument is an optional function to format the sequence of arguments."""</FONT>
    <FONT COLOR=black><B>def</B></FONT> convert(name, locals=locals,
                formatarg=formatarg, formatvalue=formatvalue):
        <FONT COLOR=black><B>return</B></FONT> formatarg(name) + formatvalue(locals[name])
    specs = []
    <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> range(len(args)):
        specs.append(strseq(args[i], convert, join))
    <FONT COLOR=black><B>if</B></FONT> varargs:
        specs.append(formatvarargs(varargs) + formatvalue(locals[varargs]))
    <FONT COLOR=black><B>if</B></FONT> varkw:
        specs.append(formatvarkw(varkw) + formatvalue(locals[varkw]))
    <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>'('</FONT> + string.join(specs, <FONT COLOR=#FF0000>', '</FONT>) + <FONT COLOR=#FF0000>')'</FONT>

<FONT COLOR=#1111CC># -------------------------------------------------- stack frame extraction</FONT>
<FONT COLOR=black><B>def</B></FONT> getframeinfo(frame, context=1):
    <FONT COLOR=#FF0000>"""Get information about a frame or traceback object.

    A tuple of five things is returned: the filename, the line number of
    the current line, the function name, a list of lines of context from
    the source code, and the index of the current line within that list.
    The optional second argument specifies the number of lines of context
    to return, which are centered around the current line."""</FONT>
    <FONT COLOR=black><B>if</B></FONT> istraceback(frame):
        frame = frame.tb_frame
    <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> isframe(frame):
        <FONT COLOR=black><B>raise</B></FONT> TypeError, <FONT COLOR=#FF0000>'arg is not a frame or traceback object'</FONT>

    <FONT COLOR=#1111CC># prefer to give filename the actual source file but if</FONT>
    <FONT COLOR=#1111CC># it does not exist, return the filename.</FONT>
    filename = getsourcefile(frame) <FONT COLOR=black><B>or</B></FONT> getfile(frame)
    lineno = getlineno(frame)
    <FONT COLOR=black><B>if</B></FONT> context &gt; 0:
        start = lineno - 1 - context/2
        <FONT COLOR=black><B>try</B></FONT>:
            lines, lnum = findsource(frame)
        <FONT COLOR=black><B>except</B></FONT> IOError:
            lines = index = None
        <FONT COLOR=black><B>else</B></FONT>:
            start = max(start, 1)
            start = min(start, len(lines) - context)
            lines = lines[start:start+context]
            index = lineno - 1 - start
    <FONT COLOR=black><B>else</B></FONT>:
        lines = index = None

    <FONT COLOR=black><B>return</B></FONT> (filename, lineno, frame.f_code.co_name, lines, index)

<FONT COLOR=black><B>def</B></FONT> getlineno(frame):
    <FONT COLOR=#FF0000>"""Get the line number from a frame object, allowing for optimization."""</FONT>
    <FONT COLOR=#1111CC># Written by Marc-André Lemburg; revised by Jim Hugunin and Fredrik Lundh.</FONT>
    lineno = frame.f_lineno
    code = frame.f_code
    <FONT COLOR=black><B>if</B></FONT> hasattr(code, <FONT COLOR=#FF0000>'co_lnotab'</FONT>):
        table = code.co_lnotab
        lineno = code.co_firstlineno
        addr = 0
        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> range(0, len(table), 2):
            addr = addr + ord(table[i])
            <FONT COLOR=black><B>if</B></FONT> addr &gt; frame.f_lasti: <FONT COLOR=black><B>break</B></FONT>
            lineno = lineno + ord(table[i+1])
    <FONT COLOR=black><B>return</B></FONT> lineno

<FONT COLOR=black><B>def</B></FONT> getouterframes(frame, context=1):
    <FONT COLOR=#FF0000>"""Get a list of records for a frame and all higher (calling) frames.

    Each record contains a frame object, filename, line number, function
    name, a list of lines of context, and index within the context."""</FONT>
    framelist = []
    <FONT COLOR=black><B>while</B></FONT> frame:
        framelist.append((frame,) + getframeinfo(frame, context))
        frame = frame.f_back
    <FONT COLOR=black><B>return</B></FONT> framelist

<FONT COLOR=black><B>def</B></FONT> getinnerframes(tb, context=1):
    <FONT COLOR=#FF0000>"""Get a list of records for a traceback's frame and all lower frames.

    Each record contains a frame object, filename, line number, function
    name, a list of lines of context, and index within the context."""</FONT>
    framelist = []
    <FONT COLOR=black><B>while</B></FONT> tb:
        framelist.append((tb.tb_frame,) + getframeinfo(tb, context))
        tb = tb.tb_next
    <FONT COLOR=black><B>return</B></FONT> framelist

<FONT COLOR=black><B>def</B></FONT> currentframe():
    <FONT COLOR=#FF0000>"""Return the frame object for the caller's stack frame."""</FONT>
    <FONT COLOR=black><B>try</B></FONT>:
        <FONT COLOR=black><B>raise</B></FONT> <FONT COLOR=#FF0000>'catch me'</FONT>
    <FONT COLOR=black><B>except</B></FONT>:
        <FONT COLOR=black><B>return</B></FONT> sys.exc_info()[2].tb_frame.f_back

<FONT COLOR=black><B>if</B></FONT> hasattr(sys, <FONT COLOR=#FF0000>'_getframe'</FONT>): currentframe = sys._getframe

<FONT COLOR=black><B>def</B></FONT> stack(context=1):
    <FONT COLOR=#FF0000>"""Return a list of records for the stack above the caller's frame."""</FONT>
    <FONT COLOR=black><B>return</B></FONT> getouterframes(currentframe().f_back, context)

<FONT COLOR=black><B>def</B></FONT> trace(context=1):
    <FONT COLOR=#FF0000>"""Return a list of records for the stack below the current exception."""</FONT>
    <FONT COLOR=black><B>return</B></FONT> getinnerframes(sys.exc_info()[2], context)
</PRE>
                  <!--footer-->
                  </BODY>
