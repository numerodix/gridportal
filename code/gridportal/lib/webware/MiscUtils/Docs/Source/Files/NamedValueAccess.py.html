<HTML><HEAD><TITLE>MiscUtils/NamedValueAccess.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=#FF0000>"""
NamedValueAccess provides functions, a mix-in class and a wrapper class
all for accessing Python objects by named attributes. You can use which
ever of the three approaches best suites your needs and style.


NOTES

If Python provided a root class 'Object' in the same tradition as other
OOP languages such as Smalltalk, Objective-C and Java, then we could
dispense with the global functions and simply stick with the mix-in.


TO DO

* The mix-in's valueForKey() could be out of slight alignment with the
  function, since they have different implementations. However, the test
  cases pass for both right now.

* Should the valueForKey() function provide for caching of bindings in
  the same manner than the mix-in does?

  If not, should the mix-in allow an option to *not* cache bindings?

* hasValueForKey() function? (We already have a method in the mix-in)

* valuesForNames() in the mix-in:
    * Change parameter 'keys' to 'names'
    * Use NoDefault instead of None in the parameters
    * Revisit doc string and test cases

* Docs: More improvs to doc strings.

* Testing: increase coverage

* Rename? class NamedValueAccess+ible:

* Benchmarking: Set this up in a new file:
    Testing/BenchNamedValueAccess.py
  so we can experment with caching vs. not and other techniques.


PAST DESIGN DECISIONS

* Only if a name binds to a method is it invoked. Another approach is
  to invoke any value that is __call__able, but that is unPythonic: If
  obj.foo is a class or a function then obj.foo gives that class or
  function, not the result of invoking it. Method is the only
  convenience we provide, because that's one of the major points of
  providing this.


CREDIT

Chuck Esterbrook &lt;echuck@mindspring.com&gt;
Tavis Rudd &lt;tavis@calrudd.com&gt;
"""</FONT>


<FONT COLOR=black><B>import</B></FONT> types
<FONT COLOR=black><B>import</B></FONT> string, sys
<FONT COLOR=black><B>from</B></FONT> time <FONT COLOR=black><B>import</B></FONT> time
<FONT COLOR=black><B>from</B></FONT> MiscUtils <FONT COLOR=black><B>import</B></FONT> NoDefault


<FONT COLOR=#1111CC># if technique is zero, use bound methods in the _kvGetBindings cache, otherwise use unbound</FONT>
<FONT COLOR=#1111CC># @@ 2000-05-31 ce: after additional testing we can probably scorge the technique=0 allowance</FONT>
technique = 1


<FONT COLOR=#1111CC>## Exceptions ##</FONT>

<FONT COLOR=black><B>class</B></FONT> NamedValueAccessError(LookupError): <FONT COLOR=black><B>pass</B></FONT>
<FONT COLOR=black><B>class</B></FONT> ValueForKeyError(NamedValueAccessError): <FONT COLOR=black><B>pass</B></FONT>


<FONT COLOR=black><B>class</B></FONT> NamedValueAccess:
    <FONT COLOR=#FF0000>"""
    This class is intended to be ancestor class such that you can say:
        from NamedValueAccess import *
        age = someObj.valueForName("age")
        name = someObj.valueForName("info.fields.name")

    This can be useful in setups where you wish to textually refer to the objects
    in a program, such as an HTML template processed in the context of an
    object-oriented framework.

    Keys can be matched to either methods or ivars and with or without underscores.

    valueForName() can also traverse bona fide dictionaries (DictType).

    You can safely import * from this module. Only the NamedValueAccess class is exported
    (other than typical things like string and sys).

    There is no __init__() method and never will be.

    You can run the test suite by running this module as a program.

    You'll see the terms 'key' and 'name' in the class and its documentation. A 'key'
    is a single identifier such as 'foo'. A name could be key, or a qualified key,
    such as 'foo.bar.boo'. Names are generally more convenient and powerful, while
    key-oriented methods are more efficient and provide the atomic functionality that
    name-oriented methods are built upon. From a usage point of view, you normally
    just use the 'name' methods and forget about the 'key'.

    @@ 2000-05-21 ce: This class causes problems when used in WebKit for logging.
        Perhaps circular references?
        Involving self?
        Having to do with methods bound to their objects?

    @@ 2000-03-03 ce: document ivars

    @@ 2000-04-24 ce: Some classes like UserDict need to use getitem()
    instead of getattr() and don't need to deal with _bindingForGetKey().

    @@ 2000-05-31 ce: Rename this class to NamedValues, NamedValueAccess, ValuesByName

    @@ This class probably needs to be in MiscUtils, as it's being used in that way
       while MiddleKit was intended for "enterprise/business objects".
    """</FONT>

    <FONT COLOR=#1111CC>#</FONT>
    <FONT COLOR=#1111CC># Accessing values by key</FONT>
    <FONT COLOR=#1111CC>#</FONT>
    <FONT COLOR=black><B>def</B></FONT> hasValueForKey(self, key):
        <FONT COLOR=#FF0000>""" Returns true if the key is available, although that does not
            guarantee that there will not be errors caused by retrieving the key. """</FONT>

        <FONT COLOR=black><B>return</B></FONT> self._bindingForGetKey(key)!=None


    <FONT COLOR=black><B>def</B></FONT> valueForKey(self, key, default=NoDefault):
        <FONT COLOR=#FF0000>""" Suppose key is 'foo'. This method returns the value with the following precedence:
                1. Methods before non-methods
                2. Public attributes before private attributes

            More specifically, this method then returns one of the following:
                * self.foo()
                * self._foo()
                * self.foo
                * self._foo

            ...or default, if it was specified,
            otherwise invokes and returns result of valueForUnknownKey().
            Note that valueForUnknownKey(), normally returns an exception.

            See valueForName() which is a more advanced version of this method that allows
            multiple, qualified keys.
        """</FONT>

        binding = self._bindingForGetKey(key)

        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> binding:
            <FONT COLOR=black><B>if</B></FONT> default <FONT COLOR=black><B>is</B></FONT> NoDefault:
                <FONT COLOR=black><B>return</B></FONT> self.valueForUnknownKey(key, default)
            <FONT COLOR=black><B>else</B></FONT>:
                <FONT COLOR=black><B>return</B></FONT> default

        <FONT COLOR=black><B>if</B></FONT> type(binding) <FONT COLOR=black><B>is</B></FONT> types.MethodType:
<FONT COLOR=#1111CC># @@ 2000-05-07 ce: come to a decision on exception handling for key errors</FONT>
<FONT COLOR=#1111CC>#           try:</FONT>
            <FONT COLOR=black><B>if</B></FONT> technique:
                result = binding(self)
            <FONT COLOR=black><B>else</B></FONT>:
                result = binding()
<FONT COLOR=#1111CC>#           except:</FONT>
                <FONT COLOR=#1111CC># @@ 2000-02-18: Improve next line with exception info</FONT>
<FONT COLOR=#1111CC>#               raise NamedValueAccessError, 'Caught exception while accessing key (%s). Exception is %s' % (key, sys.exc_info())</FONT>
            <FONT COLOR=black><B>return</B></FONT> result
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> getattr(self, binding)

    <FONT COLOR=black><B>def</B></FONT> hasValueForName(self, keysString):
        <FONT COLOR=black><B>try</B></FONT>:
            value = self.valueForName(keysString)
        <FONT COLOR=black><B>except</B></FONT> NamedValueAccessError:
            <FONT COLOR=black><B>return</B></FONT> 0
        <FONT COLOR=black><B>return</B></FONT> 1

    <FONT COLOR=black><B>def</B></FONT> valueForName(self, keysString, default=None):
        <FONT COLOR=#FF0000>""" Returns the value for the given keysString. This is the more advanced version of
            valueForKey(), which can only handle single names. This method can handle
            'foo', 'foo1.foo2', 'a.b.c.d', etc. It will traverse dictionaries if needed. """</FONT>
        keys = string.split(keysString, <FONT COLOR=#FF0000>'.'</FONT>)
        <FONT COLOR=black><B>return</B></FONT> self.valueForKeySequence(keys, default)

    <FONT COLOR=black><B>def</B></FONT> valueForKeySequence(self, listOfKeys, default=None):
        <FONT COLOR=#1111CC># @@ 2000-02-18: document</FONT>
        <FONT COLOR=black><B>return</B></FONT> _valueForKeySequence(self, listOfKeys, default)

    <FONT COLOR=black><B>def</B></FONT> valuesForNames(self, keys, default=None, defaults=None, forgive=0, includeNames=0):
        <FONT COLOR=#FF0000>""" Returns a list of values that match the given keys, each of which is passed
              through valueForName() and so could be of the form 'a.b.c'.
            keys is a sequence. default is any kind of object. defaults is a sequence.
              forgive and includeNames is a flag.
            If default is not None, then it is substituted when a key is not found.
            Otherwise, if defaults is not None, then it's corresponding/parallel value
              for the current key is substituted when a key is not found.
            Otherwise, if forgive=1, then unknown keys simply don't produce any values.
            Otherwise, if default and defaults are None, and forgive=0, then the unknown
              keys will probably raise an exception through self.valueForUnknownKey() although
              that method can always return a final, default value.
            if keys is None, then None is returned. If keys is an empty list, then None
              is returned.
            Often these last four arguments are specified by key.
            Examples:
                names = ['origin.x', 'origin.y', 'size.width', 'size.height']
                obj.valuesForNames(names)
                obj.valuesForNames(names, default=0.0)
                obj.valuesForNames(names, defaults=[0.0, 0.0, 100.0, 100.0])
                obj.valuesForNames(names, forgive=0)
            @@ 2000-03-04 ce: includeNames is only supported when forgive=1.
                It should be supported for the other cases.
                It should be documented.
                It should be included in the test cases.
        """</FONT>

        <FONT COLOR=black><B>if</B></FONT> keys <FONT COLOR=black><B>is</B></FONT> None:
            <FONT COLOR=black><B>return</B></FONT> None
        <FONT COLOR=black><B>if</B></FONT> len(keys) <FONT COLOR=black><B>is</B></FONT> 0:
            <FONT COLOR=black><B>return</B></FONT> []
        results = []

        <FONT COLOR=black><B>if</B></FONT> default <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None:
            results = map(<FONT COLOR=black><B>lambda</B></FONT> key, myself=self, mydefault=default: myself.valueForName(key, mydefault), keys)
        <FONT COLOR=black><B>elif</B></FONT> defaults <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None:
            <FONT COLOR=black><B>if</B></FONT> len(keys) <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> len(defaults):
                <FONT COLOR=black><B>raise</B></FONT> NamedValueAccessError, <FONT COLOR=#FF0000>'Keys and defaults have mismatching lengths (%d and %d).'</FONT> % (len(keys), len(defaults))
            results = map(<FONT COLOR=black><B>lambda</B></FONT> key, default, myself=self: myself.valueForName(key, default), keys, defaults)
        <FONT COLOR=black><B>elif</B></FONT> forgive:
            results = []
            uniqueObject = <FONT COLOR=#FF0000>'uni'</FONT> + <FONT COLOR=#FF0000>'que'</FONT>
            <FONT COLOR=black><B>for</B></FONT> key <FONT COLOR=black><B>in</B></FONT> keys:
                value = self.valueForName(key, uniqueObject)
                <FONT COLOR=black><B>if</B></FONT> value <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> uniqueObject:
                    <FONT COLOR=black><B>if</B></FONT> includeNames:
                        results.append((key, value))
                    <FONT COLOR=black><B>else</B></FONT>:
                        results.append(value)
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=#1111CC># no defaults, no forgiveness</FONT>
            results = map(<FONT COLOR=black><B>lambda</B></FONT> key, myself=self: myself.valueForName(key), keys)
        <FONT COLOR=black><B>return</B></FONT> results

    <FONT COLOR=black><B>def</B></FONT> setValueForKey(self, key, value):
        <FONT COLOR=#1111CC># @@ 2000-02-18: naming might be weired here with args reversed</FONT>
        <FONT COLOR=#FF0000>""" Suppose key is 'foo'. This method sets the value with the following precedence:
                1. Public attributes before private attributes
                2. Methods before non-methods

            More specifically, this method then uses one of the following:
                @@ 2000-03-04 ce: fill in

            ...or invokes handleUnknownSetKey().
        """</FONT>
        <FONT COLOR=black><B>raise</B></FONT> NotImplementedError <FONT COLOR=#1111CC># @@ 2000-03-04 ce</FONT>

    <FONT COLOR=black><B>def</B></FONT> resetKeyBindings(self):
        <FONT COLOR=#1111CC># @@ 2000-02-18 document this method</FONT>
        <FONT COLOR=black><B>if</B></FONT> hasattr(self, <FONT COLOR=#FF0000>'_kvGetBindings'</FONT>):
            self._kvGetBindings = {}


    <FONT COLOR=#1111CC>#</FONT>
    <FONT COLOR=#1111CC># Errors</FONT>
    <FONT COLOR=#1111CC>#</FONT>
    <FONT COLOR=black><B>def</B></FONT> valueForUnknownKey(self, key, default):
        <FONT COLOR=black><B>raise</B></FONT> NamedValueAccessError, key

    <FONT COLOR=#1111CC>#def </FONT>handleUnknownSetKey(self, key):
    <FONT COLOR=#1111CC>#   raise NamedValueAccessError, key</FONT>


    <FONT COLOR=#1111CC>#</FONT>
    <FONT COLOR=#1111CC># Private</FONT>
    <FONT COLOR=#1111CC>#</FONT>
    <FONT COLOR=black><B>def</B></FONT> _bindingForGetKey(self, key):
        <FONT COLOR=#FF0000>""" Bindings are cached.
            Bindings are methods or strings.
        """</FONT>

        <FONT COLOR=#1111CC># Make _kvGetBindings dictionary if we don't have one</FONT>
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> hasattr(self, <FONT COLOR=#FF0000>'_kvGetBindings'</FONT>):
            self._kvGetBindings = {}

        <FONT COLOR=#1111CC># Return the binding if we already have one</FONT>
        <FONT COLOR=black><B>if</B></FONT> self._kvGetBindings.has_key(key):
            <FONT COLOR=black><B>return</B></FONT> self._kvGetBindings[key]

        <FONT COLOR=#1111CC># No binding, so we have to look for the key</FONT>

        found = None  <FONT COLOR=#1111CC># set to what we find</FONT>

        <FONT COLOR=#1111CC># Try plain old key</FONT>
        <FONT COLOR=black><B>if</B></FONT> hasattr(self, key):
            found = getattr(self, key)
            <FONT COLOR=#1111CC>#print </FONT><FONT COLOR=#FF0000>'0: found = '</FONT>, found, type(found)
            <FONT COLOR=black><B>if</B></FONT> type(found) <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> types.MethodType:
                found = key
            <FONT COLOR=black><B>elif</B></FONT> technique:
                found = getattr(self.__class__, key)
            self._kvGetBindings[key] = found
        <FONT COLOR=#1111CC>#print </FONT><FONT COLOR=#FF0000>'1: found = '</FONT>, found, type(found)

        <FONT COLOR=#1111CC># Try _key only if we didn't find a method called key</FONT>
        <FONT COLOR=black><B>if</B></FONT> type(found) <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> types.MethodType:
            underKey = <FONT COLOR=#FF0000>'_'</FONT> + key
            <FONT COLOR=black><B>if</B></FONT> hasattr(self, underKey):
                underAttr = getattr(self, underKey)
                <FONT COLOR=black><B>if</B></FONT> found==None:
                    <FONT COLOR=black><B>if</B></FONT> type(underAttr) <FONT COLOR=black><B>is</B></FONT> types.MethodType:
                        <FONT COLOR=black><B>if</B></FONT> technique:
                            value = getattr(self.__class__, underKey)
                        <FONT COLOR=black><B>else</B></FONT>:
                            value = underAttr
                    <FONT COLOR=black><B>else</B></FONT>:
                        value = underKey
                    found = self._kvGetBindings[key] = value
                <FONT COLOR=black><B>else</B></FONT>:
                    <FONT COLOR=black><B>if</B></FONT> type(underAttr) <FONT COLOR=black><B>is</B></FONT> types.MethodType:
                        <FONT COLOR=black><B>if</B></FONT> technique:
                            underAttr = getattr(self.__class__, underKey)
                        found = self._kvGetBindings[key] = underAttr

        <FONT COLOR=#1111CC>#print </FONT><FONT COLOR=#FF0000>'2: found = '</FONT>, found, type(found)

        <FONT COLOR=black><B>return</B></FONT> found


<FONT COLOR=black><B>class</B></FONT> NamedValueAccessWrapper(NamedValueAccess):
    <FONT COLOR=#FF0000>"""
    This provides a wrapper around an existing object which will respond
    to the methods of NamedValueAccess. By using the wrapper, you can
    stick with objects and methods such as obj.valueForName('x.y') (as
    opposed to functions like valueForName()) and refrain from modifying
    the existing class hierarchy with NamedValueAccess.

    Example:
        wrapper = NamedValueAccessWrapper(obj)
        print wrapper.valueForName('manager.name')
    """</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, object):
        self._object = object

    <FONT COLOR=black><B>def</B></FONT> hasValueForKey(self, key):
        <FONT COLOR=black><B>try</B></FONT>:
            value = self.valueForKey(ley)
        <FONT COLOR=black><B>except</B></FONT> NamedValueAccessError:
            <FONT COLOR=black><B>return</B></FONT> 0
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> 1

    <FONT COLOR=black><B>def</B></FONT> valueForKey(self, key, default=NoDefault):
        <FONT COLOR=black><B>return</B></FONT> valueForKey(self._object)

    <FONT COLOR=black><B>def</B></FONT> valueForName(self, key, default=NoDefault):
        <FONT COLOR=black><B>return</B></FONT> valueForName(self._object)



<FONT COLOR=#1111CC>#</FONT>
<FONT COLOR=#1111CC># Private</FONT>
<FONT COLOR=#1111CC>#</FONT>

<FONT COLOR=black><B>def</B></FONT> _valueForKeySequence(obj, listOfKeys, default=None):
    <FONT COLOR=#FF0000>""" This is a recursive function used to implement NamedValueAccess.valueForKeySequence.
        Besides supporting inheritors of NamedValueAccess, this function also supports
        dictionaries, which is why it's not found in the class.
    """</FONT>

    <FONT COLOR=#1111CC># @@ 2000-02-18: Optimize by specifying index instead of making new list</FONT>
    <FONT COLOR=black><B>if</B></FONT> type(obj) <FONT COLOR=black><B>is</B></FONT> types.DictType:
        <FONT COLOR=black><B>try</B></FONT>:
            value = obj[listOfKeys[0]]
        <FONT COLOR=black><B>except</B></FONT>: <FONT COLOR=#1111CC># @@ 2000-03-03 ce: this exception should be more specific. probably nameerror or indexerror</FONT>
            <FONT COLOR=black><B>if</B></FONT> default <FONT COLOR=black><B>is</B></FONT> None:
                <FONT COLOR=black><B>raise</B></FONT> NamedValueAccessError, <FONT COLOR=#FF0000>'Unknown key (%s) in dictionary.'</FONT> % listOfKeys[0]
            <FONT COLOR=black><B>else</B></FONT>:
                <FONT COLOR=black><B>return</B></FONT> default
    <FONT COLOR=black><B>else</B></FONT>:
        value = obj.valueForKey(listOfKeys[0], default)
    <FONT COLOR=black><B>if</B></FONT> len(listOfKeys)&gt;1:
        <FONT COLOR=black><B>return</B></FONT> _valueForKeySequence(value, listOfKeys[1:], default)
    <FONT COLOR=black><B>else</B></FONT>:
        <FONT COLOR=black><B>return</B></FONT> value


<FONT COLOR=black><B>def</B></FONT> _dict_valueForKey(obj, key, default=NoDefault):
    <FONT COLOR=#FF0000>"""
    Returns the value for a given key of the dictionary-like object.
    This is a private, custom function built in support of valueForKey().
    """</FONT>
    <FONT COLOR=black><B>try</B></FONT>:
        value = obj[key]
    <FONT COLOR=black><B>except</B></FONT> AttributeError, e:
        <FONT COLOR=#1111CC># We attempt to pass only on exceptions caused</FONT>
        <FONT COLOR=#1111CC># by obj not responding to __getitem__. Any</FONT>
        <FONT COLOR=#1111CC># other exceptions generated get raised up.</FONT>
        substring = <FONT COLOR=#FF0000>"instance has no attribute '__getitem__'"</FONT>
        <FONT COLOR=black><B>if</B></FONT> e.args[0][-len(substring):]==substring:
            <FONT COLOR=black><B>if</B></FONT> default <FONT COLOR=black><B>is</B></FONT> NoDefault:
                <FONT COLOR=black><B>return</B></FONT> None
            <FONT COLOR=black><B>else</B></FONT>:
                <FONT COLOR=black><B>return</B></FONT>
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>raise</B></FONT>
    <FONT COLOR=black><B>except</B></FONT> KeyError, e:
        <FONT COLOR=black><B>if</B></FONT> e.args[0]==key:
            <FONT COLOR=black><B>if</B></FONT> default <FONT COLOR=black><B>is</B></FONT> NoDefault:
                <FONT COLOR=black><B>raise</B></FONT> ValueForKeyError, key
            <FONT COLOR=black><B>else</B></FONT>:
                <FONT COLOR=black><B>return</B></FONT> default
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=#1111CC># If we get here, then the KeyError is deeper in the</FONT>
            <FONT COLOR=#1111CC># implementation of obj[key]</FONT>
            <FONT COLOR=black><B>raise</B></FONT>
    <FONT COLOR=black><B>else</B></FONT>:
        <FONT COLOR=black><B>return</B></FONT> value


<FONT COLOR=black><B>def</B></FONT> valueForKey(obj, key, default=NoDefault):
    <FONT COLOR=#FF0000>"""
    Returns the value of the object named by the given key.

    Suppose key is 'foo'. This method returns the value with the
    following precedence:
        1. Methods before non-methods
        2. Attributes before keys (__getitem__)
        3. Public things before private things
           (private being denoted by a preceding underscore)

    More specifically, this method returns one of the following:
        * obj.valueForKey(key)  # only if the method exists
        * obj.foo()
        * obj._foo()
        * obj.foo
        * obj._foo
        * obj['foo']
        * obj.valueForUnknownKey(key)
        * default  # only if specified

    If all of these fail, a ValueForKeyError is raised.


    NOTES

    * If the object provides a valueForKey() method, that method will be
      invoked to do the work.

    * valueForKey() works on dictionaries and dictionary-like objects.

    * valueForUnknownKey() provides a hook by which objects can
      delegate or chain their keyed value access to other objects.
      The key and default arguments are passed to it and it should
      generally respect the typical treatment of the the default
      argument as found throughout Webware and described in the Style
      Guidelines.

    * See valueForName() which is a more advanced version of this
      function that allows multiple, qualified keys.
    """</FONT>

    <FONT COLOR=#1111CC># We only accept strings for keys</FONT>
    <FONT COLOR=black><B>assert</B></FONT> type(key) <FONT COLOR=black><B>is</B></FONT> types.StringType

    <FONT COLOR=#1111CC># Use obj.valueForKey() if it is available</FONT>
    valueForKeyMeth = getattr(obj, <FONT COLOR=#FF0000>'valueForKey'</FONT>, None)
    <FONT COLOR=black><B>if</B></FONT> valueForKeyMeth:
        <FONT COLOR=black><B>return</B></FONT> valueForKeyMeth(key, default)

    attr   = None
    method = None
    value  = None
    unknown = 0
    <FONT COLOR=black><B>if</B></FONT> type(obj) <FONT COLOR=black><B>is</B></FONT> types.DictType:
        <FONT COLOR=black><B>if</B></FONT> default <FONT COLOR=black><B>is</B></FONT> NoDefault:
            <FONT COLOR=black><B>try</B></FONT>:
                <FONT COLOR=black><B>return</B></FONT> obj[key]
            <FONT COLOR=black><B>except</B></FONT> KeyError:
                <FONT COLOR=black><B>raise</B></FONT> ValueForKeyError, key
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> obj.get(key, default)
    <FONT COLOR=black><B>else</B></FONT>:
        <FONT COLOR=black><B>try</B></FONT>:
            klass    = obj.__class__
        <FONT COLOR=black><B>except</B></FONT> AttributeError:
            <FONT COLOR=black><B>raise</B></FONT> AttributeError, <FONT COLOR=#FF0000>'__class__ obj type=%r, obj=%r'</FONT> % (type(obj), obj)
        method   = getattr(klass, key, None)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> method:
            underKey = <FONT COLOR=#FF0000>'_'</FONT> + key
            method = getattr(klass, underKey, None)
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> method:
                attr = getattr(obj, key, NoDefault)
                <FONT COLOR=black><B>if</B></FONT> attr <FONT COLOR=black><B>is</B></FONT> NoDefault:
                    attr = getattr(obj, underKey, NoDefault)
                    <FONT COLOR=black><B>if</B></FONT> attr <FONT COLOR=black><B>is</B></FONT> NoDefault:
                        getitem = getattr(obj.__class__, <FONT COLOR=#FF0000>'__getitem__'</FONT>, None)
                        <FONT COLOR=black><B>if</B></FONT> getitem:
                            <FONT COLOR=black><B>try</B></FONT>:
                                value = getitem(obj, key)
                            <FONT COLOR=black><B>except</B></FONT> KeyError:
                                unknown = 1

<FONT COLOR=#1111CC>#   if value is not NoDefault:</FONT>
<FONT COLOR=#1111CC>#       return value</FONT>
    <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> unknown:
        <FONT COLOR=black><B>if</B></FONT> method:
            <FONT COLOR=black><B>return</B></FONT> method(obj)
        <FONT COLOR=black><B>if</B></FONT> attr <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> NoDefault:
            <FONT COLOR=black><B>return</B></FONT> attr

    <FONT COLOR=#1111CC># Use obj.valueForUnknownKey() if it is available</FONT>
    valueForUnknownKey = getattr(obj, <FONT COLOR=#FF0000>'valueForUnknownKey'</FONT>, None)
    <FONT COLOR=black><B>if</B></FONT> valueForUnknownKey:
        <FONT COLOR=black><B>return</B></FONT> valueForUnknownKey(key, default)

    <FONT COLOR=black><B>if</B></FONT> default!=NoDefault:
        <FONT COLOR=black><B>return</B></FONT> default
    <FONT COLOR=black><B>else</B></FONT>:
        <FONT COLOR=black><B>raise</B></FONT> ValueForKeyError, key


<FONT COLOR=black><B>def</B></FONT> valueForName(obj, name, default=NoDefault):
    <FONT COLOR=#FF0000>"""
    Returns the value of the object that is named. The name can use
    dotted notation to traverse through a network/graph of objects.
    Since this function relies on valueForKey() for each individual
    component of the name, you should be familiar with the semantics
    of that notation.

    Example: valueForName(obj, 'department.manager.salary')
    """</FONT>

    names = string.split(name, <FONT COLOR=#FF0000>'.'</FONT>)
    <FONT COLOR=black><B>for</B></FONT> name <FONT COLOR=black><B>in</B></FONT> names:
        obj = valueForKey(obj, name, default)
        <FONT COLOR=black><B>if</B></FONT> obj <FONT COLOR=black><B>is</B></FONT> default:
            <FONT COLOR=black><B>return</B></FONT> obj
        <FONT COLOR=#1111CC># 2001-04-19 ce: I suppose the above technique could result in</FONT>
        <FONT COLOR=#1111CC># the default being returned prematurely if it was part of the</FONT>
        <FONT COLOR=#1111CC># chain of names. Well, that's just the way it goes for now.</FONT>
    <FONT COLOR=black><B>return</B></FONT> obj


<FONT COLOR=#1111CC># Beef up UserDict with the NamedValueAccess base class and custom versions of</FONT>
<FONT COLOR=#1111CC># hasValueForKey() and valueForKey(). This all means that UserDict's (such as</FONT>
<FONT COLOR=#1111CC># os.environ) are key/value accessible.</FONT>
<FONT COLOR=#1111CC># @@ 2000-05-07 ce: CGIWrapper.py duplicates this.</FONT>
<FONT COLOR=black><B>def</B></FONT> _enhanceUserDict():
    <FONT COLOR=black><B>from</B></FONT> UserDict <FONT COLOR=black><B>import</B></FONT> UserDict
    <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> NamedValueAccess <FONT COLOR=black><B>in</B></FONT> UserDict.__bases__:
        UserDict.__bases__ = UserDict.__bases__ + (NamedValueAccess,)

        <FONT COLOR=black><B>def</B></FONT> _UserDict_hasValueForKey(self, key):
            <FONT COLOR=black><B>return</B></FONT> self.has_key(key)

        <FONT COLOR=black><B>def</B></FONT> _UserDict_valueForKey(self, key, default=NoDefault):
            <FONT COLOR=black><B>if</B></FONT> default <FONT COLOR=black><B>is</B></FONT> NoDefault:
                <FONT COLOR=black><B>if</B></FONT> self.has_key(key):
                    <FONT COLOR=black><B>return</B></FONT> self[key]
                <FONT COLOR=black><B>else</B></FONT>:
                    <FONT COLOR=black><B>raise</B></FONT> ValueForKeyError, key
            <FONT COLOR=black><B>else</B></FONT>:
                <FONT COLOR=black><B>return</B></FONT> self.get(key, default)

        setattr(UserDict, <FONT COLOR=#FF0000>'hasValueForKey'</FONT>, _UserDict_hasValueForKey)
        setattr(UserDict, <FONT COLOR=#FF0000>'valueForKey'</FONT>, _UserDict_valueForKey)

_enhanceUserDict()
</PRE>
                  <!--footer-->
                  </BODY>
