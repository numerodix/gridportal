<HTML><HEAD><TITLE>MiscUtils/DictForArgs.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=#FF0000>"""
DictForArgs.py


See the doc string for the DictForArgs() function.

Also, there is a test suite in Testing/TestDictForArgs.py
"""</FONT>


<FONT COLOR=black><B>import</B></FONT> re, string


<FONT COLOR=black><B>class</B></FONT> DictForArgsError(Exception):
    <FONT COLOR=black><B>pass</B></FONT>

<FONT COLOR=black><B>def</B></FONT> _SyntaxError(s):
    <FONT COLOR=black><B>raise</B></FONT> DictForArgsError, <FONT COLOR=#FF0000>'Syntax error: %s'</FONT> % repr(s)

<FONT COLOR=black><B>def</B></FONT> DictForArgs(s):
    <FONT COLOR=#FF0000>"""
    Takes an input such as:
            x=3
            name="foo"
            first='john' last='doe'
            required border=3

    And returns a dictionary representing the same. For keys that aren't
    given an explicit value (such as 'required' above), the value is '1'.

    All values are interpreted as strings. If you want ints and floats,
    you'll have to convert them yourself.

    This syntax is equivalent to what you find in HTML and close to other
    ML languages such as XML.

    Returns {} for an empty string.

    The informal grammar is:
        (NAME [=NAME|STRING])*

    Will raise DictForArgsError if the string is invalid.

    See also: PyDictForArgs() and ExpandDictWithExtras() in this module
    """</FONT>

    s = string.strip(s)

    <FONT COLOR=#1111CC># Tokenize</FONT>

    <FONT COLOR=#1111CC># @@ 2001-09-29 ce: push these outside for better performance</FONT>
    nameRE   = re.compile(r<FONT COLOR=#FF0000>'\w+'</FONT>)
    equalsRE = re.compile(r<FONT COLOR=#FF0000>'\='</FONT>)
    stringRE = re.compile(r<FONT COLOR=#FF0000>'''
                    "[^"]+"|
                    '[^']+'|
                    \S+'''</FONT>, re.VERBOSE)    <FONT COLOR=#1111CC>#'</FONT>
    whiteRE  = re.compile(r<FONT COLOR=#FF0000>'\s+'</FONT>)
    REs = [nameRE, equalsRE, stringRE, whiteRE]

    verbose = 0
    matches = []
    start   = 0
    sLen    = len(s)

    <FONT COLOR=black><B>if</B></FONT> verbose:
        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; DictForArgs(%s)'</FONT> % repr(s)
        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; sLen:'</FONT>, sLen
    <FONT COLOR=black><B>while</B></FONT> start&lt;sLen:
        <FONT COLOR=black><B>for</B></FONT> regEx <FONT COLOR=black><B>in</B></FONT> REs:
            <FONT COLOR=black><B>if</B></FONT> verbose: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; try:'</FONT>, regEx
            match = regEx.match(s, start)
            <FONT COLOR=black><B>if</B></FONT> verbose: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; match:'</FONT>, match
            <FONT COLOR=black><B>if</B></FONT> match <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None:
                <FONT COLOR=black><B>if</B></FONT> match.re <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> whiteRE:
                    matches.append(match)
                start = match.end()
                <FONT COLOR=black><B>if</B></FONT> verbose: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; new start:'</FONT>, start
                <FONT COLOR=black><B>break</B></FONT>
        <FONT COLOR=black><B>else</B></FONT>:
            _SyntaxError(s)

    <FONT COLOR=black><B>if</B></FONT> verbose:
        names = []
        <FONT COLOR=black><B>for</B></FONT> match <FONT COLOR=black><B>in</B></FONT> matches:
            <FONT COLOR=black><B>if</B></FONT> match.re <FONT COLOR=black><B>is</B></FONT> nameRE:
                name = <FONT COLOR=#FF0000>'name'</FONT>
            <FONT COLOR=black><B>elif</B></FONT> match.re <FONT COLOR=black><B>is</B></FONT> equalsRE:
                name = <FONT COLOR=#FF0000>'equals'</FONT>
            <FONT COLOR=black><B>elif</B></FONT> match.re <FONT COLOR=black><B>is</B></FONT> stringRE:
                name = <FONT COLOR=#FF0000>'string'</FONT>
            <FONT COLOR=black><B>elif</B></FONT> match.re <FONT COLOR=black><B>is</B></FONT> whiteRE:
                name = <FONT COLOR=#FF0000>'white'</FONT>
            names.append(name)
            <FONT COLOR=#1111CC>#print </FONT><FONT COLOR=#FF0000>'&gt;&gt; match ='</FONT>, name, match
        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; names ='</FONT>, names


    <FONT COLOR=#1111CC># Process tokens</FONT>

    <FONT COLOR=#1111CC># At this point we have a list of all the tokens (as re.Match objects)</FONT>
    <FONT COLOR=#1111CC># We need to process these into a dictionary.</FONT>

    dict = {}
    matchesLen = len(matches)
    i = 0
    <FONT COLOR=black><B>while</B></FONT> i&lt;matchesLen:
        match = matches[i]
        <FONT COLOR=black><B>if</B></FONT> i+1&lt;matchesLen:
            peekMatch = matches[i+1]
        <FONT COLOR=black><B>else</B></FONT>:
            peekMatch = None
        <FONT COLOR=black><B>if</B></FONT> match.re <FONT COLOR=black><B>is</B></FONT> nameRE:
            <FONT COLOR=black><B>if</B></FONT> peekMatch <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None:
                <FONT COLOR=black><B>if</B></FONT> peekMatch.re <FONT COLOR=black><B>is</B></FONT> nameRE:
                    <FONT COLOR=#1111CC># We have a name without an explicit value</FONT>
                    dict[match.group()] = <FONT COLOR=#FF0000>'1'</FONT>
                    i = i + 1
                    <FONT COLOR=black><B>continue</B></FONT>
                <FONT COLOR=black><B>if</B></FONT> peekMatch.re <FONT COLOR=black><B>is</B></FONT> equalsRE:
                    <FONT COLOR=black><B>if</B></FONT> i+2&lt;matchesLen:
                        target = matches[i+2]
                        <FONT COLOR=black><B>if</B></FONT> target.re <FONT COLOR=black><B>is</B></FONT> nameRE  <FONT COLOR=black><B>or</B></FONT>  target.re <FONT COLOR=black><B>is</B></FONT> stringRE:
                            value = target.group()
                            <FONT COLOR=black><B>if</B></FONT> value[0]==<FONT COLOR=#FF0000>"'"</FONT> <FONT COLOR=black><B>or</B></FONT> value[0]==<FONT COLOR=#FF0000>'"'</FONT>:
                                value = value[1:-1]
                                <FONT COLOR=#1111CC>#value = "'''%s'''" % value[1:-1]</FONT>
                                <FONT COLOR=#1111CC>#value = eval(value)</FONT>
                            dict[match.group()] = value
                            i = i + 3
                            <FONT COLOR=black><B>continue</B></FONT>
            <FONT COLOR=black><B>else</B></FONT>:
                dict[match.group()] = <FONT COLOR=#FF0000>'1'</FONT>
                i = i + 1
                <FONT COLOR=black><B>continue</B></FONT>
        _SyntaxError(s)


    <FONT COLOR=black><B>if</B></FONT> verbose: <FONT COLOR=black><B>print</B></FONT>

    <FONT COLOR=black><B>return</B></FONT> dict


<FONT COLOR=black><B>from</B></FONT> string <FONT COLOR=black><B>import</B></FONT> letters

<FONT COLOR=black><B>def</B></FONT> PyDictForArgs(s):
    <FONT COLOR=#FF0000>"""
    Takes an input such as:
            x=3
            name="foo"
            first='john'; last='doe'
            list=[1, 2, 3]; name='foo'

    And returns a dictionary representing the same.

    All values are interpreted as Python expressions. Any error in these
    expressions will raise the appropriate Python exception. This syntax
    allows much more power than DictForArgs() since you can include
    lists, dictionaries, actual ints and floats, etc.

    This could also open the door to hacking your software if the input
    comes from a tainted source such as an HTML form or an unprotected
    configuration file.

    Returns {} for an empty string.

    See also: DictForArgs() and ExpandDictWithExtras() in this module
    """</FONT>
    s = s.strip()
    <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> s:
        <FONT COLOR=black><B>return</B></FONT> {}

    <FONT COLOR=#1111CC># special case: just a name</FONT>
    <FONT COLOR=#1111CC># meaning: name=1</FONT>
    <FONT COLOR=#1111CC># example: isAbstract</FONT>
    <FONT COLOR=black><B>if</B></FONT> s.find(<FONT COLOR=#FF0000>' '</FONT>)==-1 <FONT COLOR=black><B>and</B></FONT> s.find(<FONT COLOR=#FF0000>'='</FONT>)==-1 <FONT COLOR=black><B>and</B></FONT> s[0] <FONT COLOR=black><B>in</B></FONT> letters:
        s += <FONT COLOR=#FF0000>'=1'</FONT>

    results = {}
    <FONT COLOR=black><B>exec</B></FONT> s <FONT COLOR=black><B>in</B></FONT> results

    <FONT COLOR=black><B>del</B></FONT> results[<FONT COLOR=#FF0000>'__builtins__'</FONT>]
    <FONT COLOR=black><B>return</B></FONT> results


<FONT COLOR=black><B>def</B></FONT> ExpandDictWithExtras(dict, key=<FONT COLOR=#FF0000>'Extras'</FONT>, delKey=1, dictForArgs=DictForArgs):
    <FONT COLOR=#FF0000>"""
    Returns a dictionary with the 'Extras' column expanded by DictForArgs(). For example, given:
        { 'Name': 'foo', 'Extras': 'x=1 y=2' }
    The return value is:
        { 'Name': 'foo', 'x': '1', 'y': '2' }
    The key argument controls what key in the dictionary is used to hold the extra arguments. The delKey argument controls whether that key and its corresponding value are retained.
    The same dictionary may be returned if there is no extras key.
    The most typical use of this function is to pass a row from a DataTable that was initialized from a CSV file (e.g., a spreadsheet or tabular file). FormKit and MiddleKit both use CSV files and allow for an Extras column to specify attributes that occur infrequently.
    """</FONT>

    <FONT COLOR=black><B>if</B></FONT> dict.has_key(key):
        newDict = {}
        <FONT COLOR=#1111CC># We use the following for loop rather than newDict.update()</FONT>
        <FONT COLOR=#1111CC># so that the dict arg can be dictionary-like.</FONT>
        <FONT COLOR=black><B>for</B></FONT> k, v <FONT COLOR=black><B>in</B></FONT> dict.items():
            newDict[k] = v
        <FONT COLOR=black><B>if</B></FONT> delKey:
            <FONT COLOR=black><B>del</B></FONT> newDict[key]
        newDict.update(dictForArgs(dict[key]))
        <FONT COLOR=black><B>return</B></FONT> newDict
    <FONT COLOR=black><B>else</B></FONT>:
        <FONT COLOR=black><B>return</B></FONT> dict
</PRE>
                  <!--footer-->
                  </BODY>
