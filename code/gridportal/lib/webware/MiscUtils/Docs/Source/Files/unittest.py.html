<HTML><HEAD><TITLE>MiscUtils/unittest.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=#1111CC>#!/usr/bin/env python</FONT>
<FONT COLOR=#FF0000>"""
Python unit testing framework, based on Erich Gamma's JUnit and Kent Beck's
Smalltalk testing framework.

Further information is available in the bundled documentation, and from

  http://pyunit.sourceforge.net/

This module contains the core framework classes that form the basis of
specific test cases and suites (TestCase, TestSuite etc.), and also a
text-based utility class for running the tests and reporting the results
(TextTestRunner).

Copyright (c) 1999, 2000, 2001 Steve Purcell
This module is free software, and you may redistribute it and/or modify
it under the same terms as Python itself, so long as this copyright message
and disclaimer are retained in their original form.

IN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF
THIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

THE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS,
AND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,
SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
"""</FONT>

__author__ = <FONT COLOR=#FF0000>"Steve Purcell (stephen_purcell@yahoo.com)"</FONT>
__version__ = <FONT COLOR=#FF0000>"$Revision: 1.1 $"</FONT>[11:-2]

<FONT COLOR=black><B>import</B></FONT> time
<FONT COLOR=black><B>import</B></FONT> sys
<FONT COLOR=black><B>import</B></FONT> traceback
<FONT COLOR=black><B>import</B></FONT> string
<FONT COLOR=black><B>import</B></FONT> os

<FONT COLOR=#1111CC>##############################################################################</FONT>
<FONT COLOR=#1111CC># A platform-specific concession to help the code work for JPython users</FONT>
<FONT COLOR=#1111CC>##############################################################################</FONT>

plat = string.lower(sys.platform)
_isJPython = string.find(plat, <FONT COLOR=#FF0000>'java'</FONT>) &gt;= 0 <FONT COLOR=black><B>or</B></FONT> string.find(plat, <FONT COLOR=#FF0000>'jdk'</FONT>) &gt;= 0
<FONT COLOR=black><B>del</B></FONT> plat


<FONT COLOR=#1111CC>##############################################################################</FONT>
<FONT COLOR=#1111CC># Test framework core</FONT>
<FONT COLOR=#1111CC>##############################################################################</FONT>

<FONT COLOR=black><B>class</B></FONT> TestResult:
    <FONT COLOR=#FF0000>"""Holder for test result information.

    Test results are automatically managed by the TestCase and TestSuite
    classes, and do not need to be explicitly manipulated by writers of tests.

    Each instance holds the total number of tests run, and collections of
    failures and errors that occurred among those test runs. The collections
    contain tuples of (testcase, exceptioninfo), where exceptioninfo is a
    tuple of values as returned by sys.exc_info().
    """</FONT>
    <FONT COLOR=black><B>def</B></FONT> __init__(self):
        self.failures = []
        self.errors = []
        self.testsRun = 0
        self.shouldStop = 0

    <FONT COLOR=black><B>def</B></FONT> startTest(self, test):
        <FONT COLOR=#FF0000>"Called when the given test is about to be run"</FONT>
        self.testsRun = self.testsRun + 1

    <FONT COLOR=black><B>def</B></FONT> stopTest(self, test):
        <FONT COLOR=#FF0000>"Called when the given test has been run"</FONT>
        <FONT COLOR=black><B>pass</B></FONT>

    <FONT COLOR=black><B>def</B></FONT> addError(self, test, err):
        <FONT COLOR=#FF0000>"Called when an error has occurred"</FONT>
        self.errors.append((test, err))

    <FONT COLOR=black><B>def</B></FONT> addFailure(self, test, err):
        <FONT COLOR=#FF0000>"Called when a failure has occurred"</FONT>
        self.failures.append((test, err))

    <FONT COLOR=black><B>def</B></FONT> wasSuccessful(self):
        <FONT COLOR=#FF0000>"Tells whether or not this result was a success"</FONT>
        <FONT COLOR=black><B>return</B></FONT> len(self.failures) == len(self.errors) == 0

    <FONT COLOR=black><B>def</B></FONT> stop(self):
        <FONT COLOR=#FF0000>"Indicates that the tests should be aborted"</FONT>
        self.shouldStop = 1
    
    <FONT COLOR=black><B>def</B></FONT> __repr__(self):
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>"&lt;%s run=%i errors=%i failures=%i&gt;"</FONT> % \
               (self.__class__, self.testsRun, len(self.errors),
                len(self.failures))


<FONT COLOR=black><B>class</B></FONT> TestCase:
    <FONT COLOR=#FF0000>"""A class whose instances are single test cases.

    Test authors should subclass TestCase for their own tests. Construction 
    and deconstruction of the test's environment ('fixture') can be
    implemented by overriding the 'setUp' and 'tearDown' methods respectively.

    By default, the test code itself should be placed in a method named
    'runTest'.
    
    If the fixture may be used for many test cases, create as 
    many test methods as are needed. When instantiating such a TestCase
    subclass, specify in the constructor arguments the name of the test method
    that the instance is to execute.

    If it is necessary to override the __init__ method, the base class
    __init__ method must always be called.
    """</FONT>
    <FONT COLOR=black><B>def</B></FONT> __init__(self, methodName=<FONT COLOR=#FF0000>'runTest'</FONT>):
        <FONT COLOR=#FF0000>"""Create an instance of the class that will use the named test
           method when executed. Raises a ValueError if the instance does
           not have a method with the specified name.
        """</FONT>
        <FONT COLOR=black><B>try</B></FONT>:
            self.__testMethod = getattr(self,methodName)
        <FONT COLOR=black><B>except</B></FONT> AttributeError:
            <FONT COLOR=black><B>raise</B></FONT> ValueError, <FONT COLOR=#FF0000>"no such test method in %s: %s"</FONT> % \
                  (self.__class__, methodName)

    <FONT COLOR=black><B>def</B></FONT> setUp(self):
        <FONT COLOR=#FF0000>"Hook method for setting up the test fixture before exercising it."</FONT>
        <FONT COLOR=black><B>pass</B></FONT>

    <FONT COLOR=black><B>def</B></FONT> tearDown(self):
        <FONT COLOR=#FF0000>"Hook method for deconstructing the test fixture after testing it."</FONT>
        <FONT COLOR=black><B>pass</B></FONT>

    <FONT COLOR=black><B>def</B></FONT> countTestCases(self):
        <FONT COLOR=black><B>return</B></FONT> 1

    <FONT COLOR=black><B>def</B></FONT> defaultTestResult(self):
        <FONT COLOR=black><B>return</B></FONT> TestResult()

    <FONT COLOR=black><B>def</B></FONT> shortDescription(self):
        <FONT COLOR=#FF0000>"""Returns a one-line description of the test, or None if no
        description has been provided.

        The default implementation of this method returns the first line of
        the specified test method's docstring.
        """</FONT>
        doc = self.__testMethod.__doc__
        <FONT COLOR=black><B>return</B></FONT> doc <FONT COLOR=black><B>and</B></FONT> string.strip(string.split(doc, <FONT COLOR=#FF0000>"\n"</FONT>)[0]) <FONT COLOR=black><B>or</B></FONT> None

    <FONT COLOR=black><B>def</B></FONT> id(self):
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>"%s.%s"</FONT> % (self.__class__, self.__testMethod.__name__)

    <FONT COLOR=black><B>def</B></FONT> __str__(self):
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>"%s (%s)"</FONT> % (self.__testMethod.__name__, self.__class__)

    <FONT COLOR=black><B>def</B></FONT> __repr__(self):
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>"&lt;%s testMethod=%s&gt;"</FONT> % \
               (self.__class__, self.__testMethod.__name__)

    <FONT COLOR=black><B>def</B></FONT> run(self, result=None):
        <FONT COLOR=black><B>return</B></FONT> self(result)

    <FONT COLOR=black><B>def</B></FONT> __call__(self, result=None):
        <FONT COLOR=black><B>if</B></FONT> result <FONT COLOR=black><B>is</B></FONT> None: result = self.defaultTestResult()
        result.startTest(self)
        <FONT COLOR=black><B>try</B></FONT>:
            <FONT COLOR=black><B>try</B></FONT>:
                self.setUp()
            <FONT COLOR=black><B>except</B></FONT>:
                result.addError(self,self.__exc_info())
                <FONT COLOR=black><B>return</B></FONT>

            <FONT COLOR=black><B>try</B></FONT>:
                self.__testMethod()
            <FONT COLOR=black><B>except</B></FONT> AssertionError, e:
                result.addFailure(self,self.__exc_info())
            <FONT COLOR=black><B>except</B></FONT>:
                result.addError(self,self.__exc_info())

            <FONT COLOR=black><B>try</B></FONT>:
                self.tearDown()
            <FONT COLOR=black><B>except</B></FONT>:
                result.addError(self,self.__exc_info())
        <FONT COLOR=black><B>finally</B></FONT>:
            result.stopTest(self)

    <FONT COLOR=black><B>def</B></FONT> debug(self):
        <FONT COLOR=#FF0000>"""Run the test without collecting errors in a TestResult"""</FONT>
        self.setUp()
        self.__testMethod()
        self.tearDown()

    <FONT COLOR=black><B>def</B></FONT> assert_(self, expr, msg=None):
        <FONT COLOR=#FF0000>"""Equivalent of built-in 'assert', but is not optimised out when
           __debug__ is false.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> expr:
            <FONT COLOR=black><B>raise</B></FONT> AssertionError, msg

    failUnless = assert_

    <FONT COLOR=black><B>def</B></FONT> failIf(self, expr, msg=None):
        <FONT COLOR=#FF0000>"Fail the test if the expression is true."</FONT>
        apply(self.assert_,(<FONT COLOR=black><B>not</B></FONT> expr,msg))

    <FONT COLOR=black><B>def</B></FONT> assertRaises(self, excClass, callableObj, *args, **kwargs):
        <FONT COLOR=#FF0000>"""Assert that an exception of class excClass is thrown
           by callableObj when invoked with arguments args and keyword
           arguments kwargs. If a different type of exception is
           thrown, it will not be caught, and the test case will be
           deemed to have suffered an error, exactly as for an
           unexpected exception.
        """</FONT>
        <FONT COLOR=black><B>try</B></FONT>:
            apply(callableObj, args, kwargs)
        <FONT COLOR=black><B>except</B></FONT> excClass:
            <FONT COLOR=black><B>return</B></FONT>
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>if</B></FONT> hasattr(excClass,<FONT COLOR=#FF0000>'__name__'</FONT>): excName = excClass.__name__
            <FONT COLOR=black><B>else</B></FONT>: excName = str(excClass)
            <FONT COLOR=black><B>raise</B></FONT> AssertionError, excName

    <FONT COLOR=black><B>def</B></FONT> fail(self, msg=None):
        <FONT COLOR=#FF0000>"""Fail immediately, with the given message."""</FONT>
        <FONT COLOR=black><B>raise</B></FONT> AssertionError, msg
                                   
    <FONT COLOR=black><B>def</B></FONT> __exc_info(self):
        <FONT COLOR=#FF0000>"""Return a version of sys.exc_info() with the traceback frame
           minimised; usually the top level of the traceback frame is not
           needed.
        """</FONT>
        exctype, excvalue, tb = sys.exc_info()
        newtb = tb.tb_next
        <FONT COLOR=black><B>if</B></FONT> newtb <FONT COLOR=black><B>is</B></FONT> None:
            <FONT COLOR=black><B>return</B></FONT> (exctype, excvalue, tb)
        <FONT COLOR=black><B>return</B></FONT> (exctype, excvalue, newtb)


<FONT COLOR=black><B>class</B></FONT> TestSuite:
    <FONT COLOR=#FF0000>"""A test suite is a composite test consisting of a number of TestCases.

    For use, create an instance of TestSuite, then add test case instances.
    When all tests have been added, the suite can be passed to a test
    runner, such as TextTestRunner. It will run the individual test cases
    in the order in which they were added, aggregating the results. When
    subclassing, do not forget to call the base class constructor.
    """</FONT>
    <FONT COLOR=black><B>def</B></FONT> __init__(self, tests=()):
        self._tests = []
        self.addTests(tests)

    <FONT COLOR=black><B>def</B></FONT> __repr__(self):
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>"&lt;%s tests=%s&gt;"</FONT> % (self.__class__, self._tests)

    __str__ = __repr__

    <FONT COLOR=black><B>def</B></FONT> countTestCases(self):
        cases = 0
        <FONT COLOR=black><B>for</B></FONT> test <FONT COLOR=black><B>in</B></FONT> self._tests:
            cases = cases + test.countTestCases()
        <FONT COLOR=black><B>return</B></FONT> cases

    <FONT COLOR=black><B>def</B></FONT> addTest(self, test):
        self._tests.append(test)

    <FONT COLOR=black><B>def</B></FONT> addTests(self, tests):
        <FONT COLOR=black><B>for</B></FONT> test <FONT COLOR=black><B>in</B></FONT> tests:
            self.addTest(test)

    <FONT COLOR=black><B>def</B></FONT> run(self, result):
        <FONT COLOR=black><B>return</B></FONT> self(result)

    <FONT COLOR=black><B>def</B></FONT> __call__(self, result):
        <FONT COLOR=black><B>for</B></FONT> test <FONT COLOR=black><B>in</B></FONT> self._tests:
            <FONT COLOR=black><B>if</B></FONT> result.shouldStop:
                <FONT COLOR=black><B>break</B></FONT>
            test(result)
        <FONT COLOR=black><B>return</B></FONT> result

    <FONT COLOR=black><B>def</B></FONT> debug(self):
        <FONT COLOR=#FF0000>"""Run the tests without collecting errors in a TestResult"""</FONT>
        <FONT COLOR=black><B>for</B></FONT> test <FONT COLOR=black><B>in</B></FONT> self._tests: test.debug()


<FONT COLOR=black><B>class</B></FONT> FunctionTestCase(TestCase):
    <FONT COLOR=#FF0000>"""A test case that wraps a test function.

    This is useful for slipping pre-existing test functions into the
    PyUnit framework. Optionally, set-up and tidy-up functions can be
    supplied. As with TestCase, the tidy-up ('tearDown') function will
    always be called if the set-up ('setUp') function ran successfully.
    """</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, testFunc, setUp=None, tearDown=None,
                 description=None):
        TestCase.__init__(self)
        self.__setUpFunc = setUp
        self.__tearDownFunc = tearDown
        self.__testFunc = testFunc
        self.__description = description

    <FONT COLOR=black><B>def</B></FONT> setUp(self):
        <FONT COLOR=black><B>if</B></FONT> self.__setUpFunc <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None:
            self.__setUpFunc()

    <FONT COLOR=black><B>def</B></FONT> tearDown(self):
        <FONT COLOR=black><B>if</B></FONT> self.__tearDownFunc <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None:
            self.__tearDownFunc()

    <FONT COLOR=black><B>def</B></FONT> runTest(self):
        self.__testFunc()

    <FONT COLOR=black><B>def</B></FONT> id(self):
        <FONT COLOR=black><B>return</B></FONT> self.__testFunc.__name__

    <FONT COLOR=black><B>def</B></FONT> __str__(self):
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>"%s (%s)"</FONT> % (self.__class__, self.__testFunc.__name__)

    <FONT COLOR=black><B>def</B></FONT> __repr__(self):
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>"&lt;%s testFunc=%s&gt;"</FONT> % (self.__class__, self.__testFunc)

    <FONT COLOR=black><B>def</B></FONT> shortDescription(self):
        <FONT COLOR=black><B>if</B></FONT> self.__description <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None: <FONT COLOR=black><B>return</B></FONT> self.__description
        doc = self.__testFunc.__doc__
        <FONT COLOR=black><B>return</B></FONT> doc <FONT COLOR=black><B>and</B></FONT> string.strip(string.split(doc, <FONT COLOR=#FF0000>"\n"</FONT>)[0]) <FONT COLOR=black><B>or</B></FONT> None



<FONT COLOR=#1111CC>##############################################################################</FONT>
<FONT COLOR=#1111CC># Convenience functions</FONT>
<FONT COLOR=#1111CC>##############################################################################</FONT>

<FONT COLOR=black><B>def</B></FONT> getTestCaseNames(testCaseClass, prefix, sortUsing=cmp):
    <FONT COLOR=#FF0000>"""Extracts all the names of functions in the given test case class
       and its base classes that start with the given prefix. This is used
       by makeSuite().
    """</FONT>
    testFnNames = filter(<FONT COLOR=black><B>lambda</B></FONT> n,p=prefix: n[:len(p)] == p,
                         dir(testCaseClass))
    <FONT COLOR=black><B>for</B></FONT> baseclass <FONT COLOR=black><B>in</B></FONT> testCaseClass.__bases__:
        testFnNames = testFnNames + \
                      getTestCaseNames(baseclass, prefix, sortUsing=None)
    <FONT COLOR=black><B>if</B></FONT> sortUsing:
        testFnNames.sort(sortUsing)
    <FONT COLOR=black><B>return</B></FONT> testFnNames


<FONT COLOR=black><B>def</B></FONT> makeSuite(testCaseClass, prefix=<FONT COLOR=#FF0000>'test'</FONT>, sortUsing=cmp):
    <FONT COLOR=#FF0000>"""Returns a TestSuite instance built from all of the test functions
       in the given test case class whose names begin with the given
       prefix. The cases are sorted by their function names
       using the supplied comparison function, which defaults to 'cmp'.
    """</FONT>
    cases = map(testCaseClass,
                getTestCaseNames(testCaseClass, prefix, sortUsing))
    <FONT COLOR=black><B>return</B></FONT> TestSuite(cases)


<FONT COLOR=black><B>def</B></FONT> createTestInstance(name, module=None):
    <FONT COLOR=#FF0000>"""Finds tests by their name, optionally only within the given module.

    Return the newly-constructed test, ready to run. If the name contains a ':'
    then the portion of the name after the colon is used to find a specific
    test case within the test case class named before the colon.

    Examples:
     findTest('examples.listtests.suite')
        -- returns result of calling 'suite'
     findTest('examples.listtests.ListTestCase:checkAppend')
        -- returns result of calling ListTestCase('checkAppend')
     findTest('examples.listtests.ListTestCase:check-')
        -- returns result of calling makeSuite(ListTestCase, prefix="check")
    """</FONT>
          
    spec = string.split(name, <FONT COLOR=#FF0000>':'</FONT>)
    <FONT COLOR=black><B>if</B></FONT> len(spec) &gt; 2: <FONT COLOR=black><B>raise</B></FONT> ValueError, <FONT COLOR=#FF0000>"illegal test name: %s"</FONT> % name
    <FONT COLOR=black><B>if</B></FONT> len(spec) == 1:
        testName = spec[0]
        caseName = None
    <FONT COLOR=black><B>else</B></FONT>:
        testName, caseName = spec
    parts = string.split(testName, <FONT COLOR=#FF0000>'.'</FONT>)
    <FONT COLOR=black><B>if</B></FONT> module <FONT COLOR=black><B>is</B></FONT> None:
        <FONT COLOR=black><B>if</B></FONT> len(parts) &lt; 2:
            <FONT COLOR=black><B>raise</B></FONT> ValueError, <FONT COLOR=#FF0000>"incomplete test name: %s"</FONT> % name
        constructor = __import__(string.join(parts[:-1],<FONT COLOR=#FF0000>'.'</FONT>))
        parts = parts[1:]
    <FONT COLOR=black><B>else</B></FONT>:
        constructor = module
    <FONT COLOR=black><B>for</B></FONT> part <FONT COLOR=black><B>in</B></FONT> parts:
        constructor = getattr(constructor, part)
    <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> callable(constructor):
        <FONT COLOR=black><B>raise</B></FONT> ValueError, <FONT COLOR=#FF0000>"%s is not a callable object"</FONT> % constructor
    <FONT COLOR=black><B>if</B></FONT> caseName:
        <FONT COLOR=black><B>if</B></FONT> caseName[-1] == <FONT COLOR=#FF0000>'-'</FONT>:
            prefix = caseName[:-1]
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> prefix:
                <FONT COLOR=black><B>raise</B></FONT> ValueError, <FONT COLOR=#FF0000>"prefix too short: %s"</FONT> % name
            test = makeSuite(constructor, prefix=prefix)
        <FONT COLOR=black><B>else</B></FONT>:
            test = constructor(caseName)
    <FONT COLOR=black><B>else</B></FONT>:
        test = constructor()
    <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> hasattr(test,<FONT COLOR=#FF0000>"countTestCases"</FONT>):
        <FONT COLOR=black><B>raise</B></FONT> TypeError, \
              <FONT COLOR=#FF0000>"object %s found with spec %s is not a test"</FONT> % (test, name)
    <FONT COLOR=black><B>return</B></FONT> test


<FONT COLOR=#1111CC>##############################################################################</FONT>
<FONT COLOR=#1111CC># Text UI</FONT>
<FONT COLOR=#1111CC>##############################################################################</FONT>

<FONT COLOR=black><B>class</B></FONT> _WritelnDecorator:
    <FONT COLOR=#FF0000>"""Used to decorate file-like objects with a handy 'writeln' method"""</FONT>
    <FONT COLOR=black><B>def</B></FONT> __init__(self,stream):
        self.stream = stream
        <FONT COLOR=black><B>if</B></FONT> _isJPython:
            <FONT COLOR=black><B>import</B></FONT> java.lang.System
            self.linesep = java.lang.System.getProperty(<FONT COLOR=#FF0000>"line.separator"</FONT>)
        <FONT COLOR=black><B>else</B></FONT>:
            self.linesep = os.linesep

    <FONT COLOR=black><B>def</B></FONT> __getattr__(self, attr):
        <FONT COLOR=black><B>return</B></FONT> getattr(self.stream,attr)

    <FONT COLOR=black><B>def</B></FONT> writeln(self, *args):
        <FONT COLOR=black><B>if</B></FONT> args: apply(self.write, args)
        self.write(self.linesep)

 
<FONT COLOR=black><B>class</B></FONT> _JUnitTextTestResult(TestResult):
    <FONT COLOR=#FF0000>"""A test result class that can print formatted text results to a stream.

    Used by JUnitTextTestRunner.
    """</FONT>
    <FONT COLOR=black><B>def</B></FONT> __init__(self, stream):
        self.stream = stream
        TestResult.__init__(self)

    <FONT COLOR=black><B>def</B></FONT> addError(self, test, error):
        TestResult.addError(self,test,error)
        self.stream.write(<FONT COLOR=#FF0000>'E'</FONT>)
        self.stream.flush()
        <FONT COLOR=black><B>if</B></FONT> error[0] <FONT COLOR=black><B>is</B></FONT> KeyboardInterrupt:
            self.shouldStop = 1
 
    <FONT COLOR=black><B>def</B></FONT> addFailure(self, test, error):
        TestResult.addFailure(self,test,error)
        self.stream.write(<FONT COLOR=#FF0000>'F'</FONT>)
        self.stream.flush()
 
    <FONT COLOR=black><B>def</B></FONT> startTest(self, test):
        TestResult.startTest(self,test)
        self.stream.write(<FONT COLOR=#FF0000>'.'</FONT>)
        self.stream.flush()

    <FONT COLOR=black><B>def</B></FONT> printNumberedErrors(self,errFlavour,errors):
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> errors: <FONT COLOR=black><B>return</B></FONT>
        <FONT COLOR=black><B>if</B></FONT> len(errors) == 1:
            self.stream.writeln(<FONT COLOR=#FF0000>"There was 1 %s:"</FONT> % errFlavour)
        <FONT COLOR=black><B>else</B></FONT>:
            self.stream.writeln(<FONT COLOR=#FF0000>"There were %i %ss:"</FONT> %
                                (len(errors), errFlavour))
        i = 1
        <FONT COLOR=black><B>for</B></FONT> test,error <FONT COLOR=black><B>in</B></FONT> errors:
            errString = string.join(apply(traceback.format_exception,error),<FONT COLOR=#FF0000>""</FONT>)
            self.stream.writeln(<FONT COLOR=#FF0000>"%i) %s"</FONT> % (i, test))
            self.stream.writeln(errString)
            i = i + 1
 
    <FONT COLOR=black><B>def</B></FONT> printErrors(self):
        self.printNumberedErrors(<FONT COLOR=#FF0000>"error"</FONT>,self.errors)

    <FONT COLOR=black><B>def</B></FONT> printFailures(self):
        self.printNumberedErrors(<FONT COLOR=#FF0000>"failure"</FONT>,self.failures)

    <FONT COLOR=black><B>def</B></FONT> printHeader(self):
        self.stream.writeln()
        <FONT COLOR=black><B>if</B></FONT> self.wasSuccessful():
            self.stream.writeln(<FONT COLOR=#FF0000>"OK (%i tests)"</FONT> % self.testsRun)
        <FONT COLOR=black><B>else</B></FONT>:
            self.stream.writeln(<FONT COLOR=#FF0000>"!!!FAILURES!!!"</FONT>)
            self.stream.writeln(<FONT COLOR=#FF0000>"Test Results"</FONT>)
            self.stream.writeln()
            self.stream.writeln(<FONT COLOR=#FF0000>"Run: %i ; Failures: %i ; Errors: %i"</FONT> %
                                (self.testsRun, len(self.failures),
                                 len(self.errors)))
            
    <FONT COLOR=black><B>def</B></FONT> printResult(self):
        self.printHeader()
        self.printErrors()
        self.printFailures()


<FONT COLOR=black><B>class</B></FONT> JUnitTextTestRunner:
    <FONT COLOR=#FF0000>"""A test runner class that displays results in textual form.
    
    The display format approximates that of JUnit's 'textui' test runner.
    This test runner may be removed in a future version of PyUnit.
    """</FONT>
    <FONT COLOR=black><B>def</B></FONT> __init__(self, stream=sys.stderr):
        self.stream = _WritelnDecorator(stream)

    <FONT COLOR=black><B>def</B></FONT> run(self, test):
        <FONT COLOR=#FF0000>"Run the given test case or test suite."</FONT>
        result = _JUnitTextTestResult(self.stream)
        startTime = time.time()
        test(result)
        stopTime = time.time()
        self.stream.writeln()
        self.stream.writeln(<FONT COLOR=#FF0000>"Time: %.3fs"</FONT> % float(stopTime - startTime))
        result.printResult()
        <FONT COLOR=black><B>return</B></FONT> result


<FONT COLOR=#1111CC>##############################################################################</FONT>
<FONT COLOR=#1111CC># Verbose text UI</FONT>
<FONT COLOR=#1111CC>##############################################################################</FONT>

<FONT COLOR=black><B>class</B></FONT> _VerboseTextTestResult(TestResult):
    <FONT COLOR=#FF0000>"""A test result class that can print formatted text results to a stream.

    Used by VerboseTextTestRunner.
    """</FONT>
    <FONT COLOR=black><B>def</B></FONT> __init__(self, stream, descriptions):
        TestResult.__init__(self)
        self.stream = stream
        self.lastFailure = None
        self.descriptions = descriptions
        
    <FONT COLOR=black><B>def</B></FONT> startTest(self, test):
        TestResult.startTest(self, test)
        <FONT COLOR=black><B>if</B></FONT> self.descriptions:
            self.stream.write(test.shortDescription() <FONT COLOR=black><B>or</B></FONT> str(test))
        <FONT COLOR=black><B>else</B></FONT>:
            self.stream.write(str(test))
        self.stream.write(<FONT COLOR=#FF0000>" ... "</FONT>)

    <FONT COLOR=black><B>def</B></FONT> stopTest(self, test):
        TestResult.stopTest(self, test)
        <FONT COLOR=black><B>if</B></FONT> self.lastFailure <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> test:
            self.stream.writeln(<FONT COLOR=#FF0000>"ok"</FONT>)

    <FONT COLOR=black><B>def</B></FONT> addError(self, test, err):
        TestResult.addError(self, test, err)
        self._printError(<FONT COLOR=#FF0000>"ERROR"</FONT>, test, err)
        self.lastFailure = test
        <FONT COLOR=black><B>if</B></FONT> err[0] <FONT COLOR=black><B>is</B></FONT> KeyboardInterrupt:
            self.shouldStop = 1

    <FONT COLOR=black><B>def</B></FONT> addFailure(self, test, err):
        TestResult.addFailure(self, test, err)
        self._printError(<FONT COLOR=#FF0000>"FAIL"</FONT>, test, err)
        self.lastFailure = test

    <FONT COLOR=black><B>def</B></FONT> _printError(self, flavour, test, err):
        errLines = []
        separator1 = <FONT COLOR=#FF0000>"\t"</FONT> + <FONT COLOR=#FF0000>'='</FONT> * 70
        separator2 = <FONT COLOR=#FF0000>"\t"</FONT> + <FONT COLOR=#FF0000>'-'</FONT> * 70
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self.lastFailure <FONT COLOR=black><B>is</B></FONT> test:
            self.stream.writeln()
            self.stream.writeln(separator1)
        self.stream.writeln(<FONT COLOR=#FF0000>"\t%s"</FONT> % flavour)
        self.stream.writeln(separator2)
        <FONT COLOR=black><B>for</B></FONT> line <FONT COLOR=black><B>in</B></FONT> apply(traceback.format_exception, err):
            <FONT COLOR=black><B>for</B></FONT> l <FONT COLOR=black><B>in</B></FONT> string.split(line,<FONT COLOR=#FF0000>"\n"</FONT>)[:-1]:
                self.stream.writeln(<FONT COLOR=#FF0000>"\t%s"</FONT> % l)
        self.stream.writeln(separator1)


<FONT COLOR=black><B>class</B></FONT> VerboseTextTestRunner:
    <FONT COLOR=#FF0000>"""A test runner class that displays results in textual form.
    
    It prints out the names of tests as they are run, errors as they
    occur, and a summary of the results at the end of the test run.
    """</FONT>
    <FONT COLOR=black><B>def</B></FONT> __init__(self, stream=sys.stderr, descriptions=1):
        self.stream = _WritelnDecorator(stream)
        self.descriptions = descriptions

    <FONT COLOR=black><B>def</B></FONT> run(self, test):
        <FONT COLOR=#FF0000>"Run the given test case or test suite."</FONT>
        result = _VerboseTextTestResult(self.stream, self.descriptions)
        startTime = time.time()
        test(result)
        stopTime = time.time()
        timeTaken = float(stopTime - startTime)
        self.stream.writeln(<FONT COLOR=#FF0000>"-"</FONT> * 78)
        run = result.testsRun
        self.stream.writeln(<FONT COLOR=#FF0000>"Ran %d test%s in %.3fs"</FONT> %
                            (run, run &gt; 1 <FONT COLOR=black><B>and</B></FONT> <FONT COLOR=#FF0000>"s"</FONT> <FONT COLOR=black><B>or</B></FONT> <FONT COLOR=#FF0000>""</FONT>, timeTaken))
        self.stream.writeln()
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> result.wasSuccessful():
            self.stream.write(<FONT COLOR=#FF0000>"FAILED ("</FONT>)
            failed, errored = map(len, (result.failures, result.errors))
            <FONT COLOR=black><B>if</B></FONT> failed:
                self.stream.write(<FONT COLOR=#FF0000>"failures=%d"</FONT> % failed)
            <FONT COLOR=black><B>if</B></FONT> errored:
                <FONT COLOR=black><B>if</B></FONT> failed: self.stream.write(<FONT COLOR=#FF0000>", "</FONT>)
                self.stream.write(<FONT COLOR=#FF0000>"errors=%d"</FONT> % errored)
            self.stream.writeln(<FONT COLOR=#FF0000>")"</FONT>)
        <FONT COLOR=black><B>else</B></FONT>:
            self.stream.writeln(<FONT COLOR=#FF0000>"OK"</FONT>)
        <FONT COLOR=black><B>return</B></FONT> result
        

<FONT COLOR=#1111CC># Which flavour of TextTestRunner is the default?</FONT>
TextTestRunner = VerboseTextTestRunner


<FONT COLOR=#1111CC>##############################################################################</FONT>
<FONT COLOR=#1111CC># Facilities for running tests from the command line</FONT>
<FONT COLOR=#1111CC>##############################################################################</FONT>

<FONT COLOR=black><B>class</B></FONT> TestProgram:
    <FONT COLOR=#FF0000>"""A command-line program that runs a set of tests; this is primarily
       for making test modules conveniently executable.
    """</FONT>
    USAGE = <FONT COLOR=#FF0000>"""\
Usage: %(progName)s [-h|--help] [test[:(casename|prefix-)]] [...]

Examples:
  %(progName)s                               - run default set of tests
  %(progName)s MyTestSuite                   - run suite 'MyTestSuite'
  %(progName)s MyTestCase:checkSomething     - run MyTestCase.checkSomething
  %(progName)s MyTestCase:check-             - run all 'check*' test methods
                                               in MyTestCase
"""</FONT>
    <FONT COLOR=black><B>def</B></FONT> __init__(self, module=<FONT COLOR=#FF0000>'__main__'</FONT>, defaultTest=None,
                 argv=None, testRunner=None):
        <FONT COLOR=black><B>if</B></FONT> type(module) == type(<FONT COLOR=#FF0000>''</FONT>):
            self.module = __import__(module)
            <FONT COLOR=black><B>for</B></FONT> part <FONT COLOR=black><B>in</B></FONT> string.split(module,<FONT COLOR=#FF0000>'.'</FONT>)[1:]:
                self.module = getattr(self.module, part)
        <FONT COLOR=black><B>else</B></FONT>:
            self.module = module
        <FONT COLOR=black><B>if</B></FONT> argv <FONT COLOR=black><B>is</B></FONT> None:
            argv = sys.argv
        self.defaultTest = defaultTest
        self.testRunner = testRunner
        self.progName = os.path.basename(argv[0])
        self.parseArgs(argv)
        self.createTests()
        self.runTests()

    <FONT COLOR=black><B>def</B></FONT> usageExit(self, msg=None):
        <FONT COLOR=black><B>if</B></FONT> msg: <FONT COLOR=black><B>print</B></FONT> msg
        <FONT COLOR=black><B>print</B></FONT> self.USAGE % self.__dict__
        sys.exit(2)

    <FONT COLOR=black><B>def</B></FONT> parseArgs(self, argv):
        <FONT COLOR=black><B>import</B></FONT> getopt
        <FONT COLOR=black><B>try</B></FONT>:
            options, args = getopt.getopt(argv[1:], <FONT COLOR=#FF0000>'hH'</FONT>, [<FONT COLOR=#FF0000>'help'</FONT>])
            opts = {}
            <FONT COLOR=black><B>for</B></FONT> opt, value <FONT COLOR=black><B>in</B></FONT> options:
                <FONT COLOR=black><B>if</B></FONT> opt <FONT COLOR=black><B>in</B></FONT> (<FONT COLOR=#FF0000>'-h'</FONT>,<FONT COLOR=#FF0000>'-H'</FONT>,<FONT COLOR=#FF0000>'--help'</FONT>):
                    self.usageExit()
            <FONT COLOR=black><B>if</B></FONT> len(args) == 0 <FONT COLOR=black><B>and</B></FONT> self.defaultTest <FONT COLOR=black><B>is</B></FONT> None:
                <FONT COLOR=black><B>raise</B></FONT> getopt.error, <FONT COLOR=#FF0000>"No default test is defined."</FONT>
            <FONT COLOR=black><B>if</B></FONT> len(args) &gt; 0:
                self.testNames = args
            <FONT COLOR=black><B>else</B></FONT>:
                self.testNames = (self.defaultTest,)
        <FONT COLOR=black><B>except</B></FONT> getopt.error, msg:
            self.usageExit(msg)

    <FONT COLOR=black><B>def</B></FONT> createTests(self):
        tests = []
        <FONT COLOR=black><B>for</B></FONT> testName <FONT COLOR=black><B>in</B></FONT> self.testNames:
            tests.append(createTestInstance(testName, self.module))
        self.test = TestSuite(tests)

    <FONT COLOR=black><B>def</B></FONT> runTests(self):
        <FONT COLOR=black><B>if</B></FONT> self.testRunner <FONT COLOR=black><B>is</B></FONT> None:
            self.testRunner = TextTestRunner()
        result = self.testRunner.run(self.test)
        sys.exit(<FONT COLOR=black><B>not</B></FONT> result.wasSuccessful())    

main = TestProgram


<FONT COLOR=#1111CC>##############################################################################</FONT>
<FONT COLOR=#1111CC># Executing this module from the command line</FONT>
<FONT COLOR=#1111CC>##############################################################################</FONT>

<FONT COLOR=black><B>if</B></FONT> __name__ == <FONT COLOR=#FF0000>"__main__"</FONT>:
    main(module=None)
</PRE>
                  <!--footer-->
                  </BODY>
