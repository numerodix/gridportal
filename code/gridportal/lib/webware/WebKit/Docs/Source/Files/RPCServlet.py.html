<HTML><HEAD><TITLE>WebKit/RPCServlet.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=black><B>from</B></FONT> HTTPServlet <FONT COLOR=black><B>import</B></FONT> HTTPServlet
<FONT COLOR=black><B>import</B></FONT> traceback, sys


<FONT COLOR=black><B>class</B></FONT> RPCServlet(HTTPServlet):

    <FONT COLOR=black><B>def</B></FONT> call(self, methodName, *args, **keywords):
        <FONT COLOR=#FF0000>"""
        Subclasses may override this class for custom handling of
        methods.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> methodName <FONT COLOR=black><B>in</B></FONT> self.exposedMethods():
            <FONT COLOR=black><B>return</B></FONT> getattr(self, methodName)( *args, **keywords)
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>raise</B></FONT> NotImplementedError, methodName

    <FONT COLOR=black><B>def</B></FONT> exposedMethods(self):
        <FONT COLOR=#FF0000>"""
        Subclasses should return a list of methods that will be
        exposed through XML-RPC.
        """</FONT>
        <FONT COLOR=black><B>return</B></FONT> [<FONT COLOR=#FF0000>'exposedMethods'</FONT>]

    <FONT COLOR=black><B>def</B></FONT> resultForException(self, e, trans):
        <FONT COLOR=#FF0000>"""
        Given an unhandled exception, returns the string that should be
        sent back in the RPC response as controlled by the
        RPCExceptionReturn setting.
        """</FONT>
        <FONT COLOR=#1111CC># report exception back to server</FONT>
        setting = trans.application().setting(<FONT COLOR=#FF0000>'RPCExceptionReturn'</FONT>)
        <FONT COLOR=black><B>assert</B></FONT> setting <FONT COLOR=black><B>in</B></FONT> (<FONT COLOR=#FF0000>'occurred'</FONT>, <FONT COLOR=#FF0000>'exception'</FONT>, <FONT COLOR=#FF0000>'traceback'</FONT>), <FONT COLOR=#FF0000>'setting=%r'</FONT> % setting
        <FONT COLOR=black><B>if</B></FONT> setting==<FONT COLOR=#FF0000>'occurred'</FONT>:
            result = <FONT COLOR=#FF0000>'unhandled exception'</FONT>
        <FONT COLOR=black><B>elif</B></FONT> setting==<FONT COLOR=#FF0000>'exception'</FONT>:
            result = str(e)
        <FONT COLOR=black><B>elif</B></FONT> setting==<FONT COLOR=#FF0000>'traceback'</FONT>:
            result = <FONT COLOR=#FF0000>''</FONT>.join(traceback.format_exception(*sys.exc_info()))
        <FONT COLOR=black><B>return</B></FONT> result

    <FONT COLOR=black><B>def</B></FONT> sendOK(self, contentType, contents, trans, contentEncoding=None):
        <FONT COLOR=#FF0000>"""
        Sends a 200 OK response with the given contents.
        """</FONT>
        response = trans.response()
        response.setStatus(200, <FONT COLOR=#FF0000>'OK'</FONT>)
        response.setHeader(<FONT COLOR=#FF0000>'Content-type'</FONT>, contentType)
        response.setHeader(<FONT COLOR=#FF0000>'Content-length'</FONT>, str(len(contents)))
        <FONT COLOR=black><B>if</B></FONT> contentEncoding:
            response.setHeader(<FONT COLOR=#FF0000>'Content-encoding'</FONT>, contentEncoding)
        response.write(contents)

    <FONT COLOR=black><B>def</B></FONT> handleException(self, transaction):
        <FONT COLOR=#FF0000>"""
        If ReportRPCExceptionsInWebKit is set to true, then
        flush the response (because we don't want the standard HTML traceback
        to be appended to the response) and then handle the exception in the
        standard WebKit way.  This means logging it to the console, storing
        it in the error log, sending error email, etc. depending on the
        settings.
        """</FONT>
        setting = transaction.application().setting(<FONT COLOR=#FF0000>'ReportRPCExceptionsInWebKit'</FONT>)
        <FONT COLOR=black><B>if</B></FONT> setting:
            transaction.response().flush()
            transaction.application().handleExceptionInTransaction(sys.exc_info(), transaction)
</PRE>
                  <!--footer-->
                  </BODY>
