<HTML><HEAD><TITLE>WebKit/SessionFileStore.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=black><B>from</B></FONT> SessionStore <FONT COLOR=black><B>import</B></FONT> SessionStore
<FONT COLOR=black><B>import</B></FONT> os
<FONT COLOR=black><B>from</B></FONT> glob <FONT COLOR=black><B>import</B></FONT> glob
<FONT COLOR=black><B>import</B></FONT> threading

debug = 0


<FONT COLOR=black><B>class</B></FONT> SessionFileStore(SessionStore):
    <FONT COLOR=#FF0000>"""
    Stores the sessions on disk in the Sessions/ directory, one file
    per session.

    This is useful for various situations:
        1. Using the OneShot adapter
        2. Doing development (so that restarting the app server won't
           lose session information).
        3. Fault tolerance
        4. Clustering

    Note that the last two are not yet supported by WebKit (as of 0.4,
    8/2000).
    """</FONT>


    <FONT COLOR=#1111CC>## Init ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, app):
        SessionStore.__init__(self, app)
        self._sessionDir = app.serverSidePath(<FONT COLOR=#FF0000>'Sessions'</FONT>)
        self._lock = threading.Lock()


    <FONT COLOR=#1111CC>## Access ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __len__(self):
        <FONT COLOR=black><B>if</B></FONT> debug:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; len'</FONT>, len(self.keys())
        <FONT COLOR=black><B>return</B></FONT> len(self.keys())

    <FONT COLOR=black><B>def</B></FONT> __getitem__(self, key):
        <FONT COLOR=black><B>if</B></FONT> debug:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; get (%s)'</FONT> % key
        filename = self.filenameForKey(key)
        self._lock.acquire()
        <FONT COLOR=black><B>try</B></FONT>:
            <FONT COLOR=black><B>try</B></FONT>:
                file = open(filename)
            <FONT COLOR=black><B>except</B></FONT> IOError:
                <FONT COLOR=black><B>raise</B></FONT> KeyError, key
            <FONT COLOR=black><B>try</B></FONT>:
                item = self.decoder()(file)
            <FONT COLOR=black><B>except</B></FONT>:
                <FONT COLOR=#1111CC># Corrupt data; pretend it doesn't exist</FONT>
                <FONT COLOR=black><B>raise</B></FONT> KeyError, key
            file.close()
        <FONT COLOR=black><B>finally</B></FONT>:
            self._lock.release()
        <FONT COLOR=black><B>return</B></FONT> item

    <FONT COLOR=black><B>def</B></FONT> __setitem__(self, key, item):
        <FONT COLOR=#1111CC># @@ 2001-11-12 ce: It's still possible that two threads are updating the same</FONT>
        <FONT COLOR=#1111CC># session as the same time (due to the user having two windows open) in which</FONT>
        <FONT COLOR=#1111CC># case one will clobber the results of the other! Probably need file locking</FONT>
        <FONT COLOR=#1111CC># to solve this.</FONT>
        <FONT COLOR=#1111CC># @@ 2001-11-16 gat: In order to avoid sessions clobering each other, you'd</FONT>
        <FONT COLOR=#1111CC># have to lock the file for the entire time that the servlet is manipulating</FONT>
        <FONT COLOR=#1111CC># the session, which would block any other servlets from using that session.</FONT>
        <FONT COLOR=#1111CC># Doesn't seem like a great solution to me.</FONT>

        <FONT COLOR=black><B>if</B></FONT> debug:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; setitem(%s,%s)'</FONT> % (key, item)
        filename = self.filenameForKey(key)
        self._lock.acquire()
        <FONT COLOR=black><B>try</B></FONT>:
            file = open(filename, <FONT COLOR=#FF0000>'w'</FONT>)
            <FONT COLOR=black><B>try</B></FONT>:
                self.encoder()(item, file)
            <FONT COLOR=black><B>except</B></FONT>: <FONT COLOR=#1111CC># error pickling the session.</FONT>
                <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Error saving session to disk:"</FONT>,key
                file.close()
                os.remove(filename) <FONT COLOR=#1111CC># remove file because it is corrupt.</FONT>
                self.application().handleException()
            <FONT COLOR=black><B>else</B></FONT>:
                file.close()
        <FONT COLOR=black><B>finally</B></FONT>:
            self._lock.release()

    <FONT COLOR=black><B>def</B></FONT> __delitem__(self, key):
        filename = self.filenameForKey(key)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> os.path.exists(filename):
            <FONT COLOR=black><B>raise</B></FONT> KeyError, key
        sess = self[key]
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> sess.isExpired():
            sess.expiring()
        os.remove(filename)

    <FONT COLOR=black><B>def</B></FONT> has_key(self, key):
        <FONT COLOR=black><B>return</B></FONT> os.path.exists(self.filenameForKey(key))

    <FONT COLOR=black><B>def</B></FONT> keys(self):
        start = len(self._sessionDir)+1
        end = -len(<FONT COLOR=#FF0000>'.ses'</FONT>)
        keys = glob(os.path.join(self._sessionDir, <FONT COLOR=#FF0000>'*.ses'</FONT>))
        keys = map(<FONT COLOR=black><B>lambda</B></FONT> key, start=start, end=end: key[start:end], keys)
        <FONT COLOR=black><B>if</B></FONT> debug:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; keys ='</FONT>, keys
        <FONT COLOR=black><B>return</B></FONT> keys

    <FONT COLOR=black><B>def</B></FONT> clear(self):
        <FONT COLOR=black><B>for</B></FONT> filename <FONT COLOR=black><B>in</B></FONT> glob(os.path.join(self._sessionDir,<FONT COLOR=#FF0000>'*.ses'</FONT>)):
            os.remove(filename)


    <FONT COLOR=#1111CC>## Application support ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> storeSession(self, session):
        key = session.identifier()
        self[key] = session

    <FONT COLOR=black><B>def</B></FONT> storeAllSessions(self):
        <FONT COLOR=black><B>pass</B></FONT>

<FONT COLOR=#1111CC>##  def cleanStaleSessions(self, task=None):</FONT>
<FONT COLOR=#1111CC>##      """</FONT>
<FONT COLOR=#1111CC>##      Called by the Application to tell this store to clean out all sessions that</FONT>
<FONT COLOR=#1111CC>##      have exceeded their lifetime.</FONT>
<FONT COLOR=#1111CC>##      """</FONT>
<FONT COLOR=#1111CC>##      we don't know the timeout without opening the session, so his can't work.</FONT>
<FONT COLOR=#1111CC>##      curTime = time.time()</FONT>
<FONT COLOR=#1111CC>##      for key in self.keys():</FONT>
<FONT COLOR=#1111CC>##          mtime = os.path.getmtime(self.filenameForKey(key))</FONT>
<FONT COLOR=#1111CC>##          if (curTime - mtime) &gt;= sess.timeout()  or  sess.timeout()==0:</FONT>
<FONT COLOR=#1111CC>##              sess.expiring()</FONT>
<FONT COLOR=#1111CC>##              del self[key]</FONT>

    <FONT COLOR=#1111CC>## Self utility ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> filenameForKey(self, key):
        <FONT COLOR=black><B>return</B></FONT> self._sessionDir + <FONT COLOR=#FF0000>'/%s.ses'</FONT> % key
</PRE>
                  <!--footer-->
                  </BODY>
