<HTML><HEAD><TITLE>WebKit/Application.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=#1111CC>#!/usr/bin/env python</FONT>

<FONT COLOR=black><B>from</B></FONT> Common <FONT COLOR=black><B>import</B></FONT> *
<FONT COLOR=black><B>from</B></FONT> UserDict <FONT COLOR=black><B>import</B></FONT> UserDict
<FONT COLOR=black><B>from</B></FONT> Object <FONT COLOR=black><B>import</B></FONT> Object
<FONT COLOR=black><B>from</B></FONT> Servlet <FONT COLOR=black><B>import</B></FONT> Servlet
<FONT COLOR=black><B>from</B></FONT> ServletFactory <FONT COLOR=black><B>import</B></FONT> *
<FONT COLOR=black><B>from</B></FONT> UnknownFileTypeServlet <FONT COLOR=black><B>import</B></FONT> UnknownFileTypeServletFactory
<FONT COLOR=black><B>from</B></FONT> types <FONT COLOR=black><B>import</B></FONT> FloatType
<FONT COLOR=black><B>from</B></FONT> glob <FONT COLOR=black><B>import</B></FONT> glob
<FONT COLOR=black><B>import</B></FONT> imp
<FONT COLOR=black><B>import</B></FONT> string
<FONT COLOR=black><B>from</B></FONT> threading <FONT COLOR=black><B>import</B></FONT> Lock, Thread, Event
<FONT COLOR=black><B>from</B></FONT> time <FONT COLOR=black><B>import</B></FONT> *
<FONT COLOR=black><B>from</B></FONT> fnmatch <FONT COLOR=black><B>import</B></FONT> fnmatch

<FONT COLOR=black><B>from</B></FONT> WebKit.Cookie <FONT COLOR=black><B>import</B></FONT> Cookie

<FONT COLOR=black><B>from</B></FONT> WebUtils.HTMLForException <FONT COLOR=black><B>import</B></FONT> HTMLForException

<FONT COLOR=black><B>from</B></FONT> ExceptionHandler <FONT COLOR=black><B>import</B></FONT> ExceptionHandler  

<FONT COLOR=black><B>from</B></FONT> ConfigurableForServerSidePath <FONT COLOR=black><B>import</B></FONT> ConfigurableForServerSidePath

<FONT COLOR=black><B>from</B></FONT> TaskKit.Scheduler <FONT COLOR=black><B>import</B></FONT> Scheduler

<FONT COLOR=black><B>from</B></FONT> ASStreamOut <FONT COLOR=black><B>import</B></FONT> ASStreamOut

debug = 0

<FONT COLOR=black><B>class</B></FONT> ApplicationError(Exception):
    <FONT COLOR=black><B>pass</B></FONT>

<FONT COLOR=black><B>class</B></FONT> EndResponse(Exception):
    <FONT COLOR=#FF0000>"""
    Used to prematurely break out of the awake()/respond()/sleep() cycle
    without reporting a traceback.  During servlet processing, if this
    exception is caught during respond() then sleep() is called and the
    response is sent.  If caught during awake() then both respond() and
    sleep() are skipped and the response is sent.
    """</FONT>
    <FONT COLOR=black><B>pass</B></FONT>

<FONT COLOR=black><B>class</B></FONT> Application(ConfigurableForServerSidePath, Object):
    <FONT COLOR=#FF0000>"""
    FUTURE
        * 2000-04-09 ce: Automatically open in browser.
        * 2000-04-09 ce: Option to remove HTML comments in responses.
        * 2000-04-09 ce: Option remove unnecessary white space in responses.
        * 2000-04-09 ce: Debugging flag and debug print method.
        * 2000-04-09 ce: A web-based, interactive monitor to the application.
        * 2000-04-09 ce: Record and playback of requests and responses. Useful for regression testing.
        * 2000-04-09 ce: sessionTimeout() and a hook for when the session has timed out.
        * 2000-04-09 ce: pageRefreshOnBacktrack
        * 2000-04-09 ce: terminate() and isTerminating()
        * 2000-04-09 ce: isRefusingNewSessions()
        * 2000-04-09 ce: terminateAfterTimeInterval()
        * 2000-04-09 ce: restoreSessionWithID:inTransaction:
        * 2000-04-09 ce: pageWithNameForRequest/Transaction() (?)
        * 2000-04-09 ce: port() and setPort() (?)
        * 2000-04-09 ce: Does request handling need to be embodied in a separate object?
              - Probably, as we may want request handlers for various file types.
        * 2000-04-09 ce: Concurrent request handling (probably through multi-threading)
    """</FONT>

    <FONT COLOR=#1111CC>## Init ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, server=None, transactionClass=None, sessionClass=None, requestClass=None, responseClass=None, exceptionHandlerClass=None, contexts=None, useSessionSweeper=1):

        self._server = server
        self._serverSidePath = server.serverSidePath()

        ConfigurableForServerSidePath.__init__(self)
        Object.__init__(self)

        <FONT COLOR=black><B>if</B></FONT> self.setting(<FONT COLOR=#FF0000>'PrintConfigAtStartUp'</FONT>):
            self.printConfig()

        self.initVersions()

        <FONT COLOR=black><B>if</B></FONT> transactionClass:
            self._transactionClass = transactionClass
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>from</B></FONT> Transaction <FONT COLOR=black><B>import</B></FONT> Transaction
            self._transactionClass = Transaction

        <FONT COLOR=black><B>if</B></FONT> sessionClass:
            self._sessionClass = sessionClass
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>from</B></FONT> Session <FONT COLOR=black><B>import</B></FONT> Session
            self._sessionClass = Session

        <FONT COLOR=black><B>if</B></FONT> requestClass:
            self._requestClass = requestClass
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>from</B></FONT> HTTPRequest <FONT COLOR=black><B>import</B></FONT> HTTPRequest
            self._requestClass = HTTPRequest

        <FONT COLOR=black><B>if</B></FONT> responseClass:
            self._responseClass = responseClass
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>from</B></FONT> HTTPResponse <FONT COLOR=black><B>import</B></FONT> HTTPResponse
            self._responseClass = HTTPResponse

        <FONT COLOR=black><B>if</B></FONT> exceptionHandlerClass:
            self._exceptionHandlerClass = exceptionHandlerClass
        <FONT COLOR=black><B>else</B></FONT>:
            self._exceptionHandlerClass = None

        <FONT COLOR=#1111CC># Init other attributes</FONT>
        self._servletCacheByPath = {}
        self._serverSideInfoCacheByPath = {}
        self._cacheDictLock = Lock()
        self._instanceCacheSize = self._server.setting(<FONT COLOR=#FF0000>'MaxServerThreads'</FONT>)
        self._shutDownHandlers = []

        <FONT COLOR=#1111CC># Set up servlet factories</FONT>
        self._factoryList = []  <FONT COLOR=#1111CC># the list of factories</FONT>
        self._factoryByExt = {} <FONT COLOR=#1111CC># a dictionary that maps all known extensions to their factories, for quick look up</FONT>
        self.addServletFactory(PythonServletFactory(self))
        self.addServletFactory(UnknownFileTypeServletFactory(self))
        <FONT COLOR=#1111CC># ^ @@ 2000-05-03 ce: make this customizable at least through a method (that can be overridden) if not a config file (or both)</FONT>

<FONT COLOR=#1111CC>## TaskManager</FONT>
        <FONT COLOR=black><B>if</B></FONT> self._server.isPersistent():
            self._taskManager = Scheduler(1)
            self._taskManager.start()
<FONT COLOR=#1111CC>## End TaskManager</FONT>


<FONT COLOR=#1111CC>## Contexts</FONT>
        <FONT COLOR=black><B>if</B></FONT> contexts: <FONT COLOR=#1111CC>#Try to get this from the Config file</FONT>
            defctxt = contexts
        <FONT COLOR=black><B>else</B></FONT>: <FONT COLOR=#1111CC>#Get it from Configurable object, which gets it from defaults or the user config file</FONT>
            defctxt = self.setting(<FONT COLOR=#FF0000>'Contexts'</FONT>)
        self._contexts={}
        <FONT COLOR=#1111CC># First load all contexts except the default</FONT>
        contextDirToName = {}
        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> defctxt.keys():
            <FONT COLOR=black><B>if</B></FONT> i != <FONT COLOR=#FF0000>'default'</FONT>:
                <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> os.path.isabs(defctxt[i]):
                    path = self.serverSidePath(defctxt[i])
                <FONT COLOR=black><B>else</B></FONT>:
                    path = defctxt[i]
                self.addContext(i, path)
                contextDirToName[path] = i
        <FONT COLOR=#1111CC># @@ gat: this code would be much cleaner if we had a separate DefaultContext config variable.</FONT>
        <FONT COLOR=#1111CC># load in the default context, if any</FONT>
        self._defaultContextName = None
        <FONT COLOR=black><B>if</B></FONT> defctxt.has_key(<FONT COLOR=#FF0000>'default'</FONT>):
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> os.path.isabs(defctxt[<FONT COLOR=#FF0000>'default'</FONT>]):
                path = self.serverSidePath(defctxt[<FONT COLOR=#FF0000>'default'</FONT>])
            <FONT COLOR=black><B>else</B></FONT>:
                path = defctxt[<FONT COLOR=#FF0000>'default'</FONT>]

            <FONT COLOR=#1111CC># see if the default context is the same as one of the other contexts</FONT>
            self._defaultContextName = contextDirToName.get(path, None)
            <FONT COLOR=black><B>if</B></FONT> self._defaultContextName:
                <FONT COLOR=#1111CC># the default context is shared with another context</FONT>
                self._setContext(<FONT COLOR=#FF0000>'default'</FONT>, self.context(self._defaultContextName))
            <FONT COLOR=black><B>else</B></FONT>:
                <FONT COLOR=#1111CC># the default context is separate from the other contexts, so add it like any other context</FONT>
                self._defaultContextName = <FONT COLOR=#FF0000>'default'</FONT>
                self.addContext(<FONT COLOR=#FF0000>'default'</FONT>, path)
        <FONT COLOR=black><B>print</B></FONT>
<FONT COLOR=#1111CC>## End Contexts</FONT>

<FONT COLOR=#1111CC>## Session store</FONT>
        <FONT COLOR=#1111CC># Create the session store</FONT>
        <FONT COLOR=black><B>from</B></FONT> SessionMemoryStore <FONT COLOR=black><B>import</B></FONT> SessionMemoryStore
        <FONT COLOR=black><B>from</B></FONT> SessionFileStore <FONT COLOR=black><B>import</B></FONT> SessionFileStore
        <FONT COLOR=black><B>from</B></FONT> SessionDynamicStore <FONT COLOR=black><B>import</B></FONT> SessionDynamicStore
        klass = locals()[<FONT COLOR=#FF0000>'Session'</FONT>+self.setting(<FONT COLOR=#FF0000>'SessionStore'</FONT>,<FONT COLOR=#FF0000>'File'</FONT>)+<FONT COLOR=#FF0000>'Store'</FONT>]
        <FONT COLOR=black><B>assert</B></FONT> type(klass) <FONT COLOR=black><B>is</B></FONT> ClassType
        self._sessions = klass(self)
<FONT COLOR=#1111CC>## End Session store</FONT>



        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'Current directory:'</FONT>, os.getcwd()

        self.running = 1

        <FONT COLOR=black><B>if</B></FONT> useSessionSweeper:
            self.startSessionSweeper()

        self._cacheServletInstances = self.setting(<FONT COLOR=#FF0000>"CacheServletInstances"</FONT>,1)
        <FONT COLOR=black><B>print</B></FONT>

        <FONT COLOR=black><B>try</B></FONT>:
            <FONT COLOR=#1111CC># First try the working dir</FONT>
            self._404Page = open(os.path.join(self._serverSidePath,<FONT COLOR=#FF0000>"404Text.txt"</FONT>),<FONT COLOR=#FF0000>"r"</FONT>).read()
        <FONT COLOR=black><B>except</B></FONT>:
            <FONT COLOR=black><B>try</B></FONT>:
                <FONT COLOR=#1111CC># Then try the directory this file is located in</FONT>
                self._404Page = open(os.path.join(os.path.dirname(os.path.abspath(__file__)), <FONT COLOR=#FF0000>"404Text.txt"</FONT>),<FONT COLOR=#FF0000>"r"</FONT>).read()
            <FONT COLOR=black><B>except</B></FONT>:
                <FONT COLOR=#1111CC># Fall back on a simple string</FONT>
                self._404Page = <FONT COLOR=#FF0000>"""404 Error&lt;p&gt;File Not Found: %s"""</FONT>

        <FONT COLOR=#1111CC># @@ ISB 09/02: make this default or get rid of it eventually</FONT>
        <FONT COLOR=black><B>if</B></FONT> self.setting(<FONT COLOR=#FF0000>'ExtraPathInfo'</FONT>, 0):
            self.serverSideInfoForRequestOld = self.serverSideInfoForRequest
            self.serverSideInfoForRequest = self.serverSideInfoForRequestNewAlgorithm
            self._serverSideInfoCacheByPathNew = {}
            self._filesToHideRegexes = []
            self._filesToServeRegexes = []
            <FONT COLOR=black><B>from</B></FONT> fnmatch <FONT COLOR=black><B>import</B></FONT> translate as fnTranslate
            <FONT COLOR=black><B>import</B></FONT> re
            <FONT COLOR=black><B>for</B></FONT> pattern <FONT COLOR=black><B>in</B></FONT> self.setting(<FONT COLOR=#FF0000>'FilesToHide'</FONT>):
                self._filesToHideRegexes.append(
                    re.compile(fnTranslate(pattern)))
            <FONT COLOR=black><B>for</B></FONT> pattern <FONT COLOR=black><B>in</B></FONT> self.setting(<FONT COLOR=#FF0000>'FilesToServe'</FONT>):
                self._filesToServeRegexes.append(
                    re.compile(fnTranslate(pattern)))


    <FONT COLOR=black><B>def</B></FONT> initVersions(self):
        <FONT COLOR=#FF0000>"""
        Initialize attributes that store the Webware and WebKit versions
        as both tuples and strings. These are stored in the Properties.py
        files.
        """</FONT>
        <FONT COLOR=black><B>from</B></FONT> MiscUtils.PropertiesObject <FONT COLOR=black><B>import</B></FONT> PropertiesObject
        props = PropertiesObject(os.path.join(self.webwarePath(), <FONT COLOR=#FF0000>'Properties.py'</FONT>))
        self._webwareVersion = props[<FONT COLOR=#FF0000>'version'</FONT>]
        self._webwareVersionString = props[<FONT COLOR=#FF0000>'versionString'</FONT>]

        props = PropertiesObject(os.path.join(self.webKitPath(), <FONT COLOR=#FF0000>'Properties.py'</FONT>))
        self._webKitVersion = props[<FONT COLOR=#FF0000>'version'</FONT>]
        self._webKitVersionString = props[<FONT COLOR=#FF0000>'versionString'</FONT>]


<FONT COLOR=#1111CC>## Task access</FONT>
    <FONT COLOR=black><B>def</B></FONT> taskManager(self):
        <FONT COLOR=black><B>return</B></FONT> self._taskManager

<FONT COLOR=#1111CC>## Session sweep task</FONT>
    <FONT COLOR=black><B>def</B></FONT> startSessionSweeper(self):
        <FONT COLOR=black><B>from</B></FONT> Tasks <FONT COLOR=black><B>import</B></FONT> SessionTask
        <FONT COLOR=black><B>import</B></FONT> time
        task = SessionTask.SessionTask(self._sessions)
        tm = self.taskManager()
        sweepinterval = self.setting(<FONT COLOR=#FF0000>'SessionTimeout'</FONT>)*60/10
        tm.addPeriodicAction(time.time()+sweepinterval, sweepinterval, task, <FONT COLOR=#FF0000>"SessionSweeper"</FONT>)
        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Session Sweeper started"</FONT>

<FONT COLOR=#1111CC>## Shutdown</FONT>
    <FONT COLOR=black><B>def</B></FONT> shutDown(self):
        <FONT COLOR=#FF0000>"""
        Called by AppServer when it is shuting down.  The __del__ function of Application probably won't be called due to circular references.
        """</FONT>
        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Application is Shutting Down"</FONT>
        self.running = 0
        <FONT COLOR=black><B>if</B></FONT> hasattr(self, <FONT COLOR=#FF0000>'_sessSweepThread'</FONT>):
            <FONT COLOR=#1111CC># We don't always have this, hence the 'if' above</FONT>
            self._closeEvent.set()
            self._sessSweepThread.join()
            <FONT COLOR=black><B>del</B></FONT> self._sessSweepThread
        self._sessions.storeAllSessions()
        <FONT COLOR=black><B>if</B></FONT> self._server.isPersistent():
            self.taskManager().stop()
        <FONT COLOR=black><B>del</B></FONT> self._sessions
        <FONT COLOR=black><B>del</B></FONT> self._factoryByExt
        <FONT COLOR=black><B>del</B></FONT> self._factoryList
        <FONT COLOR=black><B>del</B></FONT> self._server
        <FONT COLOR=black><B>del</B></FONT> self._servletCacheByPath

        <FONT COLOR=#1111CC># Call all registered shutdown handlers</FONT>
        <FONT COLOR=black><B>for</B></FONT> shutDownHandler <FONT COLOR=black><B>in</B></FONT> self._shutDownHandlers:
            shutDownHandler()
        <FONT COLOR=black><B>del</B></FONT> self._shutDownHandlers

        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Application has been succesfully shutdown."</FONT>

    <FONT COLOR=black><B>def</B></FONT> addShutDownHandler(self, func):
        <FONT COLOR=#FF0000>"""
        Adds this function to a list of functions that are called when the application
        shuts down.
        """</FONT>
        self._shutDownHandlers.append(func)

    <FONT COLOR=#1111CC>## Config ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> defaultConfig(self):
        <FONT COLOR=black><B>return</B></FONT> {
            <FONT COLOR=#FF0000>'PrintConfigAtStartUp'</FONT>: 1,
            <FONT COLOR=#FF0000>'DirectoryFile'</FONT>:        [<FONT COLOR=#FF0000>'index'</FONT>, <FONT COLOR=#FF0000>'Main'</FONT>],
            <FONT COLOR=#FF0000>'ExtensionsToIgnore'</FONT>:   [<FONT COLOR=#FF0000>'.pyc'</FONT>, <FONT COLOR=#FF0000>'.pyo'</FONT>, <FONT COLOR=#FF0000>'.py~'</FONT>, <FONT COLOR=#FF0000>'.bak'</FONT>, <FONT COLOR=#FF0000>'.tmpl'</FONT>],
            <FONT COLOR=#FF0000>'ExtensionsToServe'</FONT>:   None,
            <FONT COLOR=#FF0000>'UseCascadingExtensions'</FONT>:1,
            <FONT COLOR=#FF0000>'ExtensionCascadeOrder'</FONT>:[<FONT COLOR=#FF0000>'.psp'</FONT>,<FONT COLOR=#FF0000>'.py'</FONT>,<FONT COLOR=#FF0000>'.html'</FONT>,],


            <FONT COLOR=#FF0000>'FilesToHide'</FONT>: [<FONT COLOR=#FF0000>'.*'</FONT>, <FONT COLOR=#FF0000>'*~'</FONT>, <FONT COLOR=#FF0000>'*bak'</FONT>, <FONT COLOR=#FF0000>'*.tmpl'</FONT>, <FONT COLOR=#FF0000>'*.pyc'</FONT>, <FONT COLOR=#FF0000>'*.pyo'</FONT>, <FONT COLOR=#FF0000>'*.config'</FONT>],
            <FONT COLOR=#FF0000>'FilesToServe'</FONT>: None,

            <FONT COLOR=#FF0000>'LogActivity'</FONT>:          1,
            <FONT COLOR=#FF0000>'ActivityLogFilename'</FONT>:  <FONT COLOR=#FF0000>'Logs/Activity.csv'</FONT>,
            <FONT COLOR=#FF0000>'ActivityLogColumns'</FONT>:   [<FONT COLOR=#FF0000>'request.remoteAddress'</FONT>, <FONT COLOR=#FF0000>'request.method'</FONT>, <FONT COLOR=#FF0000>'request.uri'</FONT>, <FONT COLOR=#FF0000>'response.size'</FONT>, <FONT COLOR=#FF0000>'servlet.name'</FONT>, <FONT COLOR=#FF0000>'request.timeStamp'</FONT>, <FONT COLOR=#FF0000>'transaction.duration'</FONT>, <FONT COLOR=#FF0000>'transaction.errorOccurred'</FONT>],
            <FONT COLOR=#FF0000>'SessionStore'</FONT>:         <FONT COLOR=#FF0000>'Memory'</FONT>,  <FONT COLOR=#1111CC># can be File or Memory</FONT>
            <FONT COLOR=#FF0000>'SessionTimeout'</FONT>:        60,  <FONT COLOR=#1111CC># minutes</FONT>
            <FONT COLOR=#FF0000>'IgnoreInvalidSession'</FONT>: 1,
            <FONT COLOR=#FF0000>'UseAutomaticPathSessions'</FONT>: 0,

            <FONT COLOR=#1111CC># Error handling</FONT>
            <FONT COLOR=#FF0000>'ShowDebugInfoOnErrors'</FONT>: 1,
            <FONT COLOR=#FF0000>'IncludeFancyTraceback'</FONT>: 0,
            <FONT COLOR=#FF0000>'FancyTracebackContext'</FONT>: 5,
            <FONT COLOR=#FF0000>'UserErrorMessage'</FONT>:      <FONT COLOR=#FF0000>'The site is having technical difficulties with this page. An error has been logged, and the problem will be fixed as soon as possible. Sorry!'</FONT>,
            <FONT COLOR=#FF0000>'ErrorLogFilename'</FONT>:      <FONT COLOR=#FF0000>'Logs/Errors.csv'</FONT>,
            <FONT COLOR=#FF0000>'SaveErrorMessages'</FONT>:     1,
            <FONT COLOR=#FF0000>'ErrorMessagesDir'</FONT>:      <FONT COLOR=#FF0000>'ErrorMsgs'</FONT>,
            <FONT COLOR=#FF0000>'EmailErrors'</FONT>:           0, <FONT COLOR=#1111CC># be sure to review the following settings when enabling error e-mails</FONT>
            <FONT COLOR=#FF0000>'ErrorEmailServer'</FONT>:      <FONT COLOR=#FF0000>'mail.-.com'</FONT>,
            <FONT COLOR=#FF0000>'ErrorEmailHeaders'</FONT>:     { <FONT COLOR=#FF0000>'From'</FONT>:         <FONT COLOR=#FF0000>'-@-.com'</FONT>,
                                       <FONT COLOR=#FF0000>'To'</FONT>:           [<FONT COLOR=#FF0000>'-@-.com'</FONT>],
                                       <FONT COLOR=#FF0000>'Reply-to'</FONT>:     <FONT COLOR=#FF0000>'-@-.com'</FONT>,
                                       <FONT COLOR=#FF0000>'content-type'</FONT>: <FONT COLOR=#FF0000>'text/html'</FONT>,
                                       <FONT COLOR=#FF0000>'Subject'</FONT>:      <FONT COLOR=#FF0000>'Error'</FONT>
                                     },
            <FONT COLOR=#FF0000>'MaxValueLengthInExceptionReport'</FONT>: 500,
            <FONT COLOR=#FF0000>'RPCExceptionReturn'</FONT>:    <FONT COLOR=#FF0000>'traceback'</FONT>,
            <FONT COLOR=#FF0000>'ReportRPCExceptionsInWebKit'</FONT>:   1,
            <FONT COLOR=#FF0000>'Contexts'</FONT>:              { <FONT COLOR=#FF0000>'default'</FONT>:       <FONT COLOR=#FF0000>'Examples'</FONT>,
                                       <FONT COLOR=#FF0000>'Admin'</FONT>:         <FONT COLOR=#FF0000>'Admin'</FONT>,
                                       <FONT COLOR=#FF0000>'Examples'</FONT>:      <FONT COLOR=#FF0000>'Examples'</FONT>,
                                       <FONT COLOR=#FF0000>'Documentation'</FONT>: <FONT COLOR=#FF0000>'Documentation'</FONT>,
                                       <FONT COLOR=#FF0000>'Testing'</FONT>:       <FONT COLOR=#FF0000>'Testing'</FONT>,
                                     },
            <FONT COLOR=#FF0000>'Debug'</FONT>:    {
                <FONT COLOR=#FF0000>'Sessions'</FONT>: 0,
            },
            <FONT COLOR=#FF0000>'OldStyleActions'</FONT>: 0,
        }

    <FONT COLOR=black><B>def</B></FONT> configFilename(self):
        <FONT COLOR=black><B>return</B></FONT> self.serverSidePath(<FONT COLOR=#FF0000>'Configs/Application.config'</FONT>)

    <FONT COLOR=black><B>def</B></FONT> configReplacementValues(self):
        <FONT COLOR=black><B>return</B></FONT> self._server.configReplacementValues()


    <FONT COLOR=#1111CC>## Versions ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> version(self):
        <FONT COLOR=#FF0000>"""
        Returns the version of the application. This implementation
        returns '0.1'. Subclasses should override to return the correct
        version number.
        """</FONT>
        <FONT COLOR=#1111CC>## @@ 2000-05-01 ce: Maybe this could be a setting 'AppVersion'</FONT>
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>'0.1'</FONT>

    <FONT COLOR=black><B>def</B></FONT> webwareVersion(self):
        <FONT COLOR=#FF0000>""" Returns the Webware version as a tuple. """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._webwareVersion

    <FONT COLOR=black><B>def</B></FONT> webwareVersionString(self):
        <FONT COLOR=#FF0000>""" Returns the Webware version as a printable string. """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._webwareVersionString

    <FONT COLOR=black><B>def</B></FONT> webKitVersion(self):
        <FONT COLOR=#FF0000>""" Returns the WebKit version as a tuple. """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._webKitVersion

    <FONT COLOR=black><B>def</B></FONT> webKitVersionString(self):
        <FONT COLOR=#FF0000>""" Returns the WebKit version as a printable string. """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._webKitVersionString


    <FONT COLOR=#1111CC>## Dispatching Requests ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> dispatchRawRequest(self, newRequestDict, strmOut):
        <FONT COLOR=black><B>return</B></FONT> self.dispatchRequest(self.createRequestForDict(newRequestDict), strmOut)

    <FONT COLOR=black><B>def</B></FONT> dispatchRequest(self, request, strmOut):
        <FONT COLOR=#FF0000>""" Creates the transaction, session, response and servlet for the new request which is then dispatched. The transaction is returned. """</FONT>

        <FONT COLOR=black><B>assert</B></FONT> request <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None
        transaction = None
        <FONT COLOR=black><B>if</B></FONT> request.value(<FONT COLOR=#FF0000>'_captureOut_'</FONT>, 0):
            real_stdout = sys.stdout
            sys.stdout = StringIO()

        transaction = self.createTransactionForRequest(request)
        response    = self.createResponseInTransaction(transaction, strmOut)

        <FONT COLOR=black><B>try</B></FONT>:
            ssPath = request.serverSidePath()
            <FONT COLOR=black><B>if</B></FONT> ssPath <FONT COLOR=black><B>is</B></FONT> None <FONT COLOR=black><B>or</B></FONT> <FONT COLOR=black><B>not</B></FONT> os.path.exists(ssPath):
                self.handleBadURL(transaction)
            <FONT COLOR=black><B>elif</B></FONT> isdir(ssPath) <FONT COLOR=black><B>and</B></FONT> noslash(request.pathInfo()): <FONT COLOR=#1111CC># (*) see below</FONT>
                self.handleDeficientDirectoryURL(transaction)
            <FONT COLOR=black><B>elif</B></FONT> self.isSessionIdProblematic(request):
                self.handleInvalidSession(transaction)
            <FONT COLOR=black><B>elif</B></FONT> self.setting(<FONT COLOR=#FF0000>'UseAutomaticPathSessions'</FONT>) <FONT COLOR=black><B>and</B></FONT> <FONT COLOR=black><B>not</B></FONT> request.hasPathSession():
                self.handleMissingPathSession(transaction)
            <FONT COLOR=black><B>else</B></FONT>:
                validFile = 1
                baseName = os.path.split(ssPath)[1]
                <FONT COLOR=black><B>for</B></FONT> patternToHide <FONT COLOR=black><B>in</B></FONT> self.setting(<FONT COLOR=#FF0000>'FilesToHide'</FONT>):
                    <FONT COLOR=black><B>if</B></FONT> fnmatch(baseName, patternToHide):
                        validFile = 0

                patternsToServe = self.setting(<FONT COLOR=#FF0000>'FilesToServe'</FONT>)
                <FONT COLOR=black><B>if</B></FONT> patternsToServe:
                    validFile = 0
                    <FONT COLOR=black><B>for</B></FONT> patternToServe <FONT COLOR=black><B>in</B></FONT> self.setting(<FONT COLOR=#FF0000>'FilesToServe'</FONT>):
                        <FONT COLOR=black><B>if</B></FONT> fnmatch(baseName, patternToServe):
                            validFile = 1
                <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> validFile:
                    self.handleBadURL(transaction)
                <FONT COLOR=black><B>else</B></FONT>:
                    self.handleGoodURL(transaction)

            <FONT COLOR=black><B>if</B></FONT> request.value(<FONT COLOR=#FF0000>'_captureOut_'</FONT>, 0):
                response.write(<FONT COLOR=#FF0000>'''&lt;br&gt;&lt;p&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#EEEEEE&gt;
                    &lt;pre&gt;%s&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;'''</FONT> % sys.stdout.getvalue())
                sys.stdout = real_stdout

            response.deliver()

            <FONT COLOR=#1111CC># (*) We have to use pathInfo() instead of uri() when looking for the trailing slash, because some webservers, notably Apache, append a trailing / to REQUEST_URI in some circumstances even though the user did not specify that (for example: http://localhost/WebKit.cgi).</FONT>

        <FONT COLOR=black><B>except</B></FONT>:
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"*** ERROR ***"</FONT>
            <FONT COLOR=black><B>if</B></FONT> transaction:
                transaction.setErrorOccurred(1)
            self.handleExceptionInTransaction(sys.exc_info(), transaction)
            transaction.response().deliver() <FONT COLOR=#1111CC># I hope this doesn't throw an exception. :-)   @@ 2000-05-09 ce: provide a secondary exception handling mechanism</FONT>
            <FONT COLOR=black><B>pass</B></FONT>


        <FONT COLOR=black><B>if</B></FONT> self.setting(<FONT COLOR=#FF0000>'LogActivity'</FONT>):
            self.writeActivityLog(transaction)

        path = request.serverSidePath()
        self.returnInstance(transaction, path)

        <FONT COLOR=#1111CC># possible circular reference, so delete it</FONT>
        request.clearTransaction()
        response.clearTransaction()

        <FONT COLOR=black><B>return</B></FONT> transaction

    <FONT COLOR=black><B>def</B></FONT> handleBadURL(self, transaction):
        res = transaction.response()
        res.setHeader(<FONT COLOR=#FF0000>'Status'</FONT>, <FONT COLOR=#FF0000>'404 Error'</FONT>)
<FONT COLOR=#1111CC>##      res.write('&lt;p&gt; 404 Not found: %s' % transaction.request().uri())</FONT>
        res.write(self._404Page % (transaction.request().uri()))
        <FONT COLOR=#1111CC># @@ 2000-06-26 ce: This error page is pretty primitive</FONT>
        <FONT COLOR=#1111CC># @@ 2000-06-26 ce: We should probably load a separate template file and display that</FONT>

    <FONT COLOR=black><B>def</B></FONT> handleDeficientDirectoryURL(self, transaction):
        <FONT COLOR=#1111CC># @@ 2000-11-29 gat:</FONT>
        <FONT COLOR=#1111CC># This splitting and rejoining is necessary in order to handle</FONT>
        <FONT COLOR=#1111CC># url's like http://localhost/WebKit.cgi/Examples?foo=1</FONT>
        <FONT COLOR=#1111CC># without infinite looping.  I'm not sure this is the "right"</FONT>
        <FONT COLOR=#1111CC># way to do this, as it seems to contradict the docstring of</FONT>
        <FONT COLOR=#1111CC># uri(), but it works.  Needs further investigation.</FONT>
        uri = string.split(transaction.request().uri(), <FONT COLOR=#FF0000>'?'</FONT>)
        uriEnd = string.split(uri[0], <FONT COLOR=#FF0000>'/'</FONT>)[-1]
        <FONT COLOR=#1111CC># @@ gat 2000-05-19: this was changed to use a relative redirect starting with "." to force</FONT>
        <FONT COLOR=#1111CC># a client redirect instead of a server redirect.  This fixes problems on IIS.</FONT>
        uri[0] = <FONT COLOR=#FF0000>'./'</FONT> + uriEnd + <FONT COLOR=#FF0000>'/'</FONT>
        newURL = string.join(uri, <FONT COLOR=#FF0000>'?'</FONT>)
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"* handleDeficientDirectoryURL - reditrect to"</FONT>,newURL
        
        res = transaction.response()
        res.setHeader(<FONT COLOR=#FF0000>'Status'</FONT>, <FONT COLOR=#FF0000>'301 Redirect'</FONT>)
        res.setHeader(<FONT COLOR=#FF0000>'Location'</FONT>, newURL)
        res.write(<FONT COLOR=#FF0000>'''&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;301 Moved Permanently&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Moved Permanently&lt;/h1&gt;
        &lt;p&gt; The document has moved to &lt;a href="%s"&gt;%s&lt;/a&gt;.
    &lt;/body&gt;
&lt;/html&gt;'''</FONT> % (newURL, newURL))

    <FONT COLOR=black><B>def</B></FONT> isSessionIdProblematic(self, request, debug=0):
        <FONT COLOR=#FF0000>"""
        Returns 1 if there is a session id and it's not valid (either because it doesn't exist or because it has expired due to inactivity). Having no session id is not considered problematic.
        This method will also expire the session if it's too old.
        This method is invoked by dispatchRequest() as one of the major steps in handling requests.
        """</FONT>
        debug = self.setting(<FONT COLOR=#FF0000>'Debug'</FONT>)[<FONT COLOR=#FF0000>'Sessions'</FONT>]
        <FONT COLOR=black><B>if</B></FONT> debug: prefix = <FONT COLOR=#FF0000>'&gt;&gt; [session] isSessionIdProblematic:'</FONT>
        sid = request.sessionId()
        <FONT COLOR=black><B>if</B></FONT> sid:
            <FONT COLOR=black><B>if</B></FONT> self._sessions.has_key(sid):
                <FONT COLOR=black><B>if</B></FONT> (time()-request.session().lastAccessTime()) &gt;= request.session().timeout():
                    <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> prefix, <FONT COLOR=#FF0000>'session expired: %s'</FONT> % repr(sid)
                    <FONT COLOR=black><B>del</B></FONT> self._sessions[sid]
                    problematic = 1
                <FONT COLOR=black><B>else</B></FONT>:
                    problematic = 0
            <FONT COLOR=black><B>else</B></FONT>:
                <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> prefix, <FONT COLOR=#FF0000>'session does not exist: %s'</FONT> % repr(sid)
                problematic = 1
        <FONT COLOR=black><B>else</B></FONT>:
            problematic = 0
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> prefix, <FONT COLOR=#FF0000>'isSessionIdProblematic ='</FONT>, problematic, <FONT COLOR=#FF0000>',  id ='</FONT>, sid
        <FONT COLOR=black><B>return</B></FONT> problematic

    <FONT COLOR=black><B>def</B></FONT> handleInvalidSession(self, transaction):
        res = transaction.response()
        debug = self.setting(<FONT COLOR=#FF0000>'Debug'</FONT>)[<FONT COLOR=#FF0000>'Sessions'</FONT>]
        <FONT COLOR=black><B>if</B></FONT> debug: prefix = <FONT COLOR=#FF0000>'&gt;&gt; handleInvalidSession:'</FONT>
        cookie = Cookie(<FONT COLOR=#FF0000>'_SID_'</FONT>, <FONT COLOR=#FF0000>''</FONT>)
        cookie.setPath(<FONT COLOR=#FF0000>'/'</FONT>)
        res.addCookie(cookie)
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> prefix, <FONT COLOR=#FF0000>"set _SID_ to ''"</FONT>
        <FONT COLOR=black><B>if</B></FONT> self.setting(<FONT COLOR=#FF0000>'IgnoreInvalidSession'</FONT>):
            <FONT COLOR=#1111CC># Delete the session ID cookie (and field since session IDs can also</FONT>
            <FONT COLOR=#1111CC># be encoded into fields) from the request, then handle the servlet</FONT>
            <FONT COLOR=#1111CC># as though there was no session</FONT>
            <FONT COLOR=black><B>try</B></FONT>:
                <FONT COLOR=black><B>del</B></FONT> transaction.request().cookies()[<FONT COLOR=#FF0000>'_SID_'</FONT>]
            <FONT COLOR=black><B>except</B></FONT> KeyError:
                <FONT COLOR=black><B>pass</B></FONT>
            <FONT COLOR=black><B>try</B></FONT>:
                transaction.request().delField(<FONT COLOR=#FF0000>'_SID_'</FONT>)
            <FONT COLOR=black><B>except</B></FONT> KeyError:
                <FONT COLOR=black><B>pass</B></FONT>
            transaction.request().setSessionExpired(1)
            <FONT COLOR=black><B>if</B></FONT> self.setting(<FONT COLOR=#FF0000>'UseAutomaticPathSessions'</FONT>):
                self.handleMissingPathSession(transaction)
            <FONT COLOR=black><B>else</B></FONT>:
                self.handleGoodURL(transaction)
        <FONT COLOR=black><B>else</B></FONT>:
            res.write(<FONT COLOR=#FF0000>'''&lt;html&gt; &lt;head&gt; &lt;title&gt;Session expired&lt;/title&gt; &lt;/head&gt;
                &lt;body&gt; &lt;h1&gt;Session Expired&lt;/h1&gt;
                &lt;p&gt; Your session has expired and all information related to your previous working session with this site has been cleared. &lt;p&gt; You may try this URL again by choosing Refresh/Reload, or revisit the front page.
                &lt;/body&gt;
                &lt;/html&gt;
                '''</FONT>)
            <FONT COLOR=#1111CC># @@ 2000-08-10 ce: This is a little cheesy. We could load a template...</FONT>

    <FONT COLOR=black><B>def</B></FONT> handleMissingPathSession(self,transaction):
        <FONT COLOR=#FF0000>"""
        if UseAutomaticPathSessions is enabled in Application.config
        we redirect the browser to a url with SID in path
        http://gandalf/a/_SID_=2001080221301877755/Examples/
        _SID_ is extracted and removed from path in HTTPRequest.py

        this is for convinient building of webapps that must not
        depend on cookie support
        """</FONT>
        newSid = transaction.session().identifier()
        request = transaction.request()
        url = request.adapterName() + <FONT COLOR=#FF0000>'/_SID_='</FONT>+ newSid + <FONT COLOR=#FF0000>'/'</FONT> + request.pathInfo() + (request.extraURLPath() <FONT COLOR=black><B>or</B></FONT> <FONT COLOR=#FF0000>''</FONT>)

        <FONT COLOR=black><B>if</B></FONT> request.queryString():
            url = url + <FONT COLOR=#FF0000>'?'</FONT> + request.queryString()
        <FONT COLOR=black><B>if</B></FONT> self.setting(<FONT COLOR=#FF0000>'Debug'</FONT>)[<FONT COLOR=#FF0000>'Sessions'</FONT>]:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"&gt;&gt; [sessions] handling UseAutomaticPathSessions, redirecting to"</FONT>, url
        transaction.response().sendRedirect(url)

    <FONT COLOR=black><B>def</B></FONT> handleGoodURL(self, transaction):
        self.createServletInTransaction(transaction)
        <FONT COLOR=black><B>try</B></FONT>:
            self.awake(transaction)
            <FONT COLOR=black><B>try</B></FONT>:
                self.respond(transaction)
            <FONT COLOR=black><B>except</B></FONT> EndResponse:
                <FONT COLOR=black><B>pass</B></FONT>
            self.sleep(transaction)
        <FONT COLOR=black><B>except</B></FONT> EndResponse:
            <FONT COLOR=black><B>pass</B></FONT>

    <FONT COLOR=black><B>def</B></FONT> processURLPath(self, req, URL):
        <FONT COLOR=#FF0000>"""
        Return a URL Path relative to the current request and context.
        Absolute references in the URL (starting with '/' are treated
        absolute to the current context.
        """</FONT>
        
        <FONT COLOR=#1111CC># Construct the url path for the servlet we're calling</FONT>
        urlPath = req.urlPath()
        <FONT COLOR=black><B>if</B></FONT> urlPath==<FONT COLOR=#FF0000>''</FONT>:
            urlPath = <FONT COLOR=#FF0000>'/'</FONT>
        <FONT COLOR=black><B>elif</B></FONT> urlPath[-1]==<FONT COLOR=#FF0000>'/'</FONT>:
            urlPath = urlPath
        <FONT COLOR=black><B>else</B></FONT>:
            lastSlash = string.rfind(urlPath, <FONT COLOR=#FF0000>'/'</FONT>)
            urlPath = urlPath[:lastSlash+1] 

        extraPath = <FONT COLOR=#FF0000>''</FONT>
        <FONT COLOR=black><B>if</B></FONT> URL[:1] == <FONT COLOR=#FF0000>"/"</FONT>:
            extraPath = req.siteRootFromCurrentServlet()

        urlPath = WebUtils.Funcs.normURL(urlPath + extraPath + URL)

        <FONT COLOR=black><B>if</B></FONT> debug:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"*processURLPath(%s)=%s"</FONT> % (URL, urlPath)

        <FONT COLOR=black><B>return</B></FONT> urlPath

    <FONT COLOR=black><B>def</B></FONT> forward(self, trans, URL):
        <FONT COLOR=#FF0000>"""
        Enable a servlet to pass a request to another servlet. The Request object is kept the same, and may be used
        to pass information to the next servlet.  The next servlet may access the parent servlet through request.parent(),
        which will return the parent servlet.  The first servlet will not be able to send any new response data once
        the call to forwardRequest returns.
        New Response and Transaction objects are created.
        Currently the URL is always relative to the existing URL.

        NOTE: @@ sgd 2003-01-15 - presently this goes through dispatchRequest() which
        under some circumstances can result in sending a redirect() which causes the
        browser to re-get the URL.  This defeats the purpose of passing information
        to a servlet in the request or transaction objects.  This only happens in
        cases like a forward to a directory where no trailing / was specified.
        """</FONT>

        <FONT COLOR=#1111CC># @@ sgd 2003-01-15</FONT>
        <FONT COLOR=#1111CC># to fix the above warning about using dispatchRequest() consider</FONT>
        <FONT COLOR=#1111CC># using the includeURL() code but handle the session and clearing</FONT>
        <FONT COLOR=#1111CC># the output stream here.</FONT>
        
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"&gt; forward(%s)"</FONT> % str(URL)

        req = trans.request()

        urlPath = self.processURLPath(req, URL)
        
        <FONT COLOR=#1111CC>#save the original URL</FONT>
        oldURL = req.urlPath()
        req.setURLPath(urlPath)

        <FONT COLOR=#1111CC>#add a reference to the parent servlet</FONT>
        req.addParent(req.transaction()._servlet)

        <FONT COLOR=#1111CC># Store the session so that the new servlet can access its values</FONT>
        <FONT COLOR=black><B>if</B></FONT> trans.hasSession():
            self._sessions.storeSession(trans.session())

        <FONT COLOR=#1111CC># We might have created a brand-new session prior to this call.  If so, we need</FONT>
        <FONT COLOR=#1111CC># to set the _SID_ identifier in the request so that the new transaction will</FONT>
        <FONT COLOR=#1111CC># know about the new session.</FONT>
        <FONT COLOR=#1111CC># gat 200-06-21: this feels like a hack, but it is necessary to prevent losing</FONT>
        <FONT COLOR=#1111CC># session information.</FONT>
        <FONT COLOR=black><B>if</B></FONT> trans.hasSession() <FONT COLOR=black><B>and</B></FONT> <FONT COLOR=black><B>not</B></FONT> req.hasValue(<FONT COLOR=#FF0000>'_SID_'</FONT>):
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'Application.forward(): propagating new session ID into request'</FONT>
            req.setField(<FONT COLOR=#FF0000>'_SID_'</FONT>, trans.session().identifier())

        <FONT COLOR=#1111CC>#get the output stream and set it in the new response</FONT>
        strmOut = req.transaction().response().streamOut()
        strmOut.clear()
        newTrans = self.dispatchRequest(req, strmOut)
        req.popParent()
        req.setURLPath(oldURL)

        <FONT COLOR=#1111CC>#give the old response a dummy streamout- nasty hack, better idea anyone?</FONT>
        trans.response()._strmOut = ASStreamOut()
        req._transaction = trans  <FONT COLOR=#1111CC>#this is needed by dispatchRequest</FONT>

        <FONT COLOR=#1111CC># Get rid of the session in the old transaction so it won't try to save it,</FONT>
        <FONT COLOR=#1111CC># thereby wiping out session changes made in the servlet we forwarded to</FONT>
        trans.setSession(None)


    <FONT COLOR=black><B>def</B></FONT> forwardRequest(self, trans, URL):
        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"forwardRequest is deprecated.  Use forward()"</FONT>
        <FONT COLOR=black><B>return</B></FONT> self.forward(trans, URL)
        
    <FONT COLOR=black><B>def</B></FONT> includeURL(self, trans, URL):
        <FONT COLOR=#FF0000>"""
        Enable a servlet to pass a request to another servlet.  This implementation
        handles chaining and requestDispatch in Java.

        The Request, Rssponse and Session objects are all kept the same, so the Servlet
        that is called may receive information through those objects.  The catch is that
        the function WILL return to the calling servlet, so the calling servlet should either
        take advantage of that or return immediately.
        Also, if the response has already been partially sent, it can't be reversed.
        """</FONT>

        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"&gt; includeURL(%s)"</FONT> % str(URL)

        req = trans.request()

        <FONT COLOR=#1111CC>#Save the things we're gonna change.</FONT>
        currentPath=req.urlPath()
        currentServlet=trans._servlet

        urlPath = self.processURLPath(req, URL)
        
        req.setURLPath(urlPath)
        req.addParent(currentServlet)

        <FONT COLOR=#1111CC>#Get the new servlet</FONT>
        self.createServletInTransaction(trans)

        <FONT COLOR=#1111CC>#call the servlet, but not session, it's already alive</FONT>
        <FONT COLOR=black><B>try</B></FONT>:
            trans.servlet().awake(trans)
            <FONT COLOR=black><B>try</B></FONT>:
                trans.servlet().respond(trans)
            <FONT COLOR=black><B>except</B></FONT> EndResponse:
                <FONT COLOR=black><B>pass</B></FONT>
            trans.servlet().sleep(trans)
        <FONT COLOR=black><B>except</B></FONT> EndResponse:
            <FONT COLOR=black><B>pass</B></FONT>

        self.returnInstance(trans,trans.request().serverSidePath())

        <FONT COLOR=#1111CC>#replace things like they were</FONT>
        <FONT COLOR=#1111CC>#trans.request()._serverSidePath=currentPath</FONT>
        req.setURLPath(currentPath)
        req.popParent()
        trans._servlet=currentServlet


    <FONT COLOR=black><B>def</B></FONT> forwardRequestFast(self, trans, url):
        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"forwardRequestFast is deprecated.  Use includeURL()"</FONT>
        <FONT COLOR=black><B>return</B></FONT> self.includeURL(trans, url)

    <FONT COLOR=black><B>def</B></FONT> callMethodOfServlet(self, trans, URL, method, *args, **kwargs):
        <FONT COLOR=#FF0000>"""
        Enable a servlet to call a method of another servlet.  Note: the servlet's awake() is called,
        then the method is called with the given arguments, then sleep() is called.  The result
        of the method call is returned.
        """</FONT>
        req = trans.request()

        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"&gt; callMethodOfServlet(%s, %s)"</FONT> % (URL, method)

        <FONT COLOR=#1111CC># Save the current url path and servlet</FONT>
        currentPath = req.urlPath()
        currentServlet = trans._servlet

        urlPath = self.processURLPath( req, URL )
        
        <FONT COLOR=#1111CC># Modify the request to use the new URL path</FONT>
        req.setURLPath(urlPath)

        <FONT COLOR=#1111CC># Add the current servlet as a parent</FONT>
        req.addParent(currentServlet)

        <FONT COLOR=#1111CC># Get the new servlet</FONT>
        self.createServletInTransaction(trans)

        <FONT COLOR=#1111CC># Awaken, call the method, and sleep</FONT>
        servlet = trans.servlet()

        <FONT COLOR=black><B>try</B></FONT>:
            servlet.awake(trans)
            <FONT COLOR=black><B>try</B></FONT>:
                result = getattr(servlet, method)(*args, **kwargs)
            <FONT COLOR=black><B>except</B></FONT> EndResponse:
                <FONT COLOR=black><B>pass</B></FONT>
            servlet.sleep(trans)
        <FONT COLOR=black><B>except</B></FONT> EndResponse:
            <FONT COLOR=black><B>pass</B></FONT>

        <FONT COLOR=#1111CC># Return the servlet instance to the cache</FONT>
        self.returnInstance(trans, trans.request().serverSidePath())

        <FONT COLOR=#1111CC># Replace things like they were</FONT>
        req.setURLPath(currentPath)
        req.popParent()
        trans._servlet=currentServlet

        <FONT COLOR=#1111CC># Done</FONT>
        <FONT COLOR=black><B>return</B></FONT> result
    
    <FONT COLOR=#1111CC>## Transactions ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> awake(self, transaction):
        transaction.awake()

    <FONT COLOR=black><B>def</B></FONT> respond(self, transaction):
        transaction.respond()

    <FONT COLOR=black><B>def</B></FONT> sleep(self, transaction):
        transaction.sleep()
        <FONT COLOR=#1111CC># Store the session</FONT>
        <FONT COLOR=black><B>if</B></FONT> transaction.hasSession():
            self._sessions.storeSession(transaction.session())


    <FONT COLOR=#1111CC>## Sessions ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> session(self, sessionId, default=NoDefault):
        <FONT COLOR=black><B>if</B></FONT> default <FONT COLOR=black><B>is</B></FONT> NoDefault:
            <FONT COLOR=black><B>return</B></FONT> self._sessions[sessionId]
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> self._sessions.get(sessionId, default)

    <FONT COLOR=black><B>def</B></FONT> hasSession(self, sessionId):
        <FONT COLOR=black><B>return</B></FONT> self._sessions.has_key(sessionId)

    <FONT COLOR=black><B>def</B></FONT> sessions(self):
        <FONT COLOR=black><B>return</B></FONT> self._sessions


    <FONT COLOR=#1111CC>## Misc Access ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> server(self):
        <FONT COLOR=black><B>return</B></FONT> self._server

    <FONT COLOR=black><B>def</B></FONT> serverSidePath(self, path=None):
        <FONT COLOR=#FF0000>""" Returns the absolute server-side path of the WebKit application. If the optional path is passed in, then it is joined with the server side directory to form a path relative to the app server.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> path:
            <FONT COLOR=black><B>return</B></FONT> os.path.normpath(os.path.join(self._serverSidePath, path))
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> self._serverSidePath

    <FONT COLOR=black><B>def</B></FONT> webwarePath(self):
        <FONT COLOR=black><B>return</B></FONT> self._server.webwarePath()

    <FONT COLOR=black><B>def</B></FONT> webKitPath(self):
        <FONT COLOR=black><B>return</B></FONT> self._server.webKitPath()


    <FONT COLOR=black><B>def</B></FONT> name(self):
        <FONT COLOR=black><B>return</B></FONT> sys.argv[0]

    <FONT COLOR=black><B>def</B></FONT> transactionClass(self):
        <FONT COLOR=black><B>return</B></FONT> self._transactionClass

    <FONT COLOR=black><B>def</B></FONT> setTransactionClass(self, newClass):
        <FONT COLOR=black><B>assert</B></FONT> isclass(newClass)
        self._transactionClass = newClass

    <FONT COLOR=black><B>def</B></FONT> responseClass(self, newClass):
        <FONT COLOR=black><B>return</B></FONT> self._responseClass

    <FONT COLOR=black><B>def</B></FONT> setResponseClass(self, newClass):
        <FONT COLOR=black><B>assert</B></FONT> isclass(newClass)
        self._responseClass = newClass


    <FONT COLOR=#1111CC>## Contexts ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> context(self, name, default=NoDefault):
        <FONT COLOR=#FF0000>""" Returns the value of the specified context. """</FONT>
        <FONT COLOR=black><B>if</B></FONT> default <FONT COLOR=black><B>is</B></FONT> NoDefault:
            <FONT COLOR=black><B>return</B></FONT> self._contexts[name]
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> self._contexts.get(name, default)

    <FONT COLOR=black><B>def</B></FONT> hasContext(self, name):
        <FONT COLOR=black><B>return</B></FONT> self._contexts.has_key(name)

    <FONT COLOR=black><B>def</B></FONT> _setContext(self, name, value):<FONT COLOR=#1111CC>#use addContext</FONT>
        <FONT COLOR=black><B>if</B></FONT> self._contexts.has_key(name):
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'WARNING: Overwriting context %s (=%s) with %s'</FONT> % (
                repr(name), repr(self._contexts[name]), repr(value))
        self._contexts[name] = value

    <FONT COLOR=black><B>def</B></FONT> contexts(self):
        <FONT COLOR=black><B>return</B></FONT> self._contexts

    <FONT COLOR=black><B>def</B></FONT> addContext(self, name, dir):
        <FONT COLOR=black><B>if</B></FONT> self._contexts.has_key(name):
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'WARNING: Overwriting context %s (=%s) with %s'</FONT> % (
                repr(name), repr(self._contexts[name]), repr(dir))
            __contextInitialized = 1 <FONT COLOR=#1111CC># Assume already initialized.</FONT>
        <FONT COLOR=black><B>else</B></FONT>:
            __contextInitialized = 0
            
        <FONT COLOR=black><B>try</B></FONT>:
            importAsName = name
            localdir, pkgname = os.path.split(dir)
            <FONT COLOR=black><B>if</B></FONT> sys.modules.has_key(importAsName):
                mod = sys.modules.get(importAsName)
            <FONT COLOR=black><B>else</B></FONT>:
                res = imp.find_module(pkgname, [localdir])
                mod = imp.load_module(name, res[0], res[1], res[2])
                __contextInitialized = 0  <FONT COLOR=#1111CC># overwriting context - re-initialize</FONT>
                
        <FONT COLOR=black><B>except</B></FONT> ImportError,e:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Error loading context: %s: %s: dir=%s"</FONT> % (name, e, dir)
            <FONT COLOR=black><B>return</B></FONT>

        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> __contextInitialized <FONT COLOR=black><B>and</B></FONT> mod.__dict__.has_key(<FONT COLOR=#FF0000>'contextInitialize'</FONT>):
            result = mod.__dict__[<FONT COLOR=#FF0000>'contextInitialize'</FONT>](self,
                                   os.path.normpath(os.path.join(os.getcwd(),dir)))
            <FONT COLOR=black><B>if</B></FONT> result != None <FONT COLOR=black><B>and</B></FONT> result.has_key(<FONT COLOR=#FF0000>'ContentLocation'</FONT>):
                dir = result[<FONT COLOR=#FF0000>'ContentLocation'</FONT>]
        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'Loading context: %s at %s'</FONT> % (name, dir)
        self._contexts[name] = dir


    <FONT COLOR=#1111CC>## Factory access ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> addServletFactory(self, factory):
        <FONT COLOR=black><B>assert</B></FONT> isinstance(factory, ServletFactory)
        self._factoryList.append(factory)
        <FONT COLOR=black><B>for</B></FONT> ext <FONT COLOR=black><B>in</B></FONT> factory.extensions():
            <FONT COLOR=black><B>assert</B></FONT> <FONT COLOR=black><B>not</B></FONT> self._factoryByExt.has_key(ext), <FONT COLOR=#FF0000>'Extension (%s) for factory (%s) was already used by factory (%s)'</FONT> % (ext, self._factoryByExt[ext].name(), factory.name())
            self._factoryByExt[ext] = factory

    <FONT COLOR=black><B>def</B></FONT> factories(self):
        <FONT COLOR=black><B>return</B></FONT> self._factoryList


    <FONT COLOR=#1111CC>## Activity Log ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> writeActivityLog(self, transaction):
        <FONT COLOR=#FF0000>"""
        Writes an entry to the script log file. Uses settings ActivityLogFilename and ActivityLogColumns.
        """</FONT>
        filename = self.serverSidePath(self.setting(<FONT COLOR=#FF0000>'ActivityLogFilename'</FONT>))
        <FONT COLOR=black><B>if</B></FONT> os.path.exists(filename):
            file = open(filename, <FONT COLOR=#FF0000>'a'</FONT>)
        <FONT COLOR=black><B>else</B></FONT>:
            file = open(filename, <FONT COLOR=#FF0000>'w'</FONT>)
            file.write(string.join(self.setting(<FONT COLOR=#FF0000>'ActivityLogColumns'</FONT>), <FONT COLOR=#FF0000>','</FONT>)+<FONT COLOR=#FF0000>'\n'</FONT>)
        values = []
        <FONT COLOR=#1111CC># We use UserDict on the next line because we know it inherits NamedValueAccess and reponds to valueForName()</FONT>
        objects = UserDict({
            <FONT COLOR=#FF0000>'application'</FONT>: self,
            <FONT COLOR=#FF0000>'transaction'</FONT>: transaction,
            <FONT COLOR=#FF0000>'request'</FONT>:   transaction.request(),
            <FONT COLOR=#FF0000>'response'</FONT>: transaction.response(),
            <FONT COLOR=#FF0000>'servlet'</FONT>:   transaction.servlet(),
            <FONT COLOR=#FF0000>'session'</FONT>:   transaction._session, <FONT COLOR=#1111CC>#don't cause creation of session</FONT>
        })
        <FONT COLOR=black><B>for</B></FONT> column <FONT COLOR=black><B>in</B></FONT> self.setting(<FONT COLOR=#FF0000>'ActivityLogColumns'</FONT>):
            <FONT COLOR=black><B>try</B></FONT>:
                value = objects.valueForName(column)
            <FONT COLOR=black><B>except</B></FONT>:
                value = <FONT COLOR=#FF0000>'(unknown)'</FONT>
            <FONT COLOR=black><B>if</B></FONT> type(value) <FONT COLOR=black><B>is</B></FONT> FloatType:
                value = <FONT COLOR=#FF0000>'%0.2f'</FONT> % value   <FONT COLOR=#1111CC># probably need more flexibility in the future</FONT>
            <FONT COLOR=black><B>else</B></FONT>:
                value = str(value)
            values.append(value)
        file.write(string.join(values, <FONT COLOR=#FF0000>','</FONT>)+<FONT COLOR=#FF0000>'\n'</FONT>)
        file.close()

        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> objects.keys():
            objects[i]=None


    <FONT COLOR=#1111CC>## Utilities/Hooks ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> createRequestForDict(self, newRequestDict):
        <FONT COLOR=black><B>return</B></FONT> self._requestClass(dict=newRequestDict)

    <FONT COLOR=black><B>def</B></FONT> createTransactionForRequest(self, request):
        trans = self._transactionClass(application=self, request=request)
        request.setTransaction(trans)
        <FONT COLOR=black><B>return</B></FONT> trans

    <FONT COLOR=black><B>def</B></FONT> createResponseInTransaction(self, transaction, strmOut):
        response = self._responseClass(transaction, strmOut)
        transaction.setResponse(response)
        <FONT COLOR=black><B>return</B></FONT> response

    <FONT COLOR=black><B>def</B></FONT> createSessionForTransaction(self, transaction):
        debug = self.setting(<FONT COLOR=#FF0000>'Debug'</FONT>)[<FONT COLOR=#FF0000>'Sessions'</FONT>]
        <FONT COLOR=black><B>if</B></FONT> debug: prefix = <FONT COLOR=#FF0000>'&gt;&gt; [session] createSessionForTransaction:'</FONT>
        sessId = transaction.request().sessionId()
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> prefix, <FONT COLOR=#FF0000>'sessId ='</FONT>, sessId
        <FONT COLOR=black><B>if</B></FONT> sessId:
            session = self.session(sessId)
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> prefix, <FONT COLOR=#FF0000>'retrieved session ='</FONT>, session
        <FONT COLOR=black><B>else</B></FONT>:
            session = self._sessionClass(transaction)
            self._sessions[session.identifier()] = session
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> prefix, <FONT COLOR=#FF0000>'created session ='</FONT>, session
        transaction.setSession(session)
        <FONT COLOR=black><B>return</B></FONT> session

    <FONT COLOR=black><B>def</B></FONT> getServlet(self, transaction, path, cache=None): <FONT COLOR=#1111CC>#send the cache if you want the cache info set</FONT>
        ext = os.path.splitext(path)[1]
        <FONT COLOR=#1111CC># Add the path to sys.path. @@ 2000-05-09 ce: not the most ideal solution, but works for now</FONT>
        dir = os.path.dirname(path)

        factory = self._factoryByExt.get(ext, None)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> factory:
            factory = self._factoryByExt.get(<FONT COLOR=#FF0000>'.*'</FONT>, None) <FONT COLOR=#1111CC># special case: .* is the catch-all</FONT>
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> factory:
                <FONT COLOR=black><B>raise</B></FONT> ApplicationError, <FONT COLOR=#FF0000>'Unknown extension (%s). No factory found.'</FONT> % ext
            <FONT COLOR=#1111CC># ^ @@ 2000-05-03 ce: Maybe the web browser doesn't want an exception for bad extensions. We probably need a nicer message to the user...</FONT>
            <FONT COLOR=#1111CC>#                    On the other hand, that can always be done by providing a factory for '.*'</FONT>
        <FONT COLOR=black><B>assert</B></FONT> factory.uniqueness()==<FONT COLOR=#FF0000>'file'</FONT>, <FONT COLOR=#FF0000>'%s uniqueness is not supported.'</FONT> % factory.uniqueness()

        <FONT COLOR=#1111CC># @@ 2001-05-10 gat: removed this because it allows 2 different copies of the same</FONT>
        <FONT COLOR=#1111CC># module to be imported, one as "foo" and one as "context.foo".</FONT>
        <FONT COLOR=#1111CC>#if </FONT>not dir <FONT COLOR=black><B>in</B></FONT> sys.path:
        <FONT COLOR=#1111CC>#   sys.path.insert(0, dir)</FONT>
        inst = factory.servletForTransaction(transaction)
        <FONT COLOR=black><B>assert</B></FONT> inst <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None, <FONT COLOR=#FF0000>'Factory (%s) failed to create a servlet upon request.'</FONT> % factory.name()

        <FONT COLOR=black><B>if</B></FONT> cache:
            cache[<FONT COLOR=#FF0000>'threadsafe'</FONT>]=inst.canBeThreaded()
            cache[<FONT COLOR=#FF0000>'reuseable'</FONT>]=inst.canBeReused()
        <FONT COLOR=black><B>return</B></FONT> inst

    <FONT COLOR=black><B>def</B></FONT> returnInstance(self, transaction, path):
        <FONT COLOR=#FF0000>""" The only case I care about now is threadsafe=0 and reuseable=1"""</FONT>
        cache = self._servletCacheByPath.get(path, None)
        <FONT COLOR=black><B>if</B></FONT> cache <FONT COLOR=black><B>and</B></FONT> cache[<FONT COLOR=#FF0000>'reuseable'</FONT>] <FONT COLOR=black><B>and</B></FONT> <FONT COLOR=black><B>not</B></FONT> cache[<FONT COLOR=#FF0000>'threadsafe'</FONT>]:
            srv = transaction.servlet()
            <FONT COLOR=black><B>if</B></FONT> srv:
                cache[<FONT COLOR=#FF0000>'instances'</FONT>].append(transaction.servlet())
                <FONT COLOR=black><B>return</B></FONT>

    <FONT COLOR=black><B>def</B></FONT> newServletCacheItem(self,key,item):
        <FONT COLOR=#FF0000>""" Safely add new item to the main cache.  Not worried about the retrieval for now.
        I'm not even sure this is necessary, as it's a one bytecode op, but it doesn't cost
        much of anything speed wise.
        """</FONT>
        <FONT COLOR=#1111CC>#self._cacheDictLock.acquire()</FONT>
        self._servletCacheByPath[key] = item
        <FONT COLOR=#1111CC>#self._cacheDictLock.release()</FONT>

    <FONT COLOR=black><B>def</B></FONT> flushServletCache(self):
        self._servletCacheByPath = {}

    <FONT COLOR=black><B>def</B></FONT> createServletInTransaction(self, transaction):
        <FONT COLOR=#1111CC># Get the path</FONT>
        path = transaction.request().serverSidePath()
        <FONT COLOR=black><B>assert</B></FONT> path <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None

        inst = None
        cache = None


        <FONT COLOR=#1111CC># Cached?</FONT>
        <FONT COLOR=black><B>if</B></FONT> self._cacheServletInstances:
            cache = self._servletCacheByPath.get(path, None)

        <FONT COLOR=#1111CC># File is not newer?</FONT>
        <FONT COLOR=black><B>if</B></FONT> cache <FONT COLOR=black><B>and</B></FONT> cache[<FONT COLOR=#FF0000>'timestamp'</FONT>]&lt;os.path.getmtime(path):
            cache[<FONT COLOR=#FF0000>'instances'</FONT>][:] = []
            cache = None

        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> cache:
            cache = {
                <FONT COLOR=#FF0000>'instances'</FONT>:  [],
                <FONT COLOR=#FF0000>'path'</FONT>:       path,
                <FONT COLOR=#FF0000>'timestamp'</FONT>:  os.path.getmtime(path),
                <FONT COLOR=#FF0000>'threadsafe'</FONT>: 0,
                <FONT COLOR=#FF0000>'reuseable'</FONT>:  0,
                }

            self.newServletCacheItem(path,cache)
            inst = self.getServlet(transaction,path,cache)

            <FONT COLOR=black><B>if</B></FONT> cache[<FONT COLOR=#FF0000>'threadsafe'</FONT>]:
                <FONT COLOR=#FF0000>"""special case, put in the cache now"""</FONT>
                cache[<FONT COLOR=#FF0000>'instances'</FONT>].append(inst)

        <FONT COLOR=#1111CC># Instance can be reused?</FONT>
        <FONT COLOR=black><B>elif</B></FONT> <FONT COLOR=black><B>not</B></FONT> cache[<FONT COLOR=#FF0000>'reuseable'</FONT>]:
            <FONT COLOR=#1111CC># One time servlet</FONT>
            inst = self.getServlet(transaction, path)

        <FONT COLOR=black><B>elif</B></FONT> <FONT COLOR=black><B>not</B></FONT> cache[<FONT COLOR=#FF0000>'threadsafe'</FONT>]:
            <FONT COLOR=#1111CC># Not threadsafe, so need multiple instances</FONT>
            <FONT COLOR=black><B>try</B></FONT>:
                inst = cache[<FONT COLOR=#FF0000>'instances'</FONT>].pop()
            <FONT COLOR=black><B>except</B></FONT> IndexError: <FONT COLOR=#1111CC># happens if list was empty</FONT>
                inst = self.getServlet(transaction, path)

        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=#1111CC># Must be reuseable and threadsafe - just use the instance in the cache</FONT>
            <FONT COLOR=#1111CC># without removing it</FONT>
            inst = cache[<FONT COLOR=#FF0000>'instances'</FONT>][0]

        <FONT COLOR=#1111CC># Set the transaction's servlet</FONT>
        transaction.setServlet(inst)

    <FONT COLOR=black><B>def</B></FONT> handleExceptionInTransaction(self, excInfo, transaction):
        <FONT COLOR=black><B>if</B></FONT> self._exceptionHandlerClass <FONT COLOR=black><B>is</B></FONT> None:
            self._exceptionHandlerClass = ExceptionHandler
        self._exceptionHandlerClass(self, transaction, excInfo)

    <FONT COLOR=black><B>def</B></FONT> handleException(self, excInfo=None):
        <FONT COLOR=#FF0000>"""Handle the exception by calling the configured ExceptinHandler.
        Note that the exception handler must be capable of taking
        a transaction of None for exceptions that occur outside of
        a transaction.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> excInfo <FONT COLOR=black><B>is</B></FONT> None:
            excInfo = sys.exc_info()
        <FONT COLOR=black><B>if</B></FONT> self._exceptionHandlerClass <FONT COLOR=black><B>is</B></FONT> None:
            self._exceptionHandlerClass = ExceptionHandler
        self._exceptionHandlerClass(self, None, excInfo)

    <FONT COLOR=black><B>def</B></FONT> filenamesForBaseName(self, baseName):

        <FONT COLOR=#FF0000>"""Returns a list of all filenames with extensions existing for
        baseName, but not including extension found in the setting
        ExtensionsToIgnore. This utility method is used by
        serverSideInfoForRequest().  Example: '/a/b/c' could yield
        ['/a/b/c.py', '/a/b/c.html'], but will never yield a
        '/a/b/c.pyc' filename since .pyc files are ignored."""</FONT>

        <FONT COLOR=black><B>if</B></FONT> string.find(baseName, <FONT COLOR=#FF0000>'*'</FONT>) &gt;= 0:
            <FONT COLOR=black><B>return</B></FONT> []
        filenames = []
        ignoreExts = self.setting(<FONT COLOR=#FF0000>'ExtensionsToIgnore'</FONT>)
        <FONT COLOR=black><B>for</B></FONT> filename <FONT COLOR=black><B>in</B></FONT> glob(baseName+<FONT COLOR=#FF0000>'.*'</FONT>):
            <FONT COLOR=#1111CC># consider this because CVS leaves files with extensions like '*.py.~1.2.3~'</FONT>
            <FONT COLOR=#1111CC># filename[-1:] == '~': continue</FONT>
            <FONT COLOR=black><B>if</B></FONT> os.path.splitext(filename)[1] <FONT COLOR=black><B>not</B></FONT> <FONT COLOR=black><B>in</B></FONT> ignoreExts:
                <FONT COLOR=#1111CC># @@ 2000-06-22 ce: linear search</FONT>
                filenames.append(filename)

        extensionsToServe = self.setting(<FONT COLOR=#FF0000>'ExtensionsToServe'</FONT>)
        <FONT COLOR=black><B>if</B></FONT> extensionsToServe:
            filteredFilenames = []
            <FONT COLOR=black><B>for</B></FONT> filename <FONT COLOR=black><B>in</B></FONT> filenames:
                <FONT COLOR=black><B>if</B></FONT> os.path.splitext(filename)[1] <FONT COLOR=black><B>in</B></FONT> extensionsToServe:
                    filteredFilenames.append(filename)
            filenames = filteredFilenames

        <FONT COLOR=black><B>if</B></FONT> debug:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; filenamesForBaseName(%s) returning %s'</FONT> % (
                repr(baseName), repr(filenames))
        <FONT COLOR=black><B>return</B></FONT> filenames

    <FONT COLOR=black><B>def</B></FONT> defaultContextNameAndPath(self):
        <FONT COLOR=#FF0000>"""
        Returns the default context name and path in a tuple.  If there's an explicitly named context with the same
        path as the "default" context, then we'll use that name instead.  Otherwise, we'll just
        use "default" as the name.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self._defaultContextName:
            defaultContextPath = self._contexts[<FONT COLOR=#FF0000>'default'</FONT>]
            <FONT COLOR=black><B>for</B></FONT> contextName, contextPath <FONT COLOR=black><B>in</B></FONT> self._contexts.items():
                <FONT COLOR=black><B>if</B></FONT> contextPath == defaultContextPath:
                    self._defaultContextName = contextName
                    <FONT COLOR=black><B>break</B></FONT>
            <FONT COLOR=black><B>else</B></FONT>:
                self._defaultContextName = <FONT COLOR=#FF0000>'default'</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._defaultContextName, self.context(self._defaultContextName)



    <FONT COLOR=black><B>def</B></FONT> serverSideInfoForRequest(self, request):
        <FONT COLOR=#FF0000>"""
        Returns a tuple (requestPath, contextPath, contextName) where requestPath is
        the server-side path of this request, contextPath is the
        server-side path of the context for this request, and contextName is the
        name of the context, which is not necessarily the same as the name
        of the directory that houses the context.
        This is a 'private' service method for use by HTTPRequest.
        Returns (None, None, None) if there is no corresponding server side path for the URL.

        This method supports:
            * Contexts
            * A default context
            * Auto discovery of directory vs. file
            * For directories, auto discovery of file, configured by DirectoryFile
            * For files, auto discovery of extension, configured by ExtensionsToIgnore
            * Rejection of files (not directories) that end in a slash (/)
            * "Extra path" URLs where the servlet is actually embedded in the path
              as opposed to being at the end of it. (ex: http://foo.com/servlet/extra/path).
              The ExtraPath information will be available through request.extraPathInfo().
              The Application.config file must have ExtraPathInfo set to 1 for this to be functional.

        IF YOU CHANGE THIS VERY IMPORTANT, SUBTLE METHOD, THEN PLEASE REVIEW
        AND COMPLETE http://localhost/WebKit.cgi/Testing/ BEFORE CHECKING IN
        OR SUBMITTING YOUR CHANGES.
        """</FONT>

        debug=0
        extraURLPath=<FONT COLOR=#FF0000>''</FONT>

        urlPath = request.urlPath()
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; urlPath ='</FONT>, repr(urlPath)

        <FONT COLOR=#1111CC>##if the requested file is in the filesystem outside of any context...</FONT>
        <FONT COLOR=black><B>if</B></FONT> request._absolutepath:
            <FONT COLOR=black><B>if</B></FONT> isdir(urlPath):
                urlPath = self.findDirectoryIndex(urlPath, debug)
            <FONT COLOR=black><B>return</B></FONT> urlPath, None, None  <FONT COLOR=#1111CC>#no contextpath, no contextname</FONT>

        <FONT COLOR=#1111CC># try the cache first</FONT>
        ssPath, contextPath, contextName = self._serverSideInfoCacheByPath.get(urlPath, (None, None, None))
        <FONT COLOR=black><B>if</B></FONT> ssPath <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None:
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; returning path from cache: %s'</FONT> % repr(ssPath)
            <FONT COLOR=black><B>return</B></FONT> ssPath, contextPath, contextName


        <FONT COLOR=#1111CC># case: no URL then use the default context</FONT>
        <FONT COLOR=black><B>if</B></FONT> urlPath==<FONT COLOR=#FF0000>''</FONT> <FONT COLOR=black><B>or</B></FONT> urlPath==<FONT COLOR=#FF0000>'/'</FONT>:
            contextName, ssPath = self.defaultContextNameAndPath()
            <FONT COLOR=black><B>if</B></FONT> debug:
                <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; no urlPath, so using default context %s at path: %s'</FONT> % (contextName, ssPath)
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=#1111CC># Check for and process context name:</FONT>
            <FONT COLOR=black><B>assert</B></FONT> urlPath[0]==<FONT COLOR=#FF0000>'/'</FONT>, <FONT COLOR=#FF0000>'urlPath=%s'</FONT> % repr(urlPath)
            <FONT COLOR=black><B>if</B></FONT> string.rfind(urlPath, <FONT COLOR=#FF0000>'/'</FONT>)&gt;0: <FONT COLOR=#1111CC># no / in url (other than the preceding /)</FONT>
                blank, contextName, restOfPath = string.split(urlPath, <FONT COLOR=#FF0000>'/'</FONT>, 2)
            <FONT COLOR=black><B>else</B></FONT>:
                contextName, restOfPath = urlPath[1:], <FONT COLOR=#FF0000>''</FONT>
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; contextName=%s, restOfPath=%s'</FONT> % (repr(contextName), repr(restOfPath))

            <FONT COLOR=#1111CC># Look for context</FONT>
            <FONT COLOR=black><B>try</B></FONT>:
                prepath = self._contexts[contextName]
            <FONT COLOR=black><B>except</B></FONT> KeyError:
                restOfPath = urlPath[1:]  <FONT COLOR=#1111CC># put the old path back, there's no context here</FONT>
                contextName, prepath = self.defaultContextNameAndPath()
                <FONT COLOR=black><B>if</B></FONT> debug:
                    <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; context not found so assuming default:'</FONT>
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; ContextName=%s, prepath=%s, restOfPath=%s'</FONT> % (contextName, repr(prepath), repr(restOfPath))
            <FONT COLOR=#1111CC>#ssPath = os.path.join(prepath, restOfPath)</FONT>
            <FONT COLOR=black><B>if</B></FONT> restOfPath != <FONT COLOR=#FF0000>''</FONT>:
                ssPath = prepath + os.sep + restOfPath
            <FONT COLOR=black><B>else</B></FONT>:
                ssPath = prepath
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"&gt;&gt; ssPath= %s"</FONT> % ssPath

        contextPath = self._contexts[contextName]

        lastChar = ssPath[-1]
        ssPath = os.path.normpath(ssPath)

        <FONT COLOR=#1111CC># 2000-07-06 ce: normpath() chops off a trailing / (or \)</FONT>
        <FONT COLOR=#1111CC># which is NOT what we want. This makes the test case</FONT>
        <FONT COLOR=#1111CC># http://localhost/WebKit.cgi/Welcome/ pass when it should</FONT>
        <FONT COLOR=#1111CC># fail. URLs that name files must not end in slashes because</FONT>
        <FONT COLOR=#1111CC># relative URLs in the resulting document will get appended</FONT>
        <FONT COLOR=#1111CC># to the URL, instead of replacing the last component.</FONT>
        <FONT COLOR=black><B>if</B></FONT> lastChar==<FONT COLOR=#FF0000>'\\'</FONT> <FONT COLOR=black><B>or</B></FONT> lastChar==<FONT COLOR=#FF0000>'/'</FONT>:
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"lastChar was %s"</FONT> % lastChar
            ssPath = ssPath + os.sep

        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; normalized ssPath ='</FONT>, repr(ssPath)


        <FONT COLOR=black><B>if</B></FONT> self.setting(<FONT COLOR=#FF0000>'ExtraPathInfo'</FONT>):  <FONT COLOR=#1111CC>#check for extraURLPath</FONT>
            ssPath, urlPath, extraURLPath = self.processExtraURLPath(ssPath, urlPath, debug)
            request.setURLPath(urlPath)
            request._extraURLPath = extraURLPath

            <FONT COLOR=#1111CC>##Finish extraURLPath checks</FONT>
            <FONT COLOR=#1111CC>##Check cache again</FONT>
            cachePath, cacheContextPath, cacheContextName = self._serverSideInfoCacheByPath.get(urlPath, (None, None, None))
            <FONT COLOR=black><B>if</B></FONT> cachePath <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None:
                <FONT COLOR=black><B>if</B></FONT> debug:
                    <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'checked cache for urlPath %s'</FONT> % urlPath
                    <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; returning path for %s from cache: %s'</FONT> % (repr(ssPath), repr(cachePath))
                <FONT COLOR=black><B>return</B></FONT> cachePath, cacheContextPath, cacheContextName


        <FONT COLOR=black><B>if</B></FONT> isdir(ssPath):
            <FONT COLOR=#1111CC># URLs that map to directories need to have a trailing slash.</FONT>
            <FONT COLOR=#1111CC># If they don't, then relative links in the web page will not be</FONT>
            <FONT COLOR=#1111CC># constructed correctly by the browser.</FONT>
            <FONT COLOR=#1111CC># So in the following if statement, we're bailing out for such URLs.</FONT>
            <FONT COLOR=#1111CC># dispatchRequest() will detect the situation and handle the redirect.</FONT>

            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"&gt;&gt; ssPath is a directory"</FONT>
            <FONT COLOR=black><B>if</B></FONT> extraURLPath == <FONT COLOR=#FF0000>''</FONT> <FONT COLOR=black><B>and</B></FONT> (urlPath==<FONT COLOR=#FF0000>''</FONT> <FONT COLOR=black><B>or</B></FONT> urlPath[-1]!=<FONT COLOR=#FF0000>'/'</FONT>):
                <FONT COLOR=black><B>if</B></FONT> debug:
                    <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; BAILING on directory url: %s'</FONT> % repr(urlPath)
                <FONT COLOR=black><B>return</B></FONT> ssPath, contextPath, contextName


            ssPath = self.findDirectoryIndex(ssPath, debug)

        <FONT COLOR=black><B>elif</B></FONT> os.path.splitext(ssPath)[1]==<FONT COLOR=#FF0000>''</FONT>:
            <FONT COLOR=#1111CC># At this point we have a file (or a bad path)</FONT>
            filenames = self.filenamesForBaseName(ssPath)
            <FONT COLOR=black><B>if</B></FONT> len(filenames)==1:
                ssPath = filenames[0]
                <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; discovered extension, file = %s'</FONT> % repr(ssPath)
            <FONT COLOR=black><B>elif</B></FONT> len(filenames) &gt; 1:
                foundMatch = 0
                <FONT COLOR=black><B>if</B></FONT> self.setting(<FONT COLOR=#FF0000>'UseCascadingExtensions'</FONT>):
                    <FONT COLOR=black><B>for</B></FONT> ext <FONT COLOR=black><B>in</B></FONT> self.setting(<FONT COLOR=#FF0000>'ExtensionCascadeOrder'</FONT>):
                        <FONT COLOR=black><B>if</B></FONT> (ssPath + ext) <FONT COLOR=black><B>in</B></FONT> filenames:
                            ssPath = ssPath + ext
                            foundMatch = 1
                            <FONT COLOR=black><B>break</B></FONT>
                <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> foundMatch:
                    <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'WARNING: For %s, did not get precisely 1 filename: %s'</FONT> %\
                          (urlPath, filenames)
                    <FONT COLOR=black><B>return</B></FONT> None, None, None
            <FONT COLOR=black><B>else</B></FONT>:
                <FONT COLOR=black><B>return</B></FONT> None, None, None

        <FONT COLOR=black><B>elif</B></FONT> <FONT COLOR=black><B>not</B></FONT> os.path.isfile(ssPath):
            <FONT COLOR=black><B>return</B></FONT> None, None, None

        self._serverSideInfoCacheByPath[urlPath] = ssPath, contextPath, contextName

        <FONT COLOR=black><B>if</B></FONT> debug:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; returning %s, %s, %s\n'</FONT> % (repr(ssPath), repr(contextPath), repr(contextName))
        <FONT COLOR=black><B>return</B></FONT> ssPath, contextPath, contextName


    <FONT COLOR=black><B>def</B></FONT> findDirectoryIndex(self, ssPath, debug=0):
        <FONT COLOR=#FF0000>"""
        Given a url that points to a directory, find an index file in that directory.
        """</FONT>
        <FONT COLOR=#1111CC># URLs that map to directories need to have a trailing slash.</FONT>
        <FONT COLOR=#1111CC># If they don't, then relative links in the web page will not be</FONT>
        <FONT COLOR=#1111CC># constructed correctly by the browser.</FONT>
        <FONT COLOR=#1111CC># So in the following if statement, we're bailing out for such URLs.</FONT>
        <FONT COLOR=#1111CC># dispatchRequest() will detect the situation and handle the redirect.</FONT>

        <FONT COLOR=#1111CC># Handle directories</FONT>
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; directory = %s'</FONT> % repr(ssPath)
        <FONT COLOR=black><B>for</B></FONT> dirFilename <FONT COLOR=black><B>in</B></FONT> self.setting(<FONT COLOR=#FF0000>'DirectoryFile'</FONT>):
            filenames = self.filenamesForBaseName(os.path.join(ssPath, dirFilename))
            num = len(filenames)
            <FONT COLOR=black><B>if</B></FONT> num==1:
                <FONT COLOR=black><B>break</B></FONT>  <FONT COLOR=#1111CC># we found a file to handle the directory</FONT>
            <FONT COLOR=black><B>elif</B></FONT> num&gt;1:
                <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'WARNING: the directory is %s which contains more than 1 directory file: %s'</FONT> % (ssPath, filenames)
                <FONT COLOR=black><B>return</B></FONT> None
        <FONT COLOR=black><B>if</B></FONT> num==0:
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'WARNING: For %s, the directory contains no directory file.'</FONT> % (ssPath)
            <FONT COLOR=black><B>return</B></FONT> None
        ssPath = filenames[0] <FONT COLOR=#1111CC># our path now includes the filename within the directory</FONT>
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; discovered directory file = %s'</FONT> % repr(ssPath)
        <FONT COLOR=black><B>return</B></FONT> ssPath


    <FONT COLOR=black><B>def</B></FONT> processExtraURLPath(self, ssPath, urlPath, debug=0):
        <FONT COLOR=#FF0000>"""
        given a server side path (ssPath) and the original request URL (urlPath), determine which portion of the URL is a request path and which portion is extra request information.
        Return a tuple of:
        ssPath: the corrected (truncted) ssPath,
        urlPath:  the corrected (trunctated) urlPath,
        extraPathInfo: the extra path info
        """</FONT>
        extraURLPath = <FONT COLOR=#FF0000>''</FONT>

        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"*** processExtraURLPath starting for ssPath="</FONT>, ssPath
        <FONT COLOR=black><B>if</B></FONT> os.path.exists(ssPath):  <FONT COLOR=#1111CC>##bail now if the whole thing exists</FONT>
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"*** entire ssPath exists"</FONT>
            <FONT COLOR=black><B>return</B></FONT> ssPath, urlPath, <FONT COLOR=#FF0000>''</FONT>

        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"starting ssPath=%s, urlPath=%s "</FONT> % (ssPath, urlPath)
        goodindex = 0  <FONT COLOR=#1111CC>#this marks the last point where the path exists</FONT>

        index = string.find(ssPath, os.sep)
        <FONT COLOR=black><B>if</B></FONT> index == -1: <FONT COLOR=black><B>return</B></FONT> ssPath, urlPath, extraURLInfo  <FONT COLOR=#1111CC>##bail if no seps found</FONT>
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> index: index=1  <FONT COLOR=#1111CC>#start with at least one character</FONT>

        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"testing "</FONT>, ssPath[:index]

        <FONT COLOR=black><B>while</B></FONT> os.path.exists(ssPath[:index]) <FONT COLOR=black><B>and</B></FONT> index != -1:
            goodindex = index
            index = string.find(ssPath, os.sep, index+1)
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"testing "</FONT>, ssPath[:index]
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"quitting loop with goodindex= "</FONT>,ssPath[:goodindex]

        <FONT COLOR=black><B>if</B></FONT> index != -1: <FONT COLOR=#1111CC>##there is another slash, but we already know its invalid</FONT>
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"last loop got an index of -1"</FONT>
            searchpath = ssPath[:index]
        <FONT COLOR=black><B>else</B></FONT>:    <FONT COLOR=#1111CC>#no more slashes, so the last element is either a file without an extension, or the real URL is a directory and the last piece is extraURLInfo</FONT>
            searchpath = ssPath


        <FONT COLOR=#1111CC>## Now test to see if the next element is a file without an extension</FONT>
        filenames = self.filenamesForBaseName(searchpath)
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"found %s valid files"</FONT> % len(filenames)
        <FONT COLOR=black><B>if</B></FONT> len(filenames)&gt;0:
            extralen=0

        <FONT COLOR=black><B>else</B></FONT>:
            extralen = len(ssPath) - goodindex
            <FONT COLOR=black><B>if</B></FONT> isdir(ssPath[:goodindex]):
                extralen = extralen-1  <FONT COLOR=#1111CC>##leave the last slash on the path</FONT>



        <FONT COLOR=black><B>if</B></FONT> extralen &gt; 0:
            urlPath, extraURLPath = urlPath[:-extralen] , urlPath[-extralen:]
            ssPath = ssPath[:-extralen]

        <FONT COLOR=black><B>if</B></FONT> extraURLPath <FONT COLOR=black><B>and</B></FONT> extraURLPath[0] != <FONT COLOR=#FF0000>'/'</FONT>:
            extraURLPath = <FONT COLOR=#FF0000>'/'</FONT> + extraURLPath
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"processExtraURLPath returning %s, %s, %s"</FONT> % ( ssPath, urlPath, extraURLPath )
        <FONT COLOR=black><B>return</B></FONT> ssPath, urlPath, extraURLPath

    <FONT COLOR=black><B>def</B></FONT> writeExceptionReport(self, handler):
        <FONT COLOR=#1111CC># Nothing particularly useful that I can think of needs to be</FONT>
        <FONT COLOR=#1111CC># added to the exception reports by the Application.</FONT>
        <FONT COLOR=#1111CC># See ExceptionHandler.py for more info.</FONT>
        <FONT COLOR=black><B>pass</B></FONT>


    <FONT COLOR=#1111CC>## New Path Algorithm ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> serverSideInfoForRequestNewAlgorithm(self, request):
        <FONT COLOR=#FF0000>"""
        Returns a tuple (requestPath, contextPath,
        contextName) where requestPath is the server-side path
        of this request, contextPath is the server-side path
        of the context for this request, and contextName is
        the name of the context, which is not necessarily the
        same as the name of the directory that houses the
        context.
        
        Returns (None, None, None) if there is no
        corresponding server side path for the URL.
        """</FONT>

        fullPath = request.urlPath()
        contextPath, contextName, rest = self.findContext(fullPath)
        servletPath, extraPath = self.findServlet(contextPath, rest)
        request._extraURLPath = extraPath
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"&gt; ssifr na:"</FONT>,(servletPath, contextPath, contextName, extraPath, request.urlPath())
        <FONT COLOR=black><B>return</B></FONT> (servletPath, contextPath, contextName)


    <FONT COLOR=black><B>def</B></FONT> findContext(self, fullPath):
        <FONT COLOR=#FF0000>"""
        Internal method: returns (contextPath, contextName, restOfPath)
        restOfPath will start with a /
        """</FONT>

        <FONT COLOR=black><B>assert</B></FONT> <FONT COLOR=black><B>not</B></FONT> fullPath <FONT COLOR=black><B>or</B></FONT> fullPath[0] == <FONT COLOR=#FF0000>'/'</FONT>
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> fullPath <FONT COLOR=black><B>or</B></FONT> fullPath == <FONT COLOR=#FF0000>'/'</FONT>:
            contextName, contextPath = self.defaultContextNameAndPath()
            <FONT COLOR=black><B>return</B></FONT> (contextPath, contextName, fullPath)
        pathParts = string.split(fullPath, <FONT COLOR=#FF0000>'/'</FONT>, 2)
        <FONT COLOR=black><B>if</B></FONT> len(pathParts) == 3:
            blank, first, rest = pathParts
        <FONT COLOR=black><B>elif</B></FONT> len(pathParts) == 2:
            first, rest = pathParts[1], <FONT COLOR=#FF0000>''</FONT>
        <FONT COLOR=black><B>else</B></FONT>:
            first, rest = <FONT COLOR=#FF0000>''</FONT>, <FONT COLOR=#FF0000>''</FONT>
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self._contexts.has_key(first):
            contextName, contextPath = self.defaultContextNameAndPath()
            <FONT COLOR=black><B>return</B></FONT> (contextPath, contextName, fullPath)
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> (self._contexts[first], first, <FONT COLOR=#FF0000>'/'</FONT> + rest)

    <FONT COLOR=black><B>def</B></FONT> findServlet(self, contextPath, urlPath):
        <FONT COLOR=#FF0000>"""
        Internal method: returns (servletPath, extraURLPath)
        extraURLPath will start with '/' (unless no extraURLPath
        was given, in which case extraURLPath will be '')
        """</FONT>
        cache = self._serverSideInfoCacheByPathNew
        <FONT COLOR=black><B>if</B></FONT> cache.has_key(urlPath):
            <FONT COLOR=black><B>return</B></FONT> (cache[urlPath], <FONT COLOR=#FF0000>''</FONT>)
        parts = string.split(urlPath, <FONT COLOR=#FF0000>'/'</FONT>)
        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> range(len(parts)):
            url = string.join(parts[:-i], <FONT COLOR=#FF0000>'/'</FONT>)
            <FONT COLOR=black><B>if</B></FONT> cache.has_key(url):
                <FONT COLOR=black><B>return</B></FONT> cache[url], <FONT COLOR=#FF0000>'/'</FONT> + string.join(parts[-i:], <FONT COLOR=#FF0000>'/'</FONT>)
        currentPath = contextPath
        <FONT COLOR=black><B>while</B></FONT> 1:
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> parts:
                filename = self.findDirectoryIndex(currentPath)
                <FONT COLOR=black><B>if</B></FONT> filename:
                    <FONT COLOR=black><B>return</B></FONT> (filename, <FONT COLOR=#FF0000>''</FONT>)
                <FONT COLOR=black><B>else</B></FONT>:
                    <FONT COLOR=black><B>return</B></FONT> None, None <FONT COLOR=#1111CC># 404 Not Found</FONT>
            first = parts[0]
            <FONT COLOR=black><B>if</B></FONT> os.path.isdir(os.path.join(currentPath, first)):
                currentPath = os.path.join(currentPath, first)
                parts = parts[1:]
                <FONT COLOR=black><B>continue</B></FONT>
            filenames = self.filenamesForBaseNameNew(os.path.join(currentPath, first))
            <FONT COLOR=black><B>if</B></FONT> filenames:
                <FONT COLOR=black><B>if</B></FONT> len(filenames) == 1:
                    <FONT COLOR=black><B>return</B></FONT> (filenames[0], 
                        <FONT COLOR=#FF0000>'/'</FONT> + string.join(parts[1:], <FONT COLOR=#FF0000>'/'</FONT>))
                <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"WARNING: More than one file matches basename %s (%s)"</FONT> % (repr(os.path.join(currentPath, first)), filenames)
                <FONT COLOR=black><B>return</B></FONT> None, None
            <FONT COLOR=black><B>else</B></FONT>:
                filename = self.findDirectoryIndex(currentPath)
                <FONT COLOR=black><B>if</B></FONT> filename:
                    <FONT COLOR=black><B>return</B></FONT> (filename, <FONT COLOR=#FF0000>'/'</FONT> + string.join(parts, <FONT COLOR=#FF0000>'/'</FONT>))

                <FONT COLOR=black><B>return</B></FONT> None, None

    <FONT COLOR=black><B>def</B></FONT> filenamesForBaseNameNew(self, baseName):
        <FONT COLOR=black><B>if</B></FONT> string.find(baseName, <FONT COLOR=#FF0000>'*'</FONT>) != -1:
            <FONT COLOR=black><B>return</B></FONT> []
        filenames = glob(baseName + <FONT COLOR=#FF0000>"*"</FONT>)
        good = []
        toIgnore = self.setting(<FONT COLOR=#FF0000>'ExtensionsToIgnore'</FONT>)
        toServe = self.setting(<FONT COLOR=#FF0000>'ExtensionsToServe'</FONT>)
        <FONT COLOR=black><B>for</B></FONT> filename <FONT COLOR=black><B>in</B></FONT> filenames:
            ext = os.path.splitext(filename)[1]
            shortFilename = os.path.basename(filename)
            <FONT COLOR=black><B>if</B></FONT> ext <FONT COLOR=black><B>in</B></FONT> toIgnore <FONT COLOR=black><B>and</B></FONT> filename != baseName:
                <FONT COLOR=black><B>continue</B></FONT>
            <FONT COLOR=black><B>if</B></FONT> toServe <FONT COLOR=black><B>and</B></FONT> ext <FONT COLOR=black><B>not</B></FONT> <FONT COLOR=black><B>in</B></FONT> toServe:
                <FONT COLOR=black><B>continue</B></FONT>
            <FONT COLOR=black><B>for</B></FONT> regex <FONT COLOR=black><B>in</B></FONT> self._filesToHideRegexes:
                <FONT COLOR=black><B>if</B></FONT> regex.match(shortFilename):
                    <FONT COLOR=black><B>continue</B></FONT>
            <FONT COLOR=black><B>if</B></FONT> self._filesToServeRegexes:
                shouldServe = 0
                <FONT COLOR=black><B>for</B></FONT> regex <FONT COLOR=black><B>in</B></FONT> self._filesToServeRegexes:
                    <FONT COLOR=black><B>if</B></FONT> regex.match(shortFilename):
                        shouldServe = 1
                        <FONT COLOR=black><B>break</B></FONT>
                <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> shouldServe:
                    <FONT COLOR=black><B>continue</B></FONT>
            good.append(filename)
        <FONT COLOR=black><B>if</B></FONT> len(good) &gt; 1 <FONT COLOR=black><B>and</B></FONT> self.setting(<FONT COLOR=#FF0000>'UseCascadingExtensions'</FONT>):
            <FONT COLOR=black><B>for</B></FONT> extension <FONT COLOR=black><B>in</B></FONT> self.setting(<FONT COLOR=#FF0000>'ExtensionCascadeOrder'</FONT>):
                actualExtension = os.path.splitext(baseName)[1]
                <FONT COLOR=black><B>if</B></FONT> baseName + extension <FONT COLOR=black><B>in</B></FONT> good \
                   <FONT COLOR=black><B>or</B></FONT> extension == actualExtension:
                    <FONT COLOR=black><B>return</B></FONT> [baseName + extension]
        <FONT COLOR=black><B>return</B></FONT> good



    <FONT COLOR=#1111CC>## Deprecated ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> serverSidePathForRequest(self, request, debug=0):
        <FONT COLOR=#FF0000>"""
        This is maintained for backward compatibility; it just returns the first part of the tuple
        returned by serverSideInfoForRequest.
        """</FONT>
        self.deprecated(self.serverSidePathForRequest)
        <FONT COLOR=black><B>return</B></FONT> self.serverSideInfoForRequest(request, debug)[0]

    <FONT COLOR=black><B>def</B></FONT> serverDir(self):
        <FONT COLOR=#FF0000>"""
        deprecated: Application.serverDir() on 1/24 in ver 0.5, use serverSidePath() instead @
        Returns the directory where the application server is located.
        """</FONT>
        self.deprecated(self.serverDir)
        <FONT COLOR=black><B>return</B></FONT> self.serverSidePath()




<FONT COLOR=black><B>def</B></FONT> isdir(s):
    <FONT COLOR=#FF0000>"""
    *** Be sure to use this isdir() function rather than os.path.isdir()
        in this file.

    2000-07-06 ce: Only on Windows, does an isdir() call with a
    path ending in a slash fail to return 1. e.g.,
    isdir('C:\\tmp\\')==0 while on UNIX isdir('/tmp/')==1.
    """</FONT>
    <FONT COLOR=black><B>if</B></FONT> s <FONT COLOR=black><B>and</B></FONT> os.name==<FONT COLOR=#FF0000>'nt'</FONT> <FONT COLOR=black><B>and</B></FONT> s[-1]==os.sep:
        <FONT COLOR=black><B>return</B></FONT> os.path.isdir(s[:-1])
    <FONT COLOR=black><B>else</B></FONT>:
        <FONT COLOR=black><B>return</B></FONT> os.path.isdir(s)

<FONT COLOR=black><B>def</B></FONT> noslash(s):
    <FONT COLOR=#FF0000>""" Return 1 if s is blank or does end in /.  A little utility for dispatchRequest(). """</FONT>
    <FONT COLOR=black><B>return</B></FONT> s==<FONT COLOR=#FF0000>''</FONT> <FONT COLOR=black><B>or</B></FONT> s[-1]!=<FONT COLOR=#FF0000>'/'</FONT>


<FONT COLOR=black><B>def</B></FONT> main(requestDict):
    <FONT COLOR=#FF0000>"""
    Returns a raw reponse. This method is mostly used by OneShotAdapter.py.
    """</FONT>
    <FONT COLOR=black><B>from</B></FONT> WebUtils.HTMLForException <FONT COLOR=black><B>import</B></FONT> HTMLForException
    <FONT COLOR=black><B>try</B></FONT>:
        <FONT COLOR=black><B>assert</B></FONT> type(requestDict) <FONT COLOR=black><B>is</B></FONT> type({})
        app = Application(useSessionSweeper=0)
        <FONT COLOR=black><B>return</B></FONT> app.dispatchRawRequest(requestDict).response().rawResponse()
    <FONT COLOR=black><B>except</B></FONT>:
        <FONT COLOR=black><B>return</B></FONT> {
            <FONT COLOR=#FF0000>'headers'</FONT>: [(<FONT COLOR=#FF0000>'Content-type'</FONT>, <FONT COLOR=#FF0000>'text/html'</FONT>)],
            <FONT COLOR=#FF0000>'contents'</FONT>: <FONT COLOR=#FF0000>'&lt;html&gt;&lt;body&gt;%s&lt;/html&gt;&lt;/body&gt;'</FONT> % HTMLForException()
        }


<FONT COLOR=#1111CC># You can run Application as a main script, in which case it expects a single</FONT>
<FONT COLOR=#1111CC># argument which is a file containing a dictionary representing a request. This</FONT>
<FONT COLOR=#1111CC># technique isn't very popular as Application itself could raise exceptions</FONT>
<FONT COLOR=#1111CC># that aren't caught. See CGIAdapter.py and AppServer.py for a better example of</FONT>
<FONT COLOR=#1111CC># how things should be done.</FONT>
<FONT COLOR=black><B>if</B></FONT> __name__==<FONT COLOR=#FF0000>'__main__'</FONT>:
    <FONT COLOR=black><B>if</B></FONT> len(sys.argv)!=2:
        sys.stderr.write(<FONT COLOR=#FF0000>'WebKit: Application: Expecting one filename argument.\n'</FONT>)
    requestDict = eval(open(sys.argv[1]).read())
    main(requestDict)
</PRE>
                  <!--footer-->
                  </BODY>
