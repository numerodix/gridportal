<HTML><HEAD><TITLE>WebKit/ThreadedAppServer.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=#1111CC>#!/usr/bin/env python</FONT>
<FONT COLOR=#FF0000>"""
AppServer

The WebKit app server is a TCP/IP server that accepts requests, hands them
off to the Application and sends the request back over the connection.

The fact that the app server stays resident is what makes it so much quicker
than traditional CGI programming. Everything gets cached.


FUTURE

    * Implement the additional settings that are commented out below.
"""</FONT>


<FONT COLOR=black><B>from</B></FONT> Common <FONT COLOR=black><B>import</B></FONT> *
<FONT COLOR=black><B>from</B></FONT> AutoReloadingAppServer <FONT COLOR=black><B>import</B></FONT> AutoReloadingAppServer as AppServer
<FONT COLOR=black><B>from</B></FONT> MiscUtils.Funcs <FONT COLOR=black><B>import</B></FONT> timestamp
<FONT COLOR=black><B>from</B></FONT> marshal <FONT COLOR=black><B>import</B></FONT> dumps, loads
<FONT COLOR=black><B>import</B></FONT> os, sys
<FONT COLOR=black><B>from</B></FONT> threading <FONT COLOR=black><B>import</B></FONT> Lock, Thread, Event
<FONT COLOR=black><B>import</B></FONT> threading
<FONT COLOR=black><B>import</B></FONT> Queue
<FONT COLOR=black><B>import</B></FONT> select
<FONT COLOR=black><B>import</B></FONT> socket
<FONT COLOR=black><B>import</B></FONT> threading
<FONT COLOR=black><B>import</B></FONT> time
<FONT COLOR=black><B>import</B></FONT> errno
<FONT COLOR=black><B>import</B></FONT> traceback
<FONT COLOR=black><B>from</B></FONT> WebUtils <FONT COLOR=black><B>import</B></FONT> Funcs

debug = 0

DefaultConfig = {
    <FONT COLOR=#FF0000>'Port'</FONT>:                 8086,
    <FONT COLOR=#FF0000>'MaxServerThreads'</FONT>:        20,
    <FONT COLOR=#FF0000>'MinServerThreads'</FONT>:        5,
    <FONT COLOR=#FF0000>'StartServerThreads'</FONT>:      10,

    <FONT COLOR=#1111CC># @@ 2000-04-27 ce: None of the following settings are implemented</FONT>
<FONT COLOR=#1111CC>#   'RequestQueueSize':     16,#    'RequestBufferSize':    64*1024,</FONT>
<FONT COLOR=#1111CC>#   'SocketType':           'inet',      # inet, unix</FONT>
}



<FONT COLOR=#1111CC>#Below used with the RestartApplication function</FONT>
<FONT COLOR=#1111CC>#ReStartLock=Lock()</FONT>
<FONT COLOR=#1111CC>#ReqCount=0</FONT>

<FONT COLOR=#1111CC>#Need to know this value for communications</FONT>
<FONT COLOR=#1111CC>#Note that this limits the size of the dictionary we receive from the AppServer to 2,147,483,647 bytes</FONT>
int_length = len(dumps(int(1)))

server = None

<FONT COLOR=black><B>class</B></FONT> ThreadedAppServer(AppServer):
    <FONT COLOR=#FF0000>"""
    """</FONT>

    <FONT COLOR=#1111CC>## Init ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, path=None):
        AppServer.__init__(self, path)
        self._addr = None
        threadCount = self.setting(<FONT COLOR=#FF0000>'StartServerThreads'</FONT>)
        self.maxServerThreads = self.setting(<FONT COLOR=#FF0000>'MaxServerThreads'</FONT>)
        self.minServerThreads = self.setting(<FONT COLOR=#FF0000>'MinServerThreads'</FONT>)
        self.monitorPort = None
        self.threadPool = []
        self.threadCount=0
        self.threadUseCounter=[]
        self.requestQueue = Queue.Queue(self.maxServerThreads * 2) <FONT COLOR=#1111CC># twice the number of threads we have</FONT>
        self.rhCache = [] <FONT COLOR=#1111CC># This will grow to a limit of the number of</FONT>
                          <FONT COLOR=#1111CC># threads plus the size of the requestQueue plus one.</FONT>
                          <FONT COLOR=#1111CC># It used to be a Queue but since we don't make</FONT>
                          <FONT COLOR=#1111CC># use of the blocking behavior and because of problems</FONT>
                          <FONT COLOR=#1111CC># with Queue.Empty being raised on .get_nowait()</FONT>
                          <FONT COLOR=#1111CC># when the queue isn't in fact empty, we have switched</FONT>
                          <FONT COLOR=#1111CC># to using a list instead.</FONT>

        self.mainsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        <FONT COLOR=#1111CC># Must use SO_REUSEADDR to avoid problems restarting the app server</FONT>
        <FONT COLOR=#1111CC># This was discussed on Webware-devel in Oct 2001, and this solution</FONT>
        <FONT COLOR=#1111CC># was found by Jeff Johnson</FONT>
        self.mainsocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        addr = self.address()
        <FONT COLOR=black><B>try</B></FONT>:
            self.mainsocket.bind(addr)
        <FONT COLOR=black><B>except</B></FONT>:
            <FONT COLOR=black><B>if</B></FONT> self.running:
                self.initiateShutdown()
            self._closeThread.join()
            <FONT COLOR=black><B>raise</B></FONT>
        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Listening on"</FONT>, addr
        open(self.serverSidePath(<FONT COLOR=#FF0000>'address.text'</FONT>), <FONT COLOR=#FF0000>'w'</FONT>).write(<FONT COLOR=#FF0000>'%s:%d'</FONT> % (addr[0], addr[1]))
        self.monitorPort = addr[1]-1

        out = sys.stdout

        out.write(<FONT COLOR=#FF0000>'Creating %d threads'</FONT> % threadCount)
        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> range(threadCount):
            self.spawnThread()
            out.write(<FONT COLOR=#FF0000>"."</FONT>)
            out.flush()
        out.write(<FONT COLOR=#FF0000>"\n"</FONT>)

        <FONT COLOR=#1111CC># @@ 2001-05-30 ce: another hard coded number:  @@jsl- not everything needs to be configurable....</FONT>
        self.mainsocket.listen(1024)
        self.recordPID()

        self.readyForRequests()

    <FONT COLOR=black><B>def</B></FONT> isPersistent(self):
        <FONT COLOR=black><B>return</B></FONT> 1

    <FONT COLOR=black><B>def</B></FONT> mainloop(self, monitor=None, timeout=1):
        <FONT COLOR=black><B>from</B></FONT> errno <FONT COLOR=black><B>import</B></FONT> EINTR

        inputsockets = [self.mainsocket,]
        <FONT COLOR=black><B>if</B></FONT> monitor:
            inputsockets.append(monitor.insock)

        threadCheckInterval = self.maxServerThreads*2
        threadUpdateDivisor = 5 <FONT COLOR=#1111CC>#grabstat interval</FONT>
        threadCheck=0

        <FONT COLOR=black><B>while</B></FONT> 1:
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self.running:
                <FONT COLOR=black><B>return</B></FONT>

            <FONT COLOR=#1111CC>#block for timeout seconds waiting for connections</FONT>
            <FONT COLOR=black><B>try</B></FONT>:
                input, output, exc = select.select(inputsockets,[],[],timeout)
            <FONT COLOR=black><B>except</B></FONT> select.error, v:
                <FONT COLOR=#1111CC># if the error is EINTR/interrupt, then self.running should be set to 0 and</FONT>
                <FONT COLOR=#1111CC># we'll exit on the next loop</FONT>
                <FONT COLOR=black><B>if</B></FONT> v[0] == EINTR <FONT COLOR=black><B>or</B></FONT> v[0]==0: <FONT COLOR=black><B>break</B></FONT>
                <FONT COLOR=black><B>else</B></FONT>: <FONT COLOR=black><B>raise</B></FONT>

            <FONT COLOR=#1111CC># @@ gat 2002-03-20: I found through heavy testing of restart behavior that WebKit</FONT>
            <FONT COLOR=#1111CC># dropped fewer requests on restart by removing this test.</FONT>
<FONT COLOR=#1111CC>##          if not self.running:</FONT>
<FONT COLOR=#1111CC>##              return</FONT>

            <FONT COLOR=black><B>for</B></FONT> sock <FONT COLOR=black><B>in</B></FONT> input:
                <FONT COLOR=black><B>if</B></FONT> sock.getsockname()[1] == self.monitorPort:
                    client,addr = sock.accept()
                    monitor.activate(client)
                    self.requestQueue.put(monitor)
                <FONT COLOR=black><B>else</B></FONT>:
                    self._reqCount = self._reqCount+1
                    rh = None
                    client,addr = sock.accept()
                    <FONT COLOR=black><B>try</B></FONT>:
                        rh = self.rhCache.pop()
                    <FONT COLOR=black><B>except</B></FONT> IndexError:
                        rh = RequestHandler(self)
                    rh.activate(client, self._reqCount)
                    self.requestQueue.put(rh)

            <FONT COLOR=black><B>if</B></FONT> threadCheck % threadUpdateDivisor == 0:
                self.updateThreadUsage()

            <FONT COLOR=black><B>if</B></FONT> threadCheck &gt; threadCheckInterval:
                <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"\nBusy Threads: "</FONT>, self.activeThreadCount()
                threadCheck=0
                self.manageThreadCount()
            <FONT COLOR=black><B>else</B></FONT>: threadCheck = threadCheck+1

            self.restartIfNecessary()

    <FONT COLOR=black><B>def</B></FONT> activeThreadCount(self):
        <FONT COLOR=#FF0000>"""
        Get a snapshot of the number of threads currently in use.
        """</FONT>
        count=0
        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> self.threadPool:
            <FONT COLOR=black><B>if</B></FONT> i.processing: count = count+1
        <FONT COLOR=black><B>return</B></FONT> count


    <FONT COLOR=black><B>def</B></FONT> updateThreadUsage(self):
        <FONT COLOR=#FF0000>"""
        Update the threadUseCounter list.
        """</FONT>
        count = self.activeThreadCount()
        <FONT COLOR=black><B>if</B></FONT> len(self.threadUseCounter) &gt; self.maxServerThreads:
            self.threadUseCounter.pop(0)
        self.threadUseCounter.append(count)


    <FONT COLOR=black><B>def</B></FONT> manageThreadCount(self):
        <FONT COLOR=#FF0000>"""
        Adjust the number of threads in use.
        This algorithm needs work.  The edges (ie at the minserverthreads) are tricky.
        When working with this, remember thread creation is CHEAP
        """</FONT>

        avg=0
        max=0
        debug=0

        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"ThreadUse Samples=%s"</FONT> % str(self.threadUseCounter)
        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> self.threadUseCounter:
            avg = avg + i
            <FONT COLOR=black><B>if</B></FONT> i &gt; max:
                max = i
        avg = avg / len(self.threadUseCounter)
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Average Thread Use: "</FONT>, avg
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Max Thread Use: "</FONT>, max
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"ThreadCount: "</FONT>, self.threadCount

        <FONT COLOR=black><B>if</B></FONT> len(self.threadUseCounter) &lt; self.maxServerThreads: <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#1111CC>#not </FONT>enough samples

        margin = self.threadCount / 2 <FONT COLOR=#1111CC>#smoothing factor</FONT>
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"margin="</FONT>, margin

        <FONT COLOR=black><B>if</B></FONT> avg &gt; self.threadCount - margin <FONT COLOR=black><B>and</B></FONT> self.threadCount &lt; self.maxServerThreads:
            <FONT COLOR=#1111CC># Running low: double thread count</FONT>
            n = min(self.threadCount, self.maxServerThreads-self.threadCount)
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Adding %s threads"</FONT> % n
            <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> range(n):
                self.spawnThread()
        <FONT COLOR=black><B>elif</B></FONT> avg &lt; self.threadCount - margin <FONT COLOR=black><B>and</B></FONT> self.threadCount &gt; self.minServerThreads:
            n=min(self.threadCount - self.minServerThreads, self.threadCount - max) 
            self.absorbThread(n)
        <FONT COLOR=black><B>else</B></FONT>:  <FONT COLOR=#1111CC>#cleanup any stale threads that we killed but haven't joined</FONT>
            self.absorbThread(0)

    <FONT COLOR=black><B>def</B></FONT> spawnThread(self):
        debug=0
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Spawning new thread"</FONT>
        t = Thread(target=self.threadloop)
        t.processing=0
        t.start()
        self.threadPool.append(t)
        self.threadCount = self.threadCount+1
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"New Thread Spawned, threadCount="</FONT>, self.threadCount
<FONT COLOR=#1111CC>##      self.threadUseCounter=[] #reset</FONT>

    <FONT COLOR=black><B>def</B></FONT> absorbThread(self,count=1):
        <FONT COLOR=#FF0000>"""  Absorb a thread.
        We do this by putting a None on the Queue.  When a thread gets it,
        that tells it to exit.  BUT, even though we put it on, the thread may not
        have retrieved it before we exit this function.  So we need to decrement
        the thread count even if we didn't find a thread that isn't alive. We'll
        get it the next time through.
        """</FONT>
        debug=0
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Absorbing %s Threads"</FONT> % count
        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> range(count):
                       self.requestQueue.put(None)
                       self.threadCount = self.threadCount-1
        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> self.threadPool:
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> i.isAlive():
                rv=i.join() <FONT COLOR=#1111CC>#Don't need a timeout, it isn't alive</FONT>
                self.threadPool.remove(i)
                <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Thread Absorbed, Real Thread Count="</FONT>, len(self.threadPool)
<FONT COLOR=#1111CC>##      self.threadUseCounter=[] #reset</FONT>


    <FONT COLOR=black><B>def</B></FONT> threadloop(self):
        self.initThread()

        t=threading.currentThread()
        t.processing=0
        <FONT COLOR=black><B>try</B></FONT>:
            <FONT COLOR=black><B>while</B></FONT> 1:
                <FONT COLOR=black><B>try</B></FONT>:
                    rh=self.requestQueue.get()
                    <FONT COLOR=black><B>if</B></FONT> rh == None: <FONT COLOR=#1111CC>#None means time to quit</FONT>
                        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Thread retrieved None, quitting"</FONT>
                        <FONT COLOR=black><B>break</B></FONT>
                    <FONT COLOR=#1111CC># @@ gat 2002-03-21: we don't want to drop a request that we've</FONT>
                    <FONT COLOR=#1111CC># already received from the adapter; therefore, I removed the</FONT>
                    <FONT COLOR=#1111CC># test of self.running.  Now, once a request gets put into the</FONT>
                    <FONT COLOR=#1111CC># request queue, it WILL be processed, never dropped.  This</FONT>
                    <FONT COLOR=#1111CC># might slow down shutdown a bit if many requests are currently</FONT>
                    <FONT COLOR=#1111CC># being processed, but it makes restarting the appserver work</FONT>
                    <FONT COLOR=#1111CC># better.</FONT>
<FONT COLOR=#1111CC>##                  if self.running:</FONT>
<FONT COLOR=#1111CC>##                      t.processing=1</FONT>
<FONT COLOR=#1111CC>##                      try:</FONT>
<FONT COLOR=#1111CC>##                          rh.handleRequest()</FONT>
<FONT COLOR=#1111CC>##                      except:</FONT>
<FONT COLOR=#1111CC>##                          traceback.print_exc(file=sys.stderr)</FONT>
<FONT COLOR=#1111CC>##                      t.processing=0</FONT>
                    t.processing=1
                    <FONT COLOR=black><B>try</B></FONT>:
                        rh.handleRequest()
                    <FONT COLOR=black><B>except</B></FONT>:
                        traceback.print_exc(file=sys.stderr)
                    t.processing=0
                    rh.close()
                <FONT COLOR=black><B>except</B></FONT> Queue.Empty:
                    <FONT COLOR=black><B>pass</B></FONT>
        <FONT COLOR=black><B>finally</B></FONT>:
            self.delThread()
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> threading.currentThread(), <FONT COLOR=#FF0000>"Quitting"</FONT>

    <FONT COLOR=black><B>def</B></FONT> initThread(self):
        <FONT COLOR=#FF0000>""" Invoked immediately by threadloop() as a hook for subclasses. This implementation does nothing and subclasses need not invoke super. """</FONT>
        <FONT COLOR=black><B>pass</B></FONT>

    <FONT COLOR=black><B>def</B></FONT> delThread(self):
        <FONT COLOR=#FF0000>""" Invoked immediately by threadloop() as a hook for subclasses. This implementation does nothing and subclasses need not invoke super. """</FONT>
        <FONT COLOR=black><B>pass</B></FONT>

    <FONT COLOR=black><B>def</B></FONT> awakeSelect(self):
        <FONT COLOR=#FF0000>"""
        Send a connect to ourself to pop the select() call out of it's loop safely
        """</FONT>
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        addr = self.address()
        <FONT COLOR=black><B>try</B></FONT>:
            sock.connect(addr)
            sock.close()
        <FONT COLOR=black><B>except</B></FONT>:
            <FONT COLOR=black><B>pass</B></FONT>
        <FONT COLOR=black><B>return</B></FONT>


    <FONT COLOR=black><B>def</B></FONT> shutDown(self):
        self.running=0
        self.awakeSelect()
        self._shuttingdown=1  <FONT COLOR=#1111CC>#jsl-is this used anywhere?</FONT>
        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"ThreadedAppServer: Shutting Down"</FONT>
        self.mainsocket.close()
        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> range(self.threadCount):
            self.requestQueue.put(None)<FONT COLOR=#1111CC>#kill all threads</FONT>
        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> self.threadPool:
            <FONT COLOR=black><B>try</B></FONT>:
                i.join()
            <FONT COLOR=black><B>except</B></FONT>:
                <FONT COLOR=black><B>pass</B></FONT>
        AppServer.shutDown(self)


    <FONT COLOR=#1111CC>## Network Server ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> address(self):
        <FONT COLOR=black><B>if</B></FONT> self._addr <FONT COLOR=black><B>is</B></FONT> None:
            self._addr = (self.setting(<FONT COLOR=#FF0000>'Host'</FONT>), self.setting(<FONT COLOR=#FF0000>'Port'</FONT>))
        <FONT COLOR=black><B>return</B></FONT> self._addr


    <FONT COLOR=#1111CC>## Misc ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> setRequestQueueSize(self, value):
        <FONT COLOR=black><B>assert</B></FONT> value&gt;=1
        self.__class__.request_queue_size = value




<FONT COLOR=black><B>class</B></FONT> Monitor:
    <FONT COLOR=black><B>def</B></FONT> __init__(self, server):
        self.server = server
        self.port = server.monitorPort
        self.insock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.insock.bind((server.address()[0],server.address()[1]-1))
        self.insock.listen(1)
        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"******** Listening to Monitor Socket ************"</FONT>

    <FONT COLOR=black><B>def</B></FONT> activate(self, socket):
        self.sock = socket

    <FONT COLOR=black><B>def</B></FONT> close(self):
        self.sock = None

    <FONT COLOR=black><B>def</B></FONT> handleRequest(self):

        verbose = self.server._verbose
        startTime = time.time()
        <FONT COLOR=black><B>if</B></FONT> verbose:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'BEGIN REQUEST'</FONT>
            <FONT COLOR=black><B>print</B></FONT> time.asctime(time.localtime(startTime))
        conn = self.sock
        <FONT COLOR=black><B>if</B></FONT> verbose:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'receiving request from'</FONT>, conn

        BUFSIZE = 8*1024


        chunk = <FONT COLOR=#FF0000>''</FONT>
        missing = int_length
        <FONT COLOR=black><B>while</B></FONT> missing &gt; 0:
            block = conn.recv(missing)
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> block:
                conn.close()
                <FONT COLOR=black><B>raise</B></FONT> NotEnoughDataError, <FONT COLOR=#FF0000>'received only %d out of %d bytes when receiving dict_length'</FONT> % (len(chunk), int_length)
            chunk = chunk + block
            missing = int_length - len(chunk)
        dict_length = loads(chunk)
        <FONT COLOR=black><B>if</B></FONT> type(dict_length) != type(1):
            conn.close()
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Error: Invalid AppServer protocol"</FONT>
            <FONT COLOR=black><B>return</B></FONT> 0

        chunk = <FONT COLOR=#FF0000>''</FONT>
        missing = dict_length
        <FONT COLOR=black><B>while</B></FONT> missing &gt; 0:
            block = conn.recv(missing)
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> block:
                conn.close()
                <FONT COLOR=black><B>raise</B></FONT> NotEnoughDataError, <FONT COLOR=#FF0000>'received only %d out of %d bytes when receiving dict'</FONT> % (len(chunk), dict_length)
            chunk = chunk + block
            missing = dict_length - len(chunk)

        dict = loads(chunk)

        <FONT COLOR=black><B>if</B></FONT> dict[<FONT COLOR=#FF0000>'format'</FONT>] == <FONT COLOR=#FF0000>"STATUS"</FONT>:
            conn.send(str(self.server._reqCount))

        <FONT COLOR=black><B>if</B></FONT> dict[<FONT COLOR=#FF0000>'format'</FONT>] == <FONT COLOR=#FF0000>'QUIT'</FONT>:
            conn.send(<FONT COLOR=#FF0000>"OK"</FONT>)
            conn.close()
            self.server.shutDown()



<FONT COLOR=black><B>from</B></FONT> WebKit.ASStreamOut <FONT COLOR=black><B>import</B></FONT> ASStreamOut
<FONT COLOR=black><B>class</B></FONT> TASASStreamOut(ASStreamOut):

    <FONT COLOR=black><B>def</B></FONT> __init__(self, sock):
        ASStreamOut.__init__(self)
        self._socket = sock

    <FONT COLOR=black><B>def</B></FONT> flush(self):
        debug=0
        result = ASStreamOut.flush(self)
        <FONT COLOR=black><B>if</B></FONT> result: <FONT COLOR=#1111CC>##a true return value means we can send</FONT>
            reslen = len(self._buffer)
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"TASASStreamout is sending %s bytes"</FONT> % reslen
            sent = 0
            <FONT COLOR=black><B>while</B></FONT> sent &lt; reslen:
                <FONT COLOR=black><B>try</B></FONT>:
                    sent = sent + self._socket.send(self._buffer[sent:sent+8192])
                <FONT COLOR=black><B>except</B></FONT> socket.error, e:
                    <FONT COLOR=black><B>if</B></FONT> e[0]==errno.EPIPE: <FONT COLOR=#1111CC>#broken pipe</FONT>
                        <FONT COLOR=black><B>pass</B></FONT>
                    <FONT COLOR=black><B>else</B></FONT>:
                        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"StreamOut Error: "</FONT>, e
                    <FONT COLOR=black><B>break</B></FONT>
            self.pop(sent)


<FONT COLOR=black><B>class</B></FONT> RequestHandler:

    <FONT COLOR=black><B>def</B></FONT> __init__(self, server):
        self.server = server

    <FONT COLOR=black><B>def</B></FONT> activate(self, sock, number):
        <FONT COLOR=#FF0000>"""
        Activates the handler for processing the request.
        Number is the number of the request, mostly used to identify
        verbose output. Each request should be given a unique,
        incremental number.
        """</FONT>
        self.sock = sock
<FONT COLOR=#1111CC>#       self._strmOut = TASASStreamOut(sock)</FONT>
        self._number = number

    <FONT COLOR=black><B>def</B></FONT> close(self):
        self.sock = None
<FONT COLOR=#1111CC>#       self._strmOut = None</FONT>
        self.server.rhCache.append(self)

    <FONT COLOR=black><B>def</B></FONT> handleRequest(self):

        verbose = self.server._verbose

        startTime = time.time()
        <FONT COLOR=black><B>if</B></FONT> verbose:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'%5i  %s '</FONT> % (self._number, timestamp()[<FONT COLOR=#FF0000>'pretty'</FONT>]),

        conn = self.sock

        <FONT COLOR=#1111CC># @@ 2001-05-30 ce: Ack! Look at this hard coding.</FONT>
        BUFSIZE = 8*1024

        data = []

        chunk = <FONT COLOR=#FF0000>''</FONT>
        missing = int_length
        <FONT COLOR=black><B>while</B></FONT> missing &gt; 0:
            block = conn.recv(missing)
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> block:
                conn.close()
                <FONT COLOR=black><B>if</B></FONT> len(chunk) == 0:
                    <FONT COLOR=#1111CC># We probably awakened due to awakeSelect being called.</FONT>
                    <FONT COLOR=black><B>return</B></FONT> 0
                <FONT COLOR=black><B>else</B></FONT>:
                    <FONT COLOR=#1111CC># We got a partial request -- something went wrong.</FONT>
                    <FONT COLOR=black><B>raise</B></FONT> NotEnoughDataError, <FONT COLOR=#FF0000>'received only %d out of %d bytes when receiving dict_length'</FONT> % (len(chunk), int_length)
            chunk = chunk + block
            missing = int_length - len(chunk)
        dict_length = loads(chunk)
        <FONT COLOR=black><B>if</B></FONT> type(dict_length) != type(1):
            conn.close()
            <FONT COLOR=black><B>print</B></FONT>
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Error: Invalid AppServer protocol"</FONT>
            <FONT COLOR=black><B>return</B></FONT> 0

        chunk = <FONT COLOR=#FF0000>''</FONT>
        missing = dict_length
        <FONT COLOR=black><B>while</B></FONT> missing &gt; 0:
            block = conn.recv(missing)
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> block:
                conn.close()
                <FONT COLOR=black><B>raise</B></FONT> NotEnoughDataError, <FONT COLOR=#FF0000>'received only %d out of %d bytes when receiving dict'</FONT> % (len(chunk), dict_length)
            chunk = chunk + block
            missing = dict_length - len(chunk)

        dict = loads(chunk)
        <FONT COLOR=#1111CC>#if </FONT>verbose: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Comm Delay=%s"</FONT> % (time.time() - dict[<FONT COLOR=#FF0000>'time'</FONT>])

        <FONT COLOR=black><B>if</B></FONT> dict:
            <FONT COLOR=black><B>if</B></FONT> verbose:
                <FONT COLOR=black><B>if</B></FONT> dict.has_key(<FONT COLOR=#FF0000>'environ'</FONT>):
                    requestURI = Funcs.requestURI(dict[<FONT COLOR=#FF0000>'environ'</FONT>])
                <FONT COLOR=black><B>else</B></FONT>:
                    requestURI = None
                <FONT COLOR=black><B>print</B></FONT> requestURI

        dict[<FONT COLOR=#FF0000>'input'</FONT>] = conn.makefile(<FONT COLOR=#FF0000>"rb"</FONT>,8012)

        strmOut = TASASStreamOut(self.sock)
        transaction = self.server._app.dispatchRawRequest(dict, strmOut)
        strmOut.close()


        <FONT COLOR=black><B>try</B></FONT>:
            conn.shutdown(1)
            conn.close()
        <FONT COLOR=black><B>except</B></FONT>:
            <FONT COLOR=black><B>pass</B></FONT>

        <FONT COLOR=black><B>if</B></FONT> verbose:
            duration = <FONT COLOR=#FF0000>'%0.2f secs'</FONT> % (time.time() - startTime)
            duration = string.ljust(duration, 19)
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'%5i  %s  %s'</FONT> % (self._number, duration, requestURI)
            <FONT COLOR=black><B>print</B></FONT>

        transaction._application=None
        transaction.die()
        <FONT COLOR=black><B>del</B></FONT> transaction

    <FONT COLOR=black><B>def</B></FONT> restartApp(self):
        <FONT COLOR=#FF0000>"""
        Not used
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> self.server.num_requests&gt; 200:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Trying to get lock"</FONT>
            ReStartLock.acquire()
            <FONT COLOR=black><B>if</B></FONT> self.server.num_requests&gt; 200: <FONT COLOR=#1111CC>#check again to make sure another thread didn't do it</FONT>
                <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Restarting Application"</FONT>
                currApp=self.server.wkApp
                wkAppServer=currApp._server
                newApp = wkAppServer.createApplication()
                newApp._sessions = currApp._sessions
                wkAppServer._app=newApp
                self.server.wkApp=newApp
                <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> currApp._factoryList:
                    currApp._factoryList.remove(i)
                <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> currApp._factoryByExt.keys():
                    currApp._factoryByExt[i]=None
                currApp._canFactory=None
                wkAppServer._plugIns=[]
                wkAppServer.loadPlugIns()


                self.server.num_requests=0
                <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Refs to old App="</FONT>,sys.getrefcount(currApp)
                currApp=None
            ReStartLock.release()

<FONT COLOR=#1111CC># This will be thrown when less data arrived on the socket than we were expecting.</FONT>
<FONT COLOR=black><B>class</B></FONT> NotEnoughDataError(Exception):
    <FONT COLOR=black><B>pass</B></FONT>


<FONT COLOR=black><B>def</B></FONT> run(useMonitor = 0, workDir=None):
    <FONT COLOR=black><B>global</B></FONT> server
    <FONT COLOR=black><B>global</B></FONT> monitor
    monitor = useMonitor
    <FONT COLOR=black><B>try</B></FONT>:
        server = None
        server = ThreadedAppServer(workDir)
        <FONT COLOR=black><B>if</B></FONT> useMonitor:
            monitor_socket = Monitor(server)
        <FONT COLOR=black><B>else</B></FONT>:
            monitor_socket = None

        <FONT COLOR=#1111CC># On NT, run mainloop in a different thread because it's not safe for</FONT>
        <FONT COLOR=#1111CC># Ctrl-C to be caught while manipulating the queues.</FONT>
        <FONT COLOR=#1111CC># It's not safe on Linux either, but there, it appears that Ctrl-C</FONT>
        <FONT COLOR=#1111CC># will trigger an exception in ANY thread, so this fix doesn't help.</FONT>
        <FONT COLOR=black><B>if</B></FONT> os.name == <FONT COLOR=#FF0000>'nt'</FONT>:
            <FONT COLOR=#1111CC># catch the exception raised by sys.exit so that we can re-call it</FONT>
            <FONT COLOR=#1111CC># in the main thread.</FONT>
            <FONT COLOR=black><B>global</B></FONT> exitStatus
            exitStatus = None
            <FONT COLOR=black><B>def</B></FONT> windowsmainloop(server, monitor):
                <FONT COLOR=black><B>global</B></FONT> exitStatus
                <FONT COLOR=black><B>try</B></FONT>:
                    server.mainloop(monitor)
                <FONT COLOR=black><B>except</B></FONT> SystemExit, e:
                    exitStatus = e.code

            <FONT COLOR=#1111CC># Run the server thread</FONT>
            t = threading.Thread(target=windowsmainloop, args=(server, monitor_socket))
            t.start()
            <FONT COLOR=black><B>try</B></FONT>:
                <FONT COLOR=black><B>while</B></FONT> server.running:
                    time.sleep(1.0)
            <FONT COLOR=black><B>except</B></FONT> KeyboardInterrupt:
                <FONT COLOR=black><B>pass</B></FONT>
            server.running = 0
            t.join()

            <FONT COLOR=#1111CC># re-call sys.exit if necessary</FONT>
            <FONT COLOR=black><B>if</B></FONT> exitStatus:
                sys.exit(exitStatus)
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>try</B></FONT>:
                server.mainloop(monitor_socket)
            <FONT COLOR=black><B>except</B></FONT> KeyboardInterrupt, e:
                server.shutDown()
    <FONT COLOR=black><B>except</B></FONT> Exception, e:
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> isinstance(e, SystemExit):
            <FONT COLOR=black><B>import</B></FONT> traceback
            traceback.print_exc(file=sys.stderr)
        <FONT COLOR=#1111CC>#print </FONT>e
        <FONT COLOR=black><B>print</B></FONT>
        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Exiting AppServer"</FONT>
        <FONT COLOR=black><B>if</B></FONT> server:
            <FONT COLOR=black><B>if</B></FONT> server.running:
                server.initiateShutdown()
            server._closeThread.join()
        <FONT COLOR=#1111CC># if we're here as a result of exit() being called,</FONT>
        <FONT COLOR=#1111CC># exit with that return code.</FONT>
        <FONT COLOR=black><B>if</B></FONT> isinstance(e,SystemExit):
            sys.exit(e)

    sys.exit()


<FONT COLOR=black><B>def</B></FONT> shutDown(arg1,arg2):
    <FONT COLOR=black><B>global</B></FONT> server
    <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Shutdown Called"</FONT>, time.asctime(time.localtime(time.time()))
    <FONT COLOR=black><B>if</B></FONT> server:
        server.initiateShutdown()
    <FONT COLOR=black><B>else</B></FONT>:
        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'WARNING: No server reference to shutdown.'</FONT>

<FONT COLOR=black><B>import</B></FONT> signal
signal.signal(signal.SIGINT, shutDown)
signal.signal(signal.SIGTERM, shutDown)




usage = <FONT COLOR=#FF0000>"""
The AppServer is the main process of WebKit.  It handles requests for servlets from webservers.
ThreadedAppServer takes the following command line arguments:
stop:  Stop the currently running Apperver.
daemon: run as a daemon
If AppServer is called with no arguments, it will start the AppServer and record the pid of the process in appserverpid.txt
"""</FONT>

<FONT COLOR=black><B>import</B></FONT> re
settingRE = re.compile(r<FONT COLOR=#FF0000>'^--([a-zA-Z][a-zA-Z0-9]*\.[a-zA-Z][a-zA-Z0-9]*)='</FONT>)
<FONT COLOR=black><B>from</B></FONT> MiscUtils <FONT COLOR=black><B>import</B></FONT> Configurable

<FONT COLOR=black><B>def</B></FONT> main(args):
    monitor=0
    function=run
    daemon=0
    workDir=None

    <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> args[:]:
        <FONT COLOR=black><B>if</B></FONT> settingRE.match(i):
            match = settingRE.match(i)
            name = match.group(1)
            value = i[match.end():]
            Configurable.addCommandLineSetting(name, value)
        <FONT COLOR=black><B>elif</B></FONT> i == <FONT COLOR=#FF0000>"monitor"</FONT>:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Enabling Monitoring"</FONT>
            monitor=1
        <FONT COLOR=black><B>elif</B></FONT> i == <FONT COLOR=#FF0000>"stop"</FONT>:
            <FONT COLOR=black><B>import</B></FONT> AppServer
            function=AppServer.stop
        <FONT COLOR=black><B>elif</B></FONT> i == <FONT COLOR=#FF0000>"daemon"</FONT>:
            daemon=1
        <FONT COLOR=black><B>elif</B></FONT> i == <FONT COLOR=#FF0000>"start"</FONT>:
            <FONT COLOR=black><B>pass</B></FONT>
        <FONT COLOR=black><B>elif</B></FONT> i[:8] == <FONT COLOR=#FF0000>"workdir="</FONT>:
            workDir = i[8:]
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>print</B></FONT> usage

    <FONT COLOR=black><B>if</B></FONT> daemon:
        <FONT COLOR=black><B>if</B></FONT> os.name == <FONT COLOR=#FF0000>"posix"</FONT>:
            pid=os.fork()
            <FONT COLOR=black><B>if</B></FONT> pid:
                sys.exit()
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"daemon mode not available on your OS"</FONT>
    function(monitor, workDir)
</PRE>
                  <!--footer-->
                  </BODY>
