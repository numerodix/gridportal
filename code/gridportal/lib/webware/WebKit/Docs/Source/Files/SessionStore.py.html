<HTML><HEAD><TITLE>WebKit/SessionStore.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=black><B>from</B></FONT> Common <FONT COLOR=black><B>import</B></FONT> *


<FONT COLOR=black><B>class</B></FONT> SessionStore(Object):
    <FONT COLOR=#FF0000>"""
    SessionStores are dictionary-like objects used by Application to
    store session state. This class is abstract and it's up to the
    concrete subclass to implement several key methods that determine
    how sessions are stored (such as in memory, on disk or in a
    database).

    Subclasses often encode sessions for storage somewhere. In light
    of that, this class also defines methods encoder(), decoder() and
    setEncoderDecoder(). The encoder and decoder default to the load()
    and dump() functions of the cPickle or pickle module. However,
    using the setEncoderDecoder() method, you can use the functions
    from marshal (if appropriate) or your own encoding scheme.
    Subclasses should use encoder() and decoder() (and not
    pickle.load() and pickle.dump()).

    Subclasses may rely on the attribute self._app to point to the
    application.

    Subclasses should be named SessionFooStore since Application
    expects "Foo" to appear for the "SessionStore" setting and
    automatically prepends Session and appends Store. Currently, you
    will also need to add another import statement in Application.py.
    Search for SessionStore and you'll find the place.

    TO DO

    * Should there be a check-in/check-out strategy for sessions to
      prevent concurrent requests on the same session? If so, that can
      probably be done at this level (as opposed to pushing the burden
      on various subclasses).
    """</FONT>


    <FONT COLOR=#1111CC>## Init ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, app):
        <FONT COLOR=#FF0000>""" Subclasses must invoke super. """</FONT>
        Object.__init__(self)
        self._app = app

        <FONT COLOR=black><B>try</B></FONT>:
            <FONT COLOR=black><B>from</B></FONT> cPickle <FONT COLOR=black><B>import</B></FONT> load, dump
        <FONT COLOR=black><B>except</B></FONT> ImportError:
            <FONT COLOR=black><B>from</B></FONT> pickle <FONT COLOR=black><B>import</B></FONT> load, dump
        self._encoder = dump
        self._decoder = load


    <FONT COLOR=#1111CC>## Access ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> application(self):
        <FONT COLOR=black><B>return</B></FONT> self._app


    <FONT COLOR=#1111CC>## Dictionary-style access ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __len__(self):
        <FONT COLOR=black><B>raise</B></FONT> AbstractError, self.__class__

    <FONT COLOR=black><B>def</B></FONT> __getitem__(self, key):
        <FONT COLOR=black><B>raise</B></FONT> AbstractError, self.__class__

    <FONT COLOR=black><B>def</B></FONT> __setitem__(self, key, item):
        <FONT COLOR=black><B>raise</B></FONT> AbstractError, self.__class__

    <FONT COLOR=black><B>def</B></FONT> __delitem__(self, key):
        <FONT COLOR=#FF0000>"""
        Subclasses are responsible for expiring the session as well.
        Something along the lines of:
            sess = self[key]
            if not sess.isExpired():
                sess.expiring()
        """</FONT>
        <FONT COLOR=black><B>raise</B></FONT> AbstractError, self.__class__

    <FONT COLOR=black><B>def</B></FONT> has_key(self, key):
        <FONT COLOR=black><B>raise</B></FONT> AbstractError, self.__class__

    <FONT COLOR=black><B>def</B></FONT> keys(self):
        <FONT COLOR=black><B>raise</B></FONT> AbstractError, self.__class__

    <FONT COLOR=black><B>def</B></FONT> clear(self):
        <FONT COLOR=black><B>raise</B></FONT> AbstractError, self.__class__


    <FONT COLOR=#1111CC>## Application support ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> storeSession(self, session):
        <FONT COLOR=black><B>raise</B></FONT> AbstractError, self.__class__

    <FONT COLOR=black><B>def</B></FONT> storeAllSessions(self):
        <FONT COLOR=black><B>raise</B></FONT> AbstractError, self.__class__

    <FONT COLOR=black><B>def</B></FONT> cleanStaleSessions(self, task=None):
        <FONT COLOR=#FF0000>"""
        Called by the Application to tell this store to clean out all sessions that
        have exceeded their lifetime.
        """</FONT>
        curTime = time.time()
        <FONT COLOR=black><B>for</B></FONT> key, sess <FONT COLOR=black><B>in</B></FONT> self.items():
            <FONT COLOR=black><B>if</B></FONT> (curTime - sess.lastAccessTime()) &gt;= sess.timeout()  <FONT COLOR=black><B>or</B></FONT>  sess.timeout()==0:
                <FONT COLOR=black><B>del</B></FONT> self[key]


    <FONT COLOR=#1111CC>## Convenience methods ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> items(self):
        <FONT COLOR=black><B>return</B></FONT> map(<FONT COLOR=black><B>lambda</B></FONT> key, self=self: (key, self[key]), self.keys())

    <FONT COLOR=black><B>def</B></FONT> values(self):
        <FONT COLOR=black><B>return</B></FONT> map(<FONT COLOR=black><B>lambda</B></FONT> key, self=self: self[key], self.keys())

    <FONT COLOR=black><B>def</B></FONT> get(self, key, default=None):
        <FONT COLOR=black><B>if</B></FONT> self.has_key(key):
            <FONT COLOR=black><B>return</B></FONT> self[key]
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> default


    <FONT COLOR=#1111CC>## Encoder/decoder ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> encoder(self):
        <FONT COLOR=black><B>return</B></FONT> self._encoder

    <FONT COLOR=black><B>def</B></FONT> decoder(self):
        <FONT COLOR=black><B>return</B></FONT> self._decoder

    <FONT COLOR=black><B>def</B></FONT> setEncoderDecoder(self, encoder, decoder):
        self._encoder = encoder
        self._decoder = decoder


    <FONT COLOR=#1111CC>## As a string ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __repr__(self):
        d = {}
        <FONT COLOR=black><B>for</B></FONT> key, value <FONT COLOR=black><B>in</B></FONT> self.items():
            d[key] = value
        <FONT COLOR=black><B>return</B></FONT> repr(d)
</PRE>
                  <!--footer-->
                  </BODY>
