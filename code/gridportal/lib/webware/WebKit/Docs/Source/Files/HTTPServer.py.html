<HTML><HEAD><TITLE>WebKit/HTTPServer.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=black><B>import</B></FONT> BaseHTTPServer, mimetools
<FONT COLOR=black><B>try</B></FONT>:
    <FONT COLOR=black><B>from</B></FONT> cStringIO <FONT COLOR=black><B>import</B></FONT> StringIO
<FONT COLOR=black><B>except</B></FONT> ImportError:
    <FONT COLOR=black><B>from</B></FONT> StringIO <FONT COLOR=black><B>import</B></FONT> StringIO
<FONT COLOR=black><B>import</B></FONT> threading, socket
<FONT COLOR=black><B>from</B></FONT> WebKit.NewThreadedAppServer <FONT COLOR=black><B>import</B></FONT> Handler
<FONT COLOR=black><B>from</B></FONT> WebKit.ASStreamOut <FONT COLOR=black><B>import</B></FONT> ASStreamOut
<FONT COLOR=black><B>import</B></FONT> time

<FONT COLOR=black><B>class</B></FONT> HTTPHandler(BaseHTTPServer.BaseHTTPRequestHandler):
    <FONT COLOR=#FF0000>"""Handles incoming requests.  Recreated with every request.
    Abstract base class.
    """</FONT>

    <FONT COLOR=#1111CC>## This sends certain CGI variables.  These are some that</FONT>
    <FONT COLOR=#1111CC>## should be sent, but aren't:</FONT>
    <FONT COLOR=#1111CC>## SERVER_ADDR</FONT>
    <FONT COLOR=#1111CC>## SERVER_PORT</FONT>
    <FONT COLOR=#1111CC>## SERVER_SOFTWARE</FONT>
    <FONT COLOR=#1111CC>## SERVER_NAME</FONT>
    <FONT COLOR=#1111CC>## HTTP_CONNECTION</FONT>
    <FONT COLOR=#1111CC>## SERVER_PROTOCOL</FONT>
    <FONT COLOR=#1111CC>## HTTP_KEEP_ALIVE</FONT>

    <FONT COLOR=#1111CC>## These I don't think are needed:</FONT>
    <FONT COLOR=#1111CC>## DOCUMENT_ROOT</FONT>
    <FONT COLOR=#1111CC>## PATH_TRANSLATED</FONT>
    <FONT COLOR=#1111CC>## GATEWAY_INTERFACE</FONT>
    <FONT COLOR=#1111CC>## PATH</FONT>
    <FONT COLOR=#1111CC>## SERVER_SIGNATURE</FONT>
    <FONT COLOR=#1111CC>## SCRIPT_NAME (?)</FONT>
    <FONT COLOR=#1111CC>## SCRIPT_FILENAME (?)</FONT>
    <FONT COLOR=#1111CC>## SERVER_ADMIN (?)</FONT>

    <FONT COLOR=black><B>def</B></FONT> doRequest(self):
        <FONT COLOR=#FF0000>"""
        Actually performs the request, creating the environment and
        calling self.doTransaction(env, myInput) to perform the
        response.
        """</FONT>
        self.server_version = <FONT COLOR=#FF0000>'Webware/0.1'</FONT>
        env = {}
        <FONT COLOR=black><B>if</B></FONT> self.headers.has_key(<FONT COLOR=#FF0000>'Content-Type'</FONT>):
            env[<FONT COLOR=#FF0000>'CONTENT_TYPE'</FONT>] = self.headers[<FONT COLOR=#FF0000>'Content-Type'</FONT>]
            <FONT COLOR=black><B>del</B></FONT> self.headers[<FONT COLOR=#FF0000>'Content-Type'</FONT>]
        self.headersToEnviron(self.headers, env)
        env[<FONT COLOR=#FF0000>'REMOTE_ADDR'</FONT>], env[<FONT COLOR=#FF0000>'REMOTE_PORT'</FONT>] = map(str, self.client_address)
        env[<FONT COLOR=#FF0000>'REQUEST_METHOD'</FONT>] = self.command
        path = self.path
        <FONT COLOR=black><B>if</B></FONT> path.find(<FONT COLOR=#FF0000>'?'</FONT>) != -1:
            env[<FONT COLOR=#FF0000>'REQUEST_URI'</FONT>], env[<FONT COLOR=#FF0000>'QUERY_STRING'</FONT>] = path.split(<FONT COLOR=#FF0000>'?'</FONT>, 1)
        <FONT COLOR=black><B>else</B></FONT>:
            env[<FONT COLOR=#FF0000>'REQUEST_URI'</FONT>] = path
            env[<FONT COLOR=#FF0000>'QUERY_STRING'</FONT>] = <FONT COLOR=#FF0000>''</FONT>
        env[<FONT COLOR=#FF0000>'PATH_INFO'</FONT>] = env[<FONT COLOR=#FF0000>'REQUEST_URI'</FONT>]
        myInput = <FONT COLOR=#FF0000>''</FONT>
        <FONT COLOR=black><B>if</B></FONT> self.headers.has_key(<FONT COLOR=#FF0000>'Content-Length'</FONT>):
            myInput = self.rfile.read(int(self.headers[<FONT COLOR=#FF0000>'Content-Length'</FONT>]))
        self.doTransaction(env, myInput)

    do_GET = do_POST = do_HEAD = doRequest
    <FONT COLOR=#1111CC># These methods are used in WebDAV requests:</FONT>
    do_OPTIONS = do_PUT = do_DELETE = doRequest
    do_MKCOL = do_COPY = do_MOVE = doRequest
    do_PROPFIND = doRequest

    <FONT COLOR=black><B>def</B></FONT> headersToEnviron(self, headers, env):
        <FONT COLOR=#FF0000>"""Use a simple heuristic to convert all the headers to
        environmental variables..."""</FONT>
        <FONT COLOR=black><B>for</B></FONT> header, value <FONT COLOR=black><B>in</B></FONT> headers.items():
            env[<FONT COLOR=#FF0000>'HTTP_%s'</FONT> % (header.upper().replace(<FONT COLOR=#FF0000>'-'</FONT>, <FONT COLOR=#FF0000>'_'</FONT>))] = value
        <FONT COLOR=black><B>return</B></FONT> env

    <FONT COLOR=black><B>def</B></FONT> processResponse(self, data):
        <FONT COLOR=#FF0000>"""
        Takes a string (like what a CGI script would print) and
        sends the actual HTTP response (response code, headers, body).
        """</FONT>
        s = StringIO(data)
        headers = mimetools.Message(s)
        self.doLocation(headers)
        self.sendStatus(headers)
        self.sendHeaders(headers)
        self.sendBody(s)

    <FONT COLOR=black><B>def</B></FONT> doLocation(self, headers):
        <FONT COLOR=#FF0000>"""If there's a Location header and no Status header,
        we need to add a Status header ourselves."""</FONT>
        <FONT COLOR=black><B>if</B></FONT> headers.has_key(<FONT COLOR=#FF0000>'Location'</FONT>):
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> headers.has_key(<FONT COLOR=#FF0000>'Status'</FONT>):
                <FONT COLOR=#1111CC>## @@: is this the right status header?</FONT>
                headers[<FONT COLOR=#FF0000>'Status'</FONT>] = <FONT COLOR=#FF0000>'301 Moved Temporarily'</FONT>

    <FONT COLOR=black><B>def</B></FONT> sendStatus(self, headers):
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> headers.has_key(<FONT COLOR=#FF0000>'Status'</FONT>):
            status = <FONT COLOR=#FF0000>"200 OK"</FONT>
        <FONT COLOR=black><B>else</B></FONT>:
            status = headers[<FONT COLOR=#FF0000>'Status'</FONT>]
            <FONT COLOR=black><B>del</B></FONT> headers[<FONT COLOR=#FF0000>'Status'</FONT>]
        pos = status.find(<FONT COLOR=#FF0000>' '</FONT>)
        <FONT COLOR=black><B>if</B></FONT> pos == -1:
            code = int(status)
            message = <FONT COLOR=#FF0000>''</FONT>
        <FONT COLOR=black><B>else</B></FONT>:
            code = int(status[:pos])
            message = status[pos:].strip()
        self.send_response(code, message)

    <FONT COLOR=black><B>def</B></FONT> sendHeaders(self, headers):
        <FONT COLOR=black><B>for</B></FONT> header, value <FONT COLOR=black><B>in</B></FONT> headers.items():
            self.send_header(header, value)
        self.end_headers()

    <FONT COLOR=black><B>def</B></FONT> sendBody(self, bodyFile):
        self.wfile.write(bodyFile.read())
        bodyFile.close()


<FONT COLOR=black><B>class</B></FONT> HTTPAppServerHandler(Handler, HTTPHandler):

    <FONT COLOR=#FF0000>"""
    Adapters HTTPHandler to fit with ThreadedAppServer's
    model of an adapter
    """</FONT>

    protocolName = <FONT COLOR=#FF0000>'http'</FONT>

    <FONT COLOR=black><B>def</B></FONT> handleRequest(self):
        HTTPHandler.__init__(self, self._sock, self._sock.getpeername(), None)

    <FONT COLOR=black><B>def</B></FONT> doTransaction(self, env, myInput):
        streamOut = ASStreamOut()
        requestDict = {
            <FONT COLOR=#FF0000>'format'</FONT>: <FONT COLOR=#FF0000>'CGI'</FONT>,
            <FONT COLOR=#FF0000>'time'</FONT>: time.time(),
            <FONT COLOR=#FF0000>'environ'</FONT>: env,
            <FONT COLOR=#FF0000>'input'</FONT>: StringIO(myInput),
            }
        self.dispatchRawRequest(requestDict, streamOut)
        self.processResponse(streamOut._buffer)
        self._sock.shutdown(2)

    <FONT COLOR=black><B>def</B></FONT> dispatchRawRequest(self, requestDict, streamOut):
        transaction = self._server._app.dispatchRawRequest(requestDict, streamOut)
        streamOut.close()
        transaction._application=None
        transaction.die()
        <FONT COLOR=black><B>del</B></FONT> transaction

</PRE>
                  <!--footer-->
                  </BODY>
