<HTML><HEAD><TITLE>WebKit/HTTPResponse.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=black><B>from</B></FONT> Common <FONT COLOR=black><B>import</B></FONT> *
<FONT COLOR=black><B>from</B></FONT> Response <FONT COLOR=black><B>import</B></FONT> Response
<FONT COLOR=black><B>from</B></FONT> WebKit.Cookie <FONT COLOR=black><B>import</B></FONT> Cookie
<FONT COLOR=black><B>from</B></FONT> types <FONT COLOR=black><B>import</B></FONT> *

<FONT COLOR=#1111CC># time.gmtime() no longer returns a tuple, and there is no globally defined type</FONT>
<FONT COLOR=#1111CC># for this at the moment.</FONT>
TimeTupleType = type(time.gmtime(0))

<FONT COLOR=#1111CC># Import mxDateTime if it exists, but we can get along with it</FONT>
<FONT COLOR=#1111CC># if not.</FONT>
<FONT COLOR=#1111CC>####################################################################</FONT>
<FONT COLOR=#1111CC>## - @@ sgd 2/5/2003 - removed optional DateTime temporarily for </FONT>
<FONT COLOR=#1111CC>## 0.8 release. Need to fix bug and verify after 0.8.</FONT>
<FONT COLOR=#1111CC>##</FONT>
<FONT COLOR=#1111CC>##try:</FONT>
<FONT COLOR=#1111CC>##  from mx import DateTime</FONT>
<FONT COLOR=#1111CC>##except ImportError:</FONT>
<FONT COLOR=#1111CC>##  try:</FONT>
<FONT COLOR=#1111CC>##      import DateTime</FONT>
<FONT COLOR=#1111CC>##  except ImportError:</FONT>
<FONT COLOR=#1111CC>##      DateTime = None</FONT>
DateTime = None
<FONT COLOR=#1111CC>####################################################################</FONT>

<FONT COLOR=black><B>from</B></FONT> MiscUtils.DateInterval <FONT COLOR=black><B>import</B></FONT> timeDecode

True, False = 1==1, 0==1

debug = 0

<FONT COLOR=black><B>class</B></FONT> HTTPResponse(Response):


    <FONT COLOR=#1111CC>## Init ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, transaction, strmOut, headers=None):
        <FONT COLOR=#FF0000>""" Initializes the request. """</FONT>

        Response.__init__(self, transaction, strmOut)

        self._committed = 0

        <FONT COLOR=black><B>if</B></FONT> headers <FONT COLOR=black><B>is</B></FONT> None:
            self._headers = {}<FONT COLOR=#1111CC>#{'Content-type': 'text/html'}</FONT>
            self.setHeader(<FONT COLOR=#FF0000>'Content-type'</FONT>,<FONT COLOR=#FF0000>'text/html'</FONT>)
        <FONT COLOR=black><B>else</B></FONT>:
            self._headers = headers

        self._cookies   = {}


    <FONT COLOR=#1111CC>## Headers ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> header(self, name, default=NoDefault):
        <FONT COLOR=#FF0000>""" Returns the value of the specified header. """</FONT>
        <FONT COLOR=black><B>if</B></FONT> default <FONT COLOR=black><B>is</B></FONT> NoDefault:
            <FONT COLOR=black><B>return</B></FONT> self._headers[string.lower(name)]
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> self._headers.get(string.lower(name), default)

    <FONT COLOR=black><B>def</B></FONT> hasHeader(self, name):
        <FONT COLOR=black><B>return</B></FONT> self._headers.has_key(string.lower(name))

    <FONT COLOR=black><B>def</B></FONT> setHeader(self, name, value):
        <FONT COLOR=#FF0000>"""
        Sets a specific header by name.
        -  parameters:
        name: Header Name
        value: Header Value
        """</FONT>
        <FONT COLOR=black><B>assert</B></FONT> self._committed==0, <FONT COLOR=#FF0000>"Headers have already been sent"</FONT>
        self._headers[string.lower(name)] = value


    <FONT COLOR=black><B>def</B></FONT> addHeader(self, name, value):
        <FONT COLOR=#FF0000>"""
        Adds a specific header by name.
        """</FONT>
        <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"addHeader is deprecated.  Use setHeader()."</FONT>
        <FONT COLOR=black><B>assert</B></FONT> self._committed==0
        self.setHeader(name, value)

    <FONT COLOR=black><B>def</B></FONT> headers(self, name=None):
        <FONT COLOR=#FF0000>""" Returns a dictionary-style object of all Header objects contained by this request. """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._headers

    <FONT COLOR=black><B>def</B></FONT> clearHeaders(self):
        <FONT COLOR=#FF0000>""" Clears all the headers. You might consider a setHeader('Content-type', 'text/html') or something similar after this. """</FONT>
        <FONT COLOR=black><B>assert</B></FONT> self._committed==0
        self._headers = {}


    <FONT COLOR=#1111CC>## Cookies ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> cookie(self, name):
        <FONT COLOR=#FF0000>""" Returns the value of the specified cookie. """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._cookies[name]

    <FONT COLOR=black><B>def</B></FONT> hasCookie(self, name):
        <FONT COLOR=#FF0000>"""
        Returns true if the specified cookie is present.
        """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._cookies.has_key(name)

    
    <FONT COLOR=black><B>def</B></FONT> setCookie(self, name, value, path=<FONT COLOR=#FF0000>'/'</FONT>, expires=<FONT COLOR=#FF0000>'ONCLOSE'</FONT>,
              secure=False):
        <FONT COLOR=#FF0000>"""
        Set a cookie.  You can also set the path (which defaults to /),
        You can also set when it expires.  It can expire:
          'NOW': this is the same as trying to delete it, but it
            doesn't really seem to work in IE
          'ONCLOSE': the default behavior for cookies (expires when
                    the browser closes)
          'NEVER': some time in the far, far future.
          integer: a timestamp value
          tuple: a tuple, as created by the time module

        @@ sgd 2/5/2003 - removed optional DateTime for 0.8 release. 
        Use of DateTime in this module has been broken for 3 months 
        and the fix has not been in any of the beta releases.
        Support may be implemented in a future release.

          DateTime: an mxDateTime object for the time
          DeltaDateTime: a interval from the present, e.g.,
            DateTime.DeltaDateTime(month=1) (1 month in the future)
                  '+...': a time in the future, '...' should be something like
            1w (1 week), 3h46m (3:45), etc.  You can use y (year),
                    b (month), w (week), d (day), h (hour), m (minute),
            s (second).  This is done by the MiscUtils.DateInterval.
        """</FONT>
        cookie = Cookie(name, value)
        <FONT COLOR=black><B>if</B></FONT> expires == <FONT COLOR=#FF0000>'ONCLOSE'</FONT> <FONT COLOR=black><B>or</B></FONT> <FONT COLOR=black><B>not</B></FONT> expires:
            <FONT COLOR=black><B>pass</B></FONT> <FONT COLOR=#1111CC># this is already default behavior</FONT>
        <FONT COLOR=black><B>elif</B></FONT> expires == <FONT COLOR=#FF0000>'NOW'</FONT> <FONT COLOR=black><B>or</B></FONT> expires == <FONT COLOR=#FF0000>'NEVER'</FONT>:
            t = time.gmtime(time.time())
            <FONT COLOR=black><B>if</B></FONT> expires == <FONT COLOR=#FF0000>'NEVER'</FONT>:
                t = (t[0] + 10,) + t[1:]
            t = time.strftime(<FONT COLOR=#FF0000>"%a, %d-%b-%Y %H:%M:%S GMT"</FONT>, t)
            cookie.setExpires(t)
        <FONT COLOR=black><B>else</B></FONT>:
            t = expires
            <FONT COLOR=black><B>if</B></FONT> type(t) <FONT COLOR=black><B>is</B></FONT> StringType <FONT COLOR=black><B>and</B></FONT> t <FONT COLOR=black><B>and</B></FONT> t[0] == <FONT COLOR=#FF0000>'+'</FONT>:
                interval = timeDecode(t[1:])
                t = time.time() + interval
            <FONT COLOR=black><B>if</B></FONT> type(t) <FONT COLOR=black><B>in</B></FONT> (IntType, LongType,FloatType):
                t = time.gmtime(t)
            <FONT COLOR=black><B>if</B></FONT> type(t) <FONT COLOR=black><B>in</B></FONT> (TupleType, TimeTupleType):
                t = time.strftime(<FONT COLOR=#FF0000>"%a, %d-%b-%Y %H:%M:%S GMT"</FONT>, t)
            <FONT COLOR=black><B>if</B></FONT> DateTime <FONT COLOR=black><B>and</B></FONT> type(t) <FONT COLOR=black><B>in</B></FONT> \
               (DateTime.DeltaDateTimeType, DateTime.RelativeDateTimeType):
                t = DateTime.now() + t
            <FONT COLOR=black><B>if</B></FONT> DateTime <FONT COLOR=black><B>and</B></FONT> type(t) <FONT COLOR=black><B>is</B></FONT> DateTime.DateTimeType:
                t = t.strftime(<FONT COLOR=#FF0000>"%a, %d-%b-%Y %H:%M:%S GMT"</FONT>)
            cookie.setExpires(t)
        <FONT COLOR=black><B>if</B></FONT> path:
            cookie.setPath(path)
        <FONT COLOR=black><B>if</B></FONT> secure:
            cookie.setSecure(secure)
        self.addCookie(cookie)

    <FONT COLOR=black><B>def</B></FONT> addCookie(self, cookie):
        <FONT COLOR=#FF0000>"""
        Adds a cookie that will be sent with this response.
        cookie is a Cookie object instance.  See WebKit.Cookie.
        """</FONT>
        <FONT COLOR=black><B>assert</B></FONT> self._committed==0
        <FONT COLOR=black><B>assert</B></FONT> isinstance(cookie, Cookie)
        self._cookies[cookie.name()] = cookie

    <FONT COLOR=black><B>def</B></FONT> delCookie(self, name):
        <FONT COLOR=#FF0000>"""
        Deletes a cookie at the browser. To do so, one has
        to create and send to the browser a cookie with
        parameters that will cause the browser to delete it.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> self._cookies.has_key(name):
            self._cookies[name].delete()
        <FONT COLOR=black><B>else</B></FONT>:
            cookie = Cookie(name, None)
            cookie.delete()
            self.addCookie(cookie)

    <FONT COLOR=black><B>def</B></FONT> cookies(self):
        <FONT COLOR=#FF0000>"""
        Returns a dictionary-style object of all Cookie objects that will be sent
        with this response.
        """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._cookies

    <FONT COLOR=black><B>def</B></FONT> clearCookies(self):
        <FONT COLOR=#FF0000>""" Clears all the cookies. """</FONT>
        <FONT COLOR=black><B>assert</B></FONT> self._committed==0
        self._cookies = {}


    <FONT COLOR=#1111CC>## Status ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> setStatus(self, code, msg=<FONT COLOR=#FF0000>''</FONT>):
        <FONT COLOR=#FF0000>""" Set the status code of the response, such as 200, 'OK'. """</FONT>
        <FONT COLOR=black><B>assert</B></FONT> self._committed==0, <FONT COLOR=#FF0000>"Headers already sent."</FONT>
        self.setHeader(<FONT COLOR=#FF0000>'Status'</FONT>, str(code) + <FONT COLOR=#FF0000>' '</FONT> + msg)


    <FONT COLOR=#1111CC>## Special responses ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> sendError(self, code, msg=<FONT COLOR=#FF0000>''</FONT>):
        <FONT COLOR=#FF0000>"""
        Sets the status code to the specified code and message.
        """</FONT>
        <FONT COLOR=black><B>assert</B></FONT> self._committed==0, <FONT COLOR=#FF0000>"Response already partially sent"</FONT>
        self.setStatus(code, msg)

    <FONT COLOR=black><B>def</B></FONT> sendRedirect(self, url):
        <FONT COLOR=#FF0000>"""
        This method sets the headers and content for the redirect, but does
        NOT change the cookies. Use clearCookies() as appropriate.

        @@ 2002-03-21 ce: I thought cookies were ignored by user agents if a
        redirect occurred. We should verify and update code or docs as appropriate.
        """</FONT>
        <FONT COLOR=#1111CC># ftp://ftp.isi.edu/in-notes/rfc2616.txt</FONT>
        <FONT COLOR=#1111CC># Sections: 10.3.3 and others</FONT>

        <FONT COLOR=black><B>assert</B></FONT> self._committed==0, <FONT COLOR=#FF0000>"Headers already sent"</FONT>

        self.setHeader(<FONT COLOR=#FF0000>'Status'</FONT>, <FONT COLOR=#FF0000>'302 Redirect'</FONT>)
        self.setHeader(<FONT COLOR=#FF0000>'Location'</FONT>, url)
        self.setHeader(<FONT COLOR=#FF0000>'Content-type'</FONT>, <FONT COLOR=#FF0000>'text/html'</FONT>)

        self.write(<FONT COLOR=#FF0000>'&lt;html&gt; &lt;body&gt; This page has been redirected to &lt;a href="%s"&gt;%s&lt;/a&gt;. &lt;/body&gt; &lt;/html&gt;'</FONT> % (url, url))


    <FONT COLOR=#1111CC>## Output ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> write(self, charstr=None):
        <FONT COLOR=#FF0000>"""
        Write charstr to the response stream.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> charstr: self._strmOut.write(charstr)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self._committed <FONT COLOR=black><B>and</B></FONT> self._strmOut._needCommit:
            self.commit()

    <FONT COLOR=black><B>def</B></FONT> flush(self, autoFlush=1):
        <FONT COLOR=#FF0000>"""
        Send all accumulated response data now.
        Commits the response headers and tells the underlying stream to flush.
        if autoFlush is 1, the responseStream will flush itself automatically from now on.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self._committed:
            self.commit()
        self._strmOut.flush()
        self._strmOut.autoCommit(1)


    <FONT COLOR=black><B>def</B></FONT> isCommitted(self):
        <FONT COLOR=#FF0000>"""
        Has the reponse already been partially or completely sent?
        If this returns true, no new headers/cookies can be added to the response.
        """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._committed

    <FONT COLOR=black><B>def</B></FONT> deliver(self):
        <FONT COLOR=#FF0000>"""
        The final step in the processing cycle.
        Not used for much with responseStreams added.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"HTTPResponse deliver called"</FONT>
        self.recordEndTime()
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self._committed: self.commit()

    <FONT COLOR=black><B>def</B></FONT> commit(self):
        <FONT COLOR=#FF0000>"""
        Write out all headers to the reponse stream, and tell the underlying
        response stream it can start sending data.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"HTTPResponse commit"</FONT>
        self.recordSession()
        self.writeHeaders()
        self._committed = 1
        self._strmOut.commit()

    <FONT COLOR=black><B>def</B></FONT> writeHeaders(self):
        <FONT COLOR=#FF0000>"""
        Write headers to the response stream.  Used internally.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> self._committed:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"response.writeHeaders called when already committed"</FONT>
            <FONT COLOR=black><B>return</B></FONT>
        headers = []
        headerstring = <FONT COLOR=#FF0000>''</FONT>
        <FONT COLOR=black><B>for</B></FONT> key, value <FONT COLOR=black><B>in</B></FONT> self._headers.items():
            headers.append((key, value))
        <FONT COLOR=black><B>for</B></FONT> cookie <FONT COLOR=black><B>in</B></FONT> self._cookies.values():
            headers.append((<FONT COLOR=#FF0000>'Set-Cookie'</FONT>, cookie.headerValue()))
        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> headers:
            hdrstr = i[0] + <FONT COLOR=#FF0000>': '</FONT> + i[1] + <FONT COLOR=#FF0000>'\r\n'</FONT>
            <FONT COLOR=black><B>if</B></FONT> string.lower(i[0]) == <FONT COLOR=#FF0000>'status'</FONT>:
                headerstring = string.join((hdrstr, headerstring),<FONT COLOR=#FF0000>''</FONT>)
            <FONT COLOR=black><B>else</B></FONT>:
                headerstring = string.join((headerstring, hdrstr),<FONT COLOR=#FF0000>''</FONT>)
        headerstring = string.join((headerstring,<FONT COLOR=#FF0000>'\r\n'</FONT>),<FONT COLOR=#FF0000>''</FONT>)
        self._strmOut.prepend(headerstring)

    <FONT COLOR=black><B>def</B></FONT> recordSession(self):
        <FONT COLOR=#FF0000>""" Invoked by commit() to record the session id in the response (if a session exists). This implementation sets a cookie for that purpose. For people who don't like sweets, a future version could check a setting and instead of using cookies, could parse the HTML and update all the relevant URLs to include the session id (which implies a big performance hit). Or we could require site developers to always pass their URLs through a function which adds the session id (which implies pain). Personally, I'd rather just use cookies. You can experiment with different techniques by subclassing Session and overriding this method. Just make sure Application knows which "session" class to use. """</FONT>
        sess = self._transaction._session
        <FONT COLOR=black><B>if</B></FONT> debug: prefix = <FONT COLOR=#FF0000>'&gt;&gt; recordSession:'</FONT>
        <FONT COLOR=black><B>if</B></FONT> sess:
            cookie = Cookie(<FONT COLOR=#FF0000>'_SID_'</FONT>, sess.identifier())
            cookie.setPath(<FONT COLOR=#FF0000>'/'</FONT>)
            <FONT COLOR=black><B>if</B></FONT> sess.isExpired() <FONT COLOR=black><B>or</B></FONT> sess.timeout() == 0:
                <FONT COLOR=#1111CC># Invalid -- tell client to forget the cookie.</FONT>
                cookie.setMaxAge(0)
                cookie.setExpires(-365*24*60*60)
            self.addCookie(cookie)
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> prefix, <FONT COLOR=#FF0000>'setting sid ='</FONT>, sess.identifier()
        <FONT COLOR=black><B>else</B></FONT>:
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> prefix, <FONT COLOR=#FF0000>'did not set sid'</FONT>

    <FONT COLOR=black><B>def</B></FONT> reset(self):
        <FONT COLOR=#FF0000>"""
        Resets the response (such as headers, cookies and contents).
        """</FONT>

        <FONT COLOR=black><B>assert</B></FONT> self._committed == 0
        self._headers = {}
        self.setHeader(<FONT COLOR=#FF0000>'Content-type'</FONT>,<FONT COLOR=#FF0000>'text/html'</FONT>)
        self._cookies = {}
        self._strmOut.clear()


    <FONT COLOR=black><B>def</B></FONT> rawResponse(self):
        <FONT COLOR=#FF0000>""" Returns the final contents of the response. Don't invoke this method until after deliver().
        Returns a dictionary representing the response containing only strings, numbers, lists, tuples, etc. with no backreferences. That means you don't need any special imports to examine the contents and you can marshal it. Currently there are two keys. 'headers' is list of tuples each of which contains two strings: the header and it's value. 'contents' is a string (that may be binary (for example, if an image were being returned)). """</FONT>

        headers = []
        <FONT COLOR=black><B>for</B></FONT> key, value <FONT COLOR=black><B>in</B></FONT> self._headers.items():
            headers.append((key, value))
        <FONT COLOR=black><B>for</B></FONT> cookie <FONT COLOR=black><B>in</B></FONT> self._cookies.values():
            headers.append((<FONT COLOR=#FF0000>'Set-Cookie'</FONT>, cookie.headerValue()))
        <FONT COLOR=black><B>return</B></FONT> {
            <FONT COLOR=#FF0000>'headers'</FONT>: headers,
            <FONT COLOR=#FF0000>'contents'</FONT>: self._strmOut.buffer()
        }

    <FONT COLOR=black><B>def</B></FONT> size(self):
        <FONT COLOR=#FF0000>"""
        Returns the size of the final contents of the response. Don't invoke this
        method until after deliver().
        """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._strmOut.size()

<FONT COLOR=#1111CC>##  def appendRawResponse(self, rawRes):</FONT>
<FONT COLOR=#1111CC>##      """</FONT>
<FONT COLOR=#1111CC>##      Appends the contents of the raw response (as returned by some transaction's rawResponse() method) to this response.</FONT>
<FONT COLOR=#1111CC>##      The headers of the receiving response take precedence over the appended response.</FONT>
<FONT COLOR=#1111CC>##      This method was built primarily to support Application.forwardRequest().</FONT>
<FONT COLOR=#1111CC>##      """</FONT>
<FONT COLOR=#1111CC>##      assert self._committed==0</FONT>
<FONT COLOR=#1111CC>##      headers = rawRes.get('headers', [])</FONT>
<FONT COLOR=#1111CC>##      for key, value in headers:</FONT>
<FONT COLOR=#1111CC>##          if not self._headers.has_key(key):</FONT>
<FONT COLOR=#1111CC>##              self._headers[key] = value</FONT>
<FONT COLOR=#1111CC>##      self.write(rawRes['contents'])</FONT>

    <FONT COLOR=black><B>def</B></FONT> mergeTextHeaders(self, headerstr):
        <FONT COLOR=#FF0000>"""
        Given a string of headers (separated by newlines), merge them into our headers.
        """</FONT>
        linesep = <FONT COLOR=#FF0000>"\n"</FONT>

        lines = string.split(headerstr,<FONT COLOR=#FF0000>"\n"</FONT>)
        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> lines:
            sep = string.find(i, <FONT COLOR=#FF0000>":"</FONT>)
            <FONT COLOR=black><B>if</B></FONT> sep:
                self.setHeader(i[:sep], string.rstrip(i[sep+1:]))


    <FONT COLOR=#1111CC>## Exception reporting ##</FONT>

    exceptionReportAttrNames = Response.exceptionReportAttrNames + [<FONT COLOR=#FF0000>'committed'</FONT>, <FONT COLOR=#FF0000>'headers'</FONT>, <FONT COLOR=#FF0000>'cookies'</FONT>]
</PRE>
                  <!--footer-->
                  </BODY>
