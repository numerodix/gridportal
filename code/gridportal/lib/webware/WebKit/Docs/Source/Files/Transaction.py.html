<HTML><HEAD><TITLE>WebKit/Transaction.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=black><B>from</B></FONT> Common <FONT COLOR=black><B>import</B></FONT> *
<FONT COLOR=black><B>from</B></FONT> WebUtils.Funcs <FONT COLOR=black><B>import</B></FONT> htmlEncode
<FONT COLOR=black><B>import</B></FONT> traceback


<FONT COLOR=black><B>class</B></FONT> Transaction(Object):
    <FONT COLOR=#FF0000>"""
    A transaction serves as:

        * A container for all objects involved in the transaction. The
          objects include application, request, response, session and
          servlet.

        * A message dissemination point. The messages include awake(),
          respond() and sleep().

    When first created, a transaction has no session. However, it will
    create or retrieve one upon being asked for session().

    The life cycle of a transaction begins and ends with Application's
    dispatchRequest().
    """</FONT>


    <FONT COLOR=#1111CC>## Init ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, application, request=None):
        Object.__init__(self)
        self._application   = application
        self._request       = request
        self._response      = None
        self._session       = None
        self._servlet       = None
        self._errorOccurred = 0

    attrNames = <FONT COLOR=#FF0000>'application request response session servlet errorOccurred'</FONT>.split()

    <FONT COLOR=black><B>def</B></FONT> __repr__(self):
        s = []
        <FONT COLOR=black><B>for</B></FONT> name <FONT COLOR=black><B>in</B></FONT> self.attrNames:
            s.append(<FONT COLOR=#FF0000>'%s=%r'</FONT> % (name, getattr(self, <FONT COLOR=#FF0000>'_'</FONT>+name, <FONT COLOR=#FF0000>'(no attr)'</FONT>)))
        s = <FONT COLOR=#FF0000>' '</FONT>.join(s)
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>'&lt;%s %s&gt;'</FONT> % (self.__class__.__name__, s)


    <FONT COLOR=#1111CC>## Access ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> application(self):
        <FONT COLOR=black><B>return</B></FONT> self._application

    <FONT COLOR=black><B>def</B></FONT> request(self):
        <FONT COLOR=black><B>return</B></FONT> self._request

    <FONT COLOR=black><B>def</B></FONT> response(self):
        <FONT COLOR=black><B>return</B></FONT> self._response

    <FONT COLOR=black><B>def</B></FONT> setResponse(self, response):
        self._response = response

    <FONT COLOR=black><B>def</B></FONT> hasSession(self):
        <FONT COLOR=#FF0000>""" Returns true if the transaction has a session. """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._session <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None

    <FONT COLOR=black><B>def</B></FONT> session(self):
        <FONT COLOR=#FF0000>""" Returns the session for the transaction, creating one if necessary. Therefore, this method never returns None. Use hasSession() if you want to find out if there one already exists. """</FONT>
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self._session:
            self._session = self._application.createSessionForTransaction(self)
        <FONT COLOR=black><B>return</B></FONT> self._session

    <FONT COLOR=black><B>def</B></FONT> setSession(self, session):
        self._session = session

    <FONT COLOR=black><B>def</B></FONT> servlet(self):
        <FONT COLOR=#FF0000>""" Return the current servlet that is processing. Remember that servlets can be nested. """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._servlet

    <FONT COLOR=black><B>def</B></FONT> setServlet(self, servlet):
        self._servlet = servlet

    <FONT COLOR=black><B>def</B></FONT> duration(self):
        <FONT COLOR=#FF0000>""" Returns the duration, in seconds, of the transaction (basically response end time minus request start time). """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._response.endTime() - self._request.time()

    <FONT COLOR=black><B>def</B></FONT> errorOccurred(self):
        <FONT COLOR=black><B>return</B></FONT> self._errorOccurred

    <FONT COLOR=black><B>def</B></FONT> setErrorOccurred(self, flag):
        <FONT COLOR=#FF0000>""" Invoked by the application if an exception is raised to the application level. """</FONT>
        self._errorOccurred = flag
        <FONT COLOR=#1111CC>#self._servlet = None</FONT>
        <FONT COLOR=#1111CC># @@ 2002-02-05 ce: disabled above statement so that custom exception handlers can examine the servlet</FONT>


    <FONT COLOR=#1111CC>## Transaction stages ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> awake(self):
        <FONT COLOR=#FF0000>""" Sends awake() the to session (if there is one) and the servlet. Currently, the request and response do not partake in the awake()-respond()-sleep() cycle. This could definitely be added in the future if any use was demonstrated for it. """</FONT>
        <FONT COLOR=black><B>if</B></FONT> self._session:
            self._session.awake(self)
        self._servlet.awake(self)

    <FONT COLOR=black><B>def</B></FONT> respond(self):
        <FONT COLOR=black><B>if</B></FONT> self._session:
            self._session.respond(self)
        self._servlet.respond(self)

    <FONT COLOR=black><B>def</B></FONT> sleep(self):
        <FONT COLOR=#FF0000>""" Note that sleep() is sent in reverse order as awake() (which is typical for shutdown/cleanup methods). """</FONT>
        self._servlet.sleep(self)
        <FONT COLOR=black><B>if</B></FONT> self._session:
            self._session.sleep(self)


    <FONT COLOR=#1111CC>## Debugging ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> dump(self, file=None):
        <FONT COLOR=#FF0000>""" Dumps debugging info to stdout. """</FONT>
        <FONT COLOR=black><B>if</B></FONT> file <FONT COLOR=black><B>is</B></FONT> None:
            file = sys.stdout
        wr = file.write
        wr(<FONT COLOR=#FF0000>'&gt;&gt; Transaction: %s\n'</FONT> % self)
        <FONT COLOR=black><B>for</B></FONT> attr <FONT COLOR=black><B>in</B></FONT> dir(self):
            wr(<FONT COLOR=#FF0000>'%s: %s\n'</FONT> % (attr, getattr(self, attr)))
        wr(<FONT COLOR=#FF0000>'\n'</FONT>)


    <FONT COLOR=#1111CC>## Die ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> die(self):
        <FONT COLOR=#FF0000>""" This method should be invoked when the entire transaction is finished with. Currently, this is invoked by AppServer. This method removes references to the different objects in the transaction, breaking cyclic reference chains and allowing either older versions of Python to collect garbage, or newer versions to collect it faster. """</FONT>
        <FONT COLOR=black><B>from</B></FONT> types <FONT COLOR=black><B>import</B></FONT> InstanceType
        <FONT COLOR=black><B>for</B></FONT> attrName <FONT COLOR=black><B>in</B></FONT> self.__dict__.keys():
            <FONT COLOR=#1111CC># @@ 2000-05-21 ce: there's got to be a better way!</FONT>
            attr = getattr(self, attrName)
            <FONT COLOR=black><B>if</B></FONT> type(attr) <FONT COLOR=black><B>is</B></FONT> InstanceType <FONT COLOR=black><B>and</B></FONT> hasattr(attr, <FONT COLOR=#FF0000>'resetKeyBindings'</FONT>):
                <FONT COLOR=#1111CC>#print </FONT><FONT COLOR=#FF0000>'&gt;&gt; resetting'</FONT>
                attr.resetKeyBindings()
            delattr(self, attrName)


    <FONT COLOR=#1111CC>## Exception handling ##</FONT>

    exceptionReportAttrNames = <FONT COLOR=#FF0000>'application request response session servlet'</FONT>.split()

    <FONT COLOR=black><B>def</B></FONT> writeExceptionReport(self, handler):
        handler.writeTitle(self.__class__.__name__)
        handler.writeAttrs(self, self.exceptionReportAttrNames)

        <FONT COLOR=black><B>for</B></FONT> name <FONT COLOR=black><B>in</B></FONT> self.exceptionReportAttrNames:
            obj = getattr(self, <FONT COLOR=#FF0000>'_'</FONT>+name, None)
            <FONT COLOR=black><B>if</B></FONT> obj:
                <FONT COLOR=black><B>try</B></FONT>:
                    obj.writeExceptionReport(handler)
                <FONT COLOR=black><B>except</B></FONT> Exception, e:
                    handler.writeln(<FONT COLOR=#FF0000>'&lt;p&gt; Uncaught exception while asking &lt;b&gt;%s&lt;/b&gt; to write report:\n&lt;pre&gt;'</FONT> % name)
                    traceback.print_exc(file=handler)
                    handler.writeln(<FONT COLOR=#FF0000>'&lt;/pre&gt;'</FONT>)
</PRE>
                  <!--footer-->
                  </BODY>
