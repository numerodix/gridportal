<HTML><HEAD><TITLE>WebKit/ServletFactory.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=black><B>from</B></FONT> Common <FONT COLOR=black><B>import</B></FONT> *
<FONT COLOR=black><B>from</B></FONT> WebKit.Servlet <FONT COLOR=black><B>import</B></FONT> Servlet
<FONT COLOR=black><B>import</B></FONT> sys
<FONT COLOR=black><B>from</B></FONT> types <FONT COLOR=black><B>import</B></FONT> ClassType, BuiltinFunctionType
<FONT COLOR=black><B>import</B></FONT> ImportSpy as imp   <FONT COLOR=#1111CC># ImportSpy provides find_module and load_module</FONT>
<FONT COLOR=black><B>import</B></FONT> threading


<FONT COLOR=black><B>class</B></FONT> ServletFactory(Object):
    <FONT COLOR=#FF0000>"""
    ServletFactory is an abstract class that defines the protocol for all servlet factories.

    Servlet factories are used by the Application to create servlets for transactions.

    A factory must inherit from this class and override uniqueness(), extensions() and servletForTransaction(). Do not invoke the base class methods as they all raise AbstractErrors.

    Each method is documented below.
    """</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, application):
        <FONT COLOR=#FF0000>""" Stores a reference to the application in self._app, because subclasses may or may not need to talk back to the application to do their work. """</FONT>
        Object.__init__(self)
        self._app = application
        self._cacheClasses = self._app.setting(<FONT COLOR=#FF0000>"CacheServletClasses"</FONT>,1)

    <FONT COLOR=black><B>def</B></FONT> name(self):
        <FONT COLOR=#FF0000>""" Returns the name of the factory. This is a convenience for the class name. """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self.__class__.__name__

    <FONT COLOR=black><B>def</B></FONT> uniqueness(self):
        <FONT COLOR=#FF0000>""" Returns a string to indicate the uniqueness of the ServletFactory's servlets. The Application needs to know if the servlets are unique per file, per extension or per application. Return values are 'file', 'extension' and 'application'.
            *** NOTE: Application only supports 'file' uniqueness at this point in time. """</FONT>
        <FONT COLOR=black><B>raise</B></FONT> AbstractError, self.__class__

    <FONT COLOR=black><B>def</B></FONT> extensions(self):
        <FONT COLOR=#FF0000>""" Return a list of extensions that match this handler. Extensions should include the dot. An empty string indicates a file with no extension and is a valid value. The extension '.*' is a special case that is looked for a URL's extension doesn't match anything. """</FONT>
        <FONT COLOR=black><B>raise</B></FONT> AbstractError, self.__class__

    <FONT COLOR=black><B>def</B></FONT> servletForTransaction(self, transaction):
        <FONT COLOR=#FF0000>""" Returns a new servlet that will handle the transaction. This method should do no caching (e.g., it should really create the servlet upon each invocation) since caching is already done at the Application level. """</FONT>
        <FONT COLOR=black><B>raise</B></FONT> AbstractError, self.__class__

    <FONT COLOR=black><B>def</B></FONT> flushCache(self):
        <FONT COLOR=#FF0000>"""
        Clear any caches and start fesh.
        """</FONT>
        <FONT COLOR=black><B>raise</B></FONT> AbstractError, self.__class__


    <FONT COLOR=black><B>def</B></FONT> importAsPackage(self, transaction, serverSidePathToImport):
        <FONT COLOR=#FF0000>"""
        Imports the module at the given path in the proper package/subpackage for the current request.  For example, if the
        transaction has the URL 'http://localhost/WebKit.cgi/MyContextDirectory/MySubdirectory/MyPage' and
        path = 'some/random/path/MyModule.py' and the context is configured to have the name "MyContext" then this function
        imports the module at that path as MyContext.MySubdirectory.MyModule .  Note that the context name may differ
        from the name of the directory containing the context, even though they are usually the same by convention.

        Note that the module imported may have a different name from the servlet name specified in the URL.  This is used in PSP.
        """</FONT>
        debug=0

        <FONT COLOR=#1111CC># Pull out the full server side path and the context path</FONT>
        request = transaction.request()
        path = request.serverSidePath()
        contextPath = request.serverSideContextPath()
        fullname = request.contextName()

        <FONT COLOR=#1111CC>## There is no context, so import the module standalone and give it a unique name</FONT>
        <FONT COLOR=black><B>if</B></FONT> fullname == None:
            remainder = serverSidePathToImport
            remainder = string.replace(remainder, <FONT COLOR=#FF0000>'\\'</FONT>, <FONT COLOR=#FF0000>'_'</FONT>)
            remainder = string.replace(remainder, <FONT COLOR=#FF0000>'/'</FONT>,<FONT COLOR=#FF0000>'_'</FONT>)
            fullmodname = string.replace(remainder,<FONT COLOR=#FF0000>'.'</FONT>,<FONT COLOR=#FF0000>'_'</FONT>)
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> __file__, <FONT COLOR=#FF0000>"fullmodname="</FONT>,fullmodname
            <FONT COLOR=black><B>if</B></FONT> len(fullmodname) &gt; 100: fullmodname=fullmodname[:-50]
            modname=os.path.splitext(os.path.basename(serverSidePathToImport))[0]
            fp, pathname, stuff = imp.find_module(modname, [os.path.dirname(serverSidePathToImport)])
            module = imp.load_module(fullmodname, fp, pathname, stuff)
            <FONT COLOR=black><B>return</B></FONT> module


        <FONT COLOR=#1111CC># First, we'll import the context's package.</FONT>
        directory, contextDirName = os.path.split(contextPath)
        self._importModuleFromDirectory(fullname, contextDirName, directory, isPackageDir=1)
        directory = contextPath

        <FONT COLOR=#1111CC># Now we'll break up the rest of the path into components.</FONT>
        remainder = path[len(contextPath)+1:]
        remainder = string.replace(remainder, <FONT COLOR=#FF0000>'\\'</FONT>, <FONT COLOR=#FF0000>'/'</FONT>)
        remainder = string.split(remainder, <FONT COLOR=#FF0000>'/'</FONT>)

        <FONT COLOR=#1111CC># Import all subpackages of the context package</FONT>
        <FONT COLOR=black><B>for</B></FONT> name <FONT COLOR=black><B>in</B></FONT> remainder[:-1]:
            fullname = fullname + <FONT COLOR=#FF0000>'.'</FONT> + name
            self._importModuleFromDirectory(fullname, name, directory, isPackageDir=1)
            directory = os.path.join(directory, name)

        <FONT COLOR=#1111CC># Finally, import the module itself as though it was part of the package</FONT>
        <FONT COLOR=#1111CC># or subpackage, even though it may be located somewhere else.</FONT>
        moduleFileName = os.path.basename(serverSidePathToImport)
        moduleDir = os.path.dirname(serverSidePathToImport)
        name, ext = os.path.splitext(moduleFileName)
        fullname = fullname + <FONT COLOR=#FF0000>'.'</FONT> + name
        module = self._importModuleFromDirectory(fullname, name, moduleDir, forceReload=1)
        <FONT COLOR=black><B>return</B></FONT> module

    <FONT COLOR=black><B>def</B></FONT> _importModuleFromDirectory(self, fullModuleName, moduleName, directory, isPackageDir=0, forceReload=0):
        <FONT COLOR=#FF0000>"""
        Imports the given module from the given directory.  fullModuleName should be the full
        dotted name that will be given to the module within Python.  moduleName should be the
        name of the module in the filesystem, which may be different from the name given in
        fullModuleName.  Returns the module object.  If forceReload is true then this reloads the module
        even if it has already been imported.

        If isPackageDir is true, then this function creates an empty __init__.py
        if that file doesn't already exist.
        """</FONT>
        debug = 0
        <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> __file__, fullModuleName, moduleName, directory
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> forceReload:
            module = sys.modules.get(fullModuleName, None)
            <FONT COLOR=black><B>if</B></FONT> module <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None:
                <FONT COLOR=black><B>return</B></FONT> module
        fp = None
        <FONT COLOR=black><B>try</B></FONT>:
            <FONT COLOR=black><B>if</B></FONT> isPackageDir:
                <FONT COLOR=#1111CC># Check if __init__.py is in the directory -- if not, make an empty one.</FONT>
                packageDir = os.path.join(directory, moduleName)
                initPy = os.path.join(packageDir, <FONT COLOR=#FF0000>'__init__.py'</FONT>)
                <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> os.path.exists(initPy):
                    file = open(initPy, <FONT COLOR=#FF0000>'w'</FONT>)
                    file.write(<FONT COLOR=#FF0000>'#'</FONT>)
                    file.close()
            fp, pathname, stuff = imp.find_module(moduleName, [directory])
            module = imp.load_module(fullModuleName, fp, pathname, stuff)
        <FONT COLOR=black><B>finally</B></FONT>:
            <FONT COLOR=black><B>if</B></FONT> fp <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None:
                fp.close()
        <FONT COLOR=black><B>return</B></FONT> module

<FONT COLOR=black><B>class</B></FONT> PythonServletFactory(ServletFactory):
    <FONT COLOR=#FF0000>"""
    This is the factory for ordinary, Python servlets whose extensions are empty or .py. The servlets are unique per file since the file itself defines the servlet.
    """</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self,app):
        ServletFactory.__init__(self,app)
        self._cache = {}
        self._lock = threading.RLock()

    <FONT COLOR=black><B>def</B></FONT> uniqueness(self):
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>'file'</FONT>

    <FONT COLOR=black><B>def</B></FONT> extensions(self):
        <FONT COLOR=black><B>return</B></FONT> [<FONT COLOR=#FF0000>'.py'</FONT>]

    <FONT COLOR=black><B>def</B></FONT> flushCache(self):
        self._cache = {}

<FONT COLOR=#1111CC>#   def old_servletForTransaction(self, transaction):</FONT>
<FONT COLOR=#1111CC>#       path = transaction.request().serverSidePath()</FONT>
<FONT COLOR=#1111CC>#       globals = {}</FONT>
<FONT COLOR=#1111CC>#       execfile(path, globals)</FONT>
<FONT COLOR=#1111CC>#       from types import ClassType</FONT>
<FONT COLOR=#1111CC>#       name = os.path.splitext(os.path.split(path)[1])[0]</FONT>
<FONT COLOR=#1111CC>#       assert globals.has_key(name), 'Cannot find expected servlet class named "%s".' % name</FONT>
<FONT COLOR=#1111CC>#       theClass = globals[name]</FONT>
<FONT COLOR=#1111CC>#       assert type(theClass) is ClassType</FONT>
<FONT COLOR=#1111CC>#       assert issubclass(theClass, Servlet)</FONT>
<FONT COLOR=#1111CC>#       return theClass()</FONT>

    <FONT COLOR=black><B>def</B></FONT> servletForTransaction(self, transaction):
        request = transaction.request()
        path = request.serverSidePath()
        name = os.path.splitext(os.path.split(path)[1])[0]
        <FONT COLOR=#1111CC># Use a lock to prevent multiple simultaneous imports of the same module</FONT>
        self._lock.acquire()
        <FONT COLOR=black><B>try</B></FONT>:
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self._cache.has_key(path):
                self._cache[path] = {}
            <FONT COLOR=black><B>if</B></FONT> os.path.getmtime(path) &gt; self._cache[path].get(<FONT COLOR=#FF0000>'mtime'</FONT>, 0):
                <FONT COLOR=#1111CC># Import the module as part of the context's package</FONT>
                module = self.importAsPackage(transaction, path)
                <FONT COLOR=black><B>assert</B></FONT> module.__dict__.has_key(name), <FONT COLOR=#FF0000>'Cannot find expected servlet class named %s in %s.'</FONT> % (repr(name), repr(path))
                <FONT COLOR=#1111CC># Pull the servlet class out of the module</FONT>
                theClass = getattr(module, name)
                <FONT COLOR=#1111CC># new-style classes aren't ClassType, but they</FONT>
                <FONT COLOR=#1111CC># are okay to use.  They are subclasses of</FONT>
                <FONT COLOR=#1111CC># type.  But type isn't a class in older</FONT>
                <FONT COLOR=#1111CC># Python versions, it's a builtin function.</FONT>
                <FONT COLOR=#1111CC># So we test what type is first, then use</FONT>
                <FONT COLOR=#1111CC># isinstance only for the newer Python</FONT>
                <FONT COLOR=#1111CC># versions</FONT>
                <FONT COLOR=black><B>if</B></FONT> type(type) <FONT COLOR=black><B>is</B></FONT> BuiltinFunctionType:
                    <FONT COLOR=black><B>assert</B></FONT> type(theClass) <FONT COLOR=black><B>is</B></FONT> ClassType
                <FONT COLOR=black><B>else</B></FONT>:
                    <FONT COLOR=black><B>assert</B></FONT> type(theClass) <FONT COLOR=black><B>is</B></FONT> ClassType \
                           <FONT COLOR=black><B>or</B></FONT> isinstance(theClass, type)
                <FONT COLOR=black><B>assert</B></FONT> issubclass(theClass, Servlet)
                self._cache[path][<FONT COLOR=#FF0000>'mtime'</FONT>] = os.path.getmtime(path)
                self._cache[path][<FONT COLOR=#FF0000>'class'</FONT>] = theClass
            <FONT COLOR=black><B>else</B></FONT>:
                theClass = self._cache[path][<FONT COLOR=#FF0000>'class'</FONT>]
                <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self._cacheClasses:
                    <FONT COLOR=black><B>del</B></FONT> self._cache[path]
            <FONT COLOR=black><B>return</B></FONT> theClass()
        <FONT COLOR=black><B>finally</B></FONT>:
            self._lock.release()

<FONT COLOR=#1111CC>#   def import_servletForTransaction(self, transaction):</FONT>
<FONT COLOR=#1111CC>#       path = transaction.request().serverSidePath()</FONT>
<FONT COLOR=#1111CC>#       name = os.path.splitext(os.path.split(path)[1])[0]</FONT>
<FONT COLOR=#1111CC>#       if not self.cache.has_key(name): self.cache[name]={}</FONT>
<FONT COLOR=#1111CC>#       if os.path.getmtime(path) &gt; self.cache[name].get('mtime',0):</FONT>
<FONT COLOR=#1111CC>#           if not os.path.split(path)[0] in sys.path: sys.path.append(os.path.split(path[0]))</FONT>
<FONT COLOR=#1111CC>#           module_obj=__import__(name)</FONT>
<FONT COLOR=#1111CC>#           reload(module_obj)#force reload</FONT>
<FONT COLOR=#1111CC>#           inst =  module_obj.__dict__[name]()</FONT>
<FONT COLOR=#1111CC>#           self.cache[name]['mtime']=os.path.getmtime(path)</FONT>
<FONT COLOR=#1111CC>#       else:</FONT>
<FONT COLOR=#1111CC>#           inst = sys.modules[name].__dict__[name]()</FONT>
<FONT COLOR=#1111CC>#       return inst</FONT>
</PRE>
                  <!--footer-->
                  </BODY>
