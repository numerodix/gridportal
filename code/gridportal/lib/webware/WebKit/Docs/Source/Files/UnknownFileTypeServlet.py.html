<HTML><HEAD><TITLE>WebKit/UnknownFileTypeServlet.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=black><B>from</B></FONT> ServletFactory <FONT COLOR=black><B>import</B></FONT> ServletFactory
<FONT COLOR=black><B>import</B></FONT> os, mimetypes, time

debug = 0

<FONT COLOR=black><B>class</B></FONT> UnknownFileTypeServletFactory(ServletFactory):
    <FONT COLOR=#FF0000>"""
    This is the factory for files of an unknown type (e.g., not .py .psp, etc).
    """</FONT>

    <FONT COLOR=black><B>def</B></FONT> uniqueness(self):
        <FONT COLOR=black><B>return</B></FONT> <FONT COLOR=#FF0000>'file'</FONT>

    <FONT COLOR=black><B>def</B></FONT> extensions(self):
        <FONT COLOR=black><B>return</B></FONT> [<FONT COLOR=#FF0000>'.*'</FONT>]

    <FONT COLOR=black><B>def</B></FONT> servletForTransaction(self, transaction):
        <FONT COLOR=black><B>return</B></FONT> UnknownFileTypeServlet(transaction.application())

    <FONT COLOR=black><B>def</B></FONT> flushCache(self):
        <FONT COLOR=black><B>pass</B></FONT>


fileCache = {}
    <FONT COLOR=#1111CC># A cache of the files served up by UnknownFileTypeServlet cached by absolute, server side path.</FONT>
    <FONT COLOR=#1111CC># Each content is another dictionary with keys: content, mimeType, mimeEncoding.</FONT>
    <FONT COLOR=#1111CC># Previously, this content was stored directly in the attributes of the UnknownFileTypeServlets, but with that approach subclasses cannot dynamically serve content from different locations.</FONT>

<FONT COLOR=black><B>from</B></FONT> HTTPServlet <FONT COLOR=black><B>import</B></FONT> HTTPServlet
<FONT COLOR=black><B>from</B></FONT> MiscUtils.Configurable <FONT COLOR=black><B>import</B></FONT> Configurable
<FONT COLOR=black><B>class</B></FONT> UnknownFileTypeServlet(HTTPServlet, Configurable):
    <FONT COLOR=#FF0000>"""
    Normally this class is just a "private" utility class for WebKit's
    purposes. However, you may find it useful to subclass on occasion,
    such as when the server side file path is determined by something
    other than a direct correlation to the URL. Here is such an example:


    from WebKit.AppServer import globalAppServer
    from WebKit.UnknownFileTypeServlet import UnknownFileTypeServlet
    import os

    class Image(UnknownFileTypeServlet):

        imageDir = '/var/images'

        def filename(self, trans):
            filename = trans.request().field('i')
            filename = os.path.join(self.imageDir, filename)
            return filename
    """</FONT>

    <FONT COLOR=#1111CC>## Candidates for subclass overrides ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> filename(self, trans):
        <FONT COLOR=#FF0000>"""
        Returns the filename to be served. A subclass could override
        this in order to serve files from other disk locations based
        on some logic.
        """</FONT>
        filename = getattr(self, <FONT COLOR=#FF0000>'_serverSideFilename'</FONT>, None)
        <FONT COLOR=black><B>if</B></FONT> filename <FONT COLOR=black><B>is</B></FONT> None:
            filename = trans.request().serverSidePath()
            self._serverSideFilename = filename  <FONT COLOR=#1111CC># cache it</FONT>
        <FONT COLOR=black><B>return</B></FONT> filename

    <FONT COLOR=black><B>def</B></FONT> shouldCacheContent(self):
        <FONT COLOR=#FF0000>"""
        Returns a boolean that controls whether or not the content served through this servlet is cached. The default behavior is to return the CacheContent setting. Subclasses may override to always True or False, or incorporate some other logic.
        """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self.setting(<FONT COLOR=#FF0000>'CacheContent'</FONT>)


    <FONT COLOR=#1111CC>## Init et al ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, application=None):
        HTTPServlet.__init__(self)
        Configurable.__init__(self)
        <FONT COLOR=black><B>if</B></FONT> application <FONT COLOR=black><B>is</B></FONT> None:
            <FONT COLOR=black><B>from</B></FONT> WebKit.AppServer <FONT COLOR=black><B>import</B></FONT> globalAppServer
            application = globalAppServer.application()
            <FONT COLOR=black><B>assert</B></FONT> application <FONT COLOR=black><B>is</B></FONT> <FONT COLOR=black><B>not</B></FONT> None
        self._application = application

    <FONT COLOR=black><B>def</B></FONT> userConfig(self):
        <FONT COLOR=#FF0000>""" Get the user config from the 'UnknownFileTypes' section in the Application's configuration. """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._application.setting(<FONT COLOR=#FF0000>'UnknownFileTypes'</FONT>)

    <FONT COLOR=black><B>def</B></FONT> configFilename(self):
        <FONT COLOR=black><B>return</B></FONT> self._application.configFilename()

    <FONT COLOR=black><B>def</B></FONT> canBeReused(self):
        <FONT COLOR=black><B>return</B></FONT> self.setting(<FONT COLOR=#FF0000>'ReuseServlets'</FONT>)

    <FONT COLOR=black><B>def</B></FONT> validTechniques(self):
        <FONT COLOR=black><B>return</B></FONT> [<FONT COLOR=#FF0000>'serveContent'</FONT>, <FONT COLOR=#FF0000>'redirectSansAdapter'</FONT>]

    <FONT COLOR=black><B>def</B></FONT> respondToGet(self, trans):
        <FONT COLOR=#FF0000>""" Responds to the transaction by invoking self.foo() for foo is specified by the 'Technique' setting. """</FONT>
        technique = self.setting(<FONT COLOR=#FF0000>'Technique'</FONT>)
        <FONT COLOR=black><B>assert</B></FONT> technique <FONT COLOR=black><B>in</B></FONT> self.validTechniques(), <FONT COLOR=#FF0000>'technique = %s'</FONT> % technique
        method = getattr(self, technique)
        method(trans)

    respondToHead = respondToGet

    <FONT COLOR=black><B>def</B></FONT> respondToPost(self, trans):
        <FONT COLOR=#FF0000>"""
        Invokes self.respondToGet().
        Since posts are usually accompanied by data, this might not be the best policy. However, a POST would most likely be for a CGI, which currently no one is mixing in with their WebKit-based web sites.
        """</FONT>
        <FONT COLOR=#1111CC># @@ 2001-01-25 ce: See doc string for why this might be a bad idea.</FONT>
        self.respondToGet(trans)

    <FONT COLOR=black><B>def</B></FONT> redirectSansAdapter(self, trans):
        <FONT COLOR=#FF0000>""" Sends a redirect to a URL that doesn't contain the adapter name. Under the right configuration, this will cause the web server to then be responsible for the URL rather than the app server. This has only been test with "*.[f]cgi" adapters.
        Keep in mind that links off the target page will NOT include the adapter in the URL. """</FONT>
        <FONT COLOR=#1111CC># @@ 2000-05-08 ce: the following is horribly CGI specific and hacky</FONT>
        env = trans.request()._environ
        <FONT COLOR=#1111CC># @@ 2001-01-25 ce: isn't there a func in WebUtils to get script name? because some servers are different?</FONT>
        newURL = os.path.split(env[<FONT COLOR=#FF0000>'SCRIPT_NAME'</FONT>])[0] + env[<FONT COLOR=#FF0000>'PATH_INFO'</FONT>]
        newURL = newURL.replace(<FONT COLOR=#FF0000>'//'</FONT>, <FONT COLOR=#FF0000>'/'</FONT>)  <FONT COLOR=#1111CC># hacky</FONT>
        trans.response().sendRedirect(newURL)


    <FONT COLOR=black><B>def</B></FONT> serveContent(self, trans):
        response = trans.response()

        <FONT COLOR=#1111CC># @@ temp variables, move to config</FONT>
        MaxCacheContentSize = 128*1024
        ReadBufferSize = 32*1024

        <FONT COLOR=#1111CC>#start sending automatically</FONT>
        response.streamOut().autoCommit(1)

        filename = self.filename(trans)
        file = fileCache.get(filename, None)
        <FONT COLOR=black><B>if</B></FONT> file <FONT COLOR=black><B>is</B></FONT> None:
            fileSize = os.path.getsize(filename)
        <FONT COLOR=black><B>else</B></FONT>:
            fileSize = file[<FONT COLOR=#FF0000>'size'</FONT>]

        isHead = trans.request().method().upper()[0]==<FONT COLOR=#FF0000>'H'</FONT> <FONT COLOR=#1111CC># as in HEAD</FONT>
        <FONT COLOR=black><B>if</B></FONT> isHead:
            response.setHeader(<FONT COLOR=#FF0000>'Content-Length'</FONT>, str(fileSize))
            mtime = os.path.getmtime(filename)
            response.setHeader(<FONT COLOR=#FF0000>'Last-Modified'</FONT>,
                time.strftime(<FONT COLOR=#FF0000>'%a, %d %b %Y %H:%M:%S GMT'</FONT>,
                time.gmtime(mtime)))

        <FONT COLOR=black><B>if</B></FONT> debug:
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; UnknownFileType.serveContent()'</FONT>
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; filename ='</FONT>, filename
        <FONT COLOR=black><B>if</B></FONT> file <FONT COLOR=black><B>is</B></FONT> None:
            <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; reading file'</FONT>
            fileType = mimetypes.guess_type(filename)
            mimeType = fileType[0]
            mimeEncoding = fileType[1]

            <FONT COLOR=black><B>if</B></FONT> mimeType <FONT COLOR=black><B>is</B></FONT> None:
                mimeType = <FONT COLOR=#FF0000>'text/html'</FONT>  <FONT COLOR=#1111CC># @@ 2000-01-27 ce: should this just be text?</FONT>
            response.setHeader(<FONT COLOR=#FF0000>'Content-type'</FONT>, mimeType)
            <FONT COLOR=black><B>if</B></FONT> mimeEncoding:
                response.setHeader(<FONT COLOR=#FF0000>'Content-encoding'</FONT>, mimeEncoding)

            <FONT COLOR=black><B>if</B></FONT> self.setting(<FONT COLOR=#FF0000>'ReuseServlets'</FONT>) <FONT COLOR=black><B>and</B></FONT> self.shouldCacheContent() <FONT COLOR=black><B>and</B></FONT> fileSize&lt;MaxCacheContentSize:
                <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; caching'</FONT>
                file = {
                    <FONT COLOR=#FF0000>'content'</FONT>:      open(filename, <FONT COLOR=#FF0000>"rb"</FONT>).read(),
                    <FONT COLOR=#FF0000>'mimeType'</FONT>:     mimeType,
                    <FONT COLOR=#FF0000>'mimeEncoding'</FONT>: mimeEncoding,
                    <FONT COLOR=#FF0000>'mtime'</FONT>:        os.path.getmtime(filename),
                    <FONT COLOR=#FF0000>'size'</FONT>:         os.path.getsize(filename),
                    <FONT COLOR=#FF0000>'filename'</FONT>:     filename,
                }
                fileCache[filename] = file
                <FONT COLOR=black><B>if</B></FONT> isHead:
                    <FONT COLOR=black><B>return</B></FONT>
                response.write(file[<FONT COLOR=#FF0000>'content'</FONT>])
            <FONT COLOR=black><B>else</B></FONT>:  <FONT COLOR=#1111CC># too big or not supposed to cache</FONT>
                <FONT COLOR=black><B>if</B></FONT> isHead:
                    <FONT COLOR=black><B>return</B></FONT>
                f = open(filename, <FONT COLOR=#FF0000>"rb"</FONT>)
                numBytesSent = 0
                <FONT COLOR=black><B>while</B></FONT> numBytesSent&lt;fileSize:
                    data = f.read(ReadBufferSize)
                    response.write(data)
                    numBytesSent += len(data)
        <FONT COLOR=black><B>else</B></FONT>:  <FONT COLOR=#1111CC># We already have the file cached in memory</FONT>
            <FONT COLOR=black><B>if</B></FONT> self.setting(<FONT COLOR=#FF0000>'CheckDate'</FONT>):
                <FONT COLOR=#1111CC># check the date and re-read if necessary</FONT>
                actual_mtime = os.path.getmtime(filename)
                <FONT COLOR=black><B>if</B></FONT> actual_mtime&gt;file[<FONT COLOR=#FF0000>'mtime'</FONT>]:
                    <FONT COLOR=black><B>if</B></FONT> debug: <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>'&gt;&gt; reading updated file'</FONT>
                    file[<FONT COLOR=#FF0000>'content'</FONT>] = open(filename, <FONT COLOR=#FF0000>'rb'</FONT>).read()
                    file[<FONT COLOR=#FF0000>'mtime'</FONT>]   = actual_mtime
            response.setHeader(<FONT COLOR=#FF0000>'Content-type'</FONT>, file[<FONT COLOR=#FF0000>'mimeType'</FONT>])
            <FONT COLOR=black><B>if</B></FONT> file.get(<FONT COLOR=#FF0000>'mimeEncoding'</FONT>):
                response.setHeader(<FONT COLOR=#FF0000>'Content-encoding'</FONT>, file[<FONT COLOR=#FF0000>'mimeEncoding'</FONT>])
            <FONT COLOR=black><B>if</B></FONT> isHead:
                <FONT COLOR=black><B>return</B></FONT>
            response.write(file[<FONT COLOR=#FF0000>'content'</FONT>])
</PRE>
                  <!--footer-->
                  </BODY>
