<HTML><HEAD><TITLE>TaskKit/Scheduler.py</TITLE></HEAD>
                  <BODY BGCOLOR=#EEEEEE>
                  <!--header-->
                  <!--script--><PRE>
<FONT COLOR=#FF0000>"""
This is the TaskManager python package.  It provides a system for running any number of
predefined tasks in separate threads in an organized and controlled manner.

A task in this package is a class derived from the Task class.  The task should have a run
method that, when called, performs some task.

The Scheduler class is the organizing object.  It manages the addition, execution, deletion,
and well being of a number of tasks.  Once you have created your task class, you call the Scheduler to
get it added to the tasks to be run.

"""</FONT>



<FONT COLOR=black><B>from</B></FONT> threading <FONT COLOR=black><B>import</B></FONT> Thread, Event
<FONT COLOR=black><B>from</B></FONT> TaskHandler <FONT COLOR=black><B>import</B></FONT> TaskHandler
<FONT COLOR=black><B>from</B></FONT> time <FONT COLOR=black><B>import</B></FONT> time, sleep
<FONT COLOR=black><B>from</B></FONT> exceptions <FONT COLOR=black><B>import</B></FONT> IOError

<FONT COLOR=black><B>class</B></FONT> Scheduler(Thread):
    <FONT COLOR=#FF0000>"""
    The top level class of the TaskManager system.  The Scheduler is a thread that 
    handles organizing and running tasks.  The Sheduler class should be instantiated 
    to start a TaskManager sessions.  It's run method should be called to start the 
    TaskManager.  It's stop method should be called to end the TaskManager session.
    """</FONT>

    <FONT COLOR=#1111CC>## Init ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> __init__(self, daemon=1):
        Thread.__init__(self)
        self._notifyEvent = Event()
        self._nextTime = None
        self._scheduled = {}
        self._running = {}
        self._onDemand = {}
        self._isRunning = 0
        <FONT COLOR=black><B>if</B></FONT> daemon: self.setDaemon(1)


    <FONT COLOR=#1111CC>## Event Methods ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> wait(self, seconds=None):
        <FONT COLOR=#FF0000>"""
        Our own version of wait.
        When called, it waits for the specified number of seconds, or until it is
        notified that it needs to wake up, through the notify event.
        """</FONT>
        <FONT COLOR=black><B>try</B></FONT>:
            self._notifyEvent.wait(seconds)
        <FONT COLOR=black><B>except</B></FONT> IOError, e:
            <FONT COLOR=black><B>pass</B></FONT>
        self._notifyEvent.clear()


    <FONT COLOR=#1111CC>## Attributes ##</FONT>
    
    <FONT COLOR=black><B>def</B></FONT> runningTasks(self):
        <FONT COLOR=black><B>return</B></FONT> self._running

    <FONT COLOR=black><B>def</B></FONT> running(self, name, default=None):
        <FONT COLOR=#FF0000>"""
        Returns a task with the given name from the "running" list, 
        if it is present there.
        """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._running.get(name, default)
            
    <FONT COLOR=black><B>def</B></FONT> hasRunning(self, name):
        <FONT COLOR=#FF0000>"""
        Check to see if a task with the given name is currently running.
        """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._running.has_key(name)

    <FONT COLOR=black><B>def</B></FONT> setRunning(self, handle):
        <FONT COLOR=#FF0000>"""
        Add a task to the running dictionary.
        Used internally only.
        """</FONT>
        self._running[handle.name()] = handle

    <FONT COLOR=black><B>def</B></FONT> delRunning(self, name):
        <FONT COLOR=#FF0000>"""
        Delete a task from the running list.
        Used Internally.
        """</FONT>
        <FONT COLOR=black><B>try</B></FONT>:
            handle = self._running[name]
            <FONT COLOR=black><B>del</B></FONT> self._running[name]
            <FONT COLOR=black><B>return</B></FONT> handle
        <FONT COLOR=black><B>except</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> None

    <FONT COLOR=black><B>def</B></FONT> scheduledTasks(self):
        <FONT COLOR=black><B>return</B></FONT> self._scheduled

    <FONT COLOR=black><B>def</B></FONT> scheduled(self, name, default=None):
        <FONT COLOR=#FF0000>"""
        Returns a task from the scheduled list.
        """</FONT>         
        <FONT COLOR=black><B>return</B></FONT> self._scheduled.get(name, default)
                    
    <FONT COLOR=black><B>def</B></FONT> hasScheduled(self, name):
        <FONT COLOR=#FF0000>"""
        Is the task with he given name in the scheduled list?
        """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._scheduled.has_key(name)

    <FONT COLOR=black><B>def</B></FONT> setScheduled(self, handle):
        <FONT COLOR=#FF0000>"""
        Add the given task to the scheduled list.
        """</FONT>
        self._scheduled[handle.name()] = handle

    <FONT COLOR=black><B>def</B></FONT> delScheduled(self, name):
        <FONT COLOR=#FF0000>"""
        Deleted a task with the given name from the scheduled list.
        """</FONT>
        <FONT COLOR=black><B>try</B></FONT>:
            handle = self._scheduled[name]
            <FONT COLOR=black><B>del</B></FONT> self._scheduled[name]
            <FONT COLOR=black><B>return</B></FONT> handle
        <FONT COLOR=black><B>except</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> None

    <FONT COLOR=black><B>def</B></FONT> onDemandTasks(self):
        <FONT COLOR=black><B>return</B></FONT> self._onDemand
        
    <FONT COLOR=black><B>def</B></FONT> onDemand(self, name, default=None):
        <FONT COLOR=#FF0000>"""
        Returns a task from the onDemand list.
        """</FONT>
        <FONT COLOR=black><B>return</B></FONT> self._onDemand.get(name, default)

    <FONT COLOR=black><B>def</B></FONT> hasOnDemand(self, name):
        <FONT COLOR=#FF0000>"""
        Is the task with he given name in the onDemand list?
        """</FONT>     
        <FONT COLOR=black><B>return</B></FONT> self._onDemand.has_key(name)

    <FONT COLOR=black><B>def</B></FONT> setOnDemand(self, handle):
        <FONT COLOR=#FF0000>"""
        Add the given task to the onDemand list.
        """</FONT>
        self._onDemand[handle.name()] = handle

    <FONT COLOR=black><B>def</B></FONT> delOnDemand(self, name):
        <FONT COLOR=#FF0000>"""
        Deleted a task with the given name from the onDemand list.
        """</FONT>
        <FONT COLOR=black><B>try</B></FONT>:
            handle = self._onDemand[name]
            <FONT COLOR=black><B>del</B></FONT> self._onDemand[name]
            <FONT COLOR=black><B>return</B></FONT> handle
        <FONT COLOR=black><B>except</B></FONT>:
            <FONT COLOR=black><B>return</B></FONT> None

    <FONT COLOR=black><B>def</B></FONT> nextTime(self):
        <FONT COLOR=black><B>return</B></FONT> self._nextTime

    <FONT COLOR=black><B>def</B></FONT> setNextTime(self, time):
        self._nextTime = time

    <FONT COLOR=black><B>def</B></FONT> isRunning(self):
        <FONT COLOR=black><B>return</B></FONT> self._isRunning


    <FONT COLOR=#1111CC>## Adding Tasks ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> addTimedAction(self, time, task, name):
        <FONT COLOR=#FF0000>"""
        This method is used to add an action to be run once, at a specific time.
        """</FONT>
        handle = self.unregisterTask(name)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> handle:
            handle = TaskHandler(self, time, 0, task, name)
        <FONT COLOR=black><B>else</B></FONT>:
            handle.reset(time, 0, task, 1)
        self.scheduleTask(handle)

    <FONT COLOR=black><B>def</B></FONT> addActionOnDemand(self, task, name):
        <FONT COLOR=#FF0000>"""
        This method is used to add a task to the scheduler that will not be scheduled 
        until specifically requested.
        """</FONT>
        handle = self.unregisterTask(name)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> handle:
            handle = TaskHandler(self, time(), 0, task, name)
        <FONT COLOR=black><B>else</B></FONT>:
            handle.reset(time(), 0, task, 1)
        self.setOnDemand(handle)

    <FONT COLOR=black><B>def</B></FONT> addDailyAction(self, hour, minute, task, name):
        <FONT COLOR=#FF0000>"""     
        This method is used to add an action to be run every day at a specific time.
        If a task with the given name is already registered with the scheduler, that task 
        will be removed from the scheduling queue and registered anew as a periodic task.
            
        Can we make this addCalendarAction?  What if we want to run something once a week?
        We probably don't need that for Webware, but this is a more generally useful module.
        This could be a difficult function, though.  Particularly without mxDateTime.
        """</FONT>
        <FONT COLOR=black><B>import</B></FONT> time
        current = time.localtime(time.time())
        currHour = current[3]
        currMin = current[4]

        <FONT COLOR=#1111CC>#minute difference</FONT>
        <FONT COLOR=black><B>if</B></FONT> minute &gt; currMin:
            minuteDifference = minute - currMin
        <FONT COLOR=black><B>elif</B></FONT> minute &lt; currMin:
            minuteDifference = 60 - currMin + minute
        <FONT COLOR=black><B>else</B></FONT>: <FONT COLOR=#1111CC>#equal</FONT>
            minuteDifference = 0

        <FONT COLOR=#1111CC>#hourDifference</FONT>
        <FONT COLOR=black><B>if</B></FONT> hour &gt; currHour:
            hourDifference = hour - currHour
        <FONT COLOR=black><B>elif</B></FONT> hour &lt; currHour:
            hourDifference = 24 - currHour + hour
        <FONT COLOR=black><B>else</B></FONT>: <FONT COLOR=#1111CC>#equal</FONT>
            hourDifference = 0

        delay = (minuteDifference + (hourDifference * 60)) * 60
        self.addPeriodicAction(time.time()+delay, 24*60*60, task, name)


    <FONT COLOR=black><B>def</B></FONT> addPeriodicAction(self, start, period, task, name):
        <FONT COLOR=#FF0000>"""
        This method is used to add an action to be run at a specific initial time, 
        and every period thereafter.

        The scheduler will not reschedule a task until the last scheduled instance 
        of the task has completed.

        If a task with the given name is already registered with the scheduler, 
        that task will be removed from the scheduling queue and registered
        anew as a periodic task.
        """</FONT>
        
        handle = self.unregisterTask(name)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> handle:
            handle = TaskHandler(self, start, period, task, name)
        <FONT COLOR=black><B>else</B></FONT>:
            handle.reset(start, period, task, 1)
        self.scheduleTask(handle)


    <FONT COLOR=#1111CC>## Task methods ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> unregisterTask(self, name):
        <FONT COLOR=#FF0000>"""
        This method unregisters the named task so that it can be rescheduled with 
        different parameters, or simply removed.
        """</FONT>
        handle = None
        <FONT COLOR=black><B>if</B></FONT> self.hasScheduled(name):
            handle = self.delScheduled(name)
        <FONT COLOR=black><B>if</B></FONT> self.hasOnDemand(name):
            handle = self.delOnDemand(name)
        <FONT COLOR=black><B>if</B></FONT> handle:
            handle.unregister()
        <FONT COLOR=black><B>return</B></FONT> handle

    <FONT COLOR=black><B>def</B></FONT> runTaskNow(self, name):
        <FONT COLOR=#FF0000>"""
        This method is provided to allow a registered task to be immediately executed.
        
        Returns 1 if the task is either currently running or was started, or 0 if the 
        task could not be found in the list of currently registered tasks.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT> self.hasRunning(name):
            <FONT COLOR=black><B>return</B></FONT> 1
        handle = self.scheduled(name)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> handle:
            handle = self.onDemand(name)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> handle:
            <FONT COLOR=black><B>return</B></FONT> 0
        self.runTask(handle)
        <FONT COLOR=black><B>return</B></FONT> 1
    
    <FONT COLOR=black><B>def</B></FONT> demandTask(self, name):
        <FONT COLOR=#FF0000>"""
        This method is provided to allow the server to request that a task listed as being 
        registered on-demand be run as soon as possible.
        
        If the task is currently running, it will be flagged to run again as soon as the 
        current run completes. 

        Returns 0 if the task name could not be found on the on-demand or currently running lists.
        """</FONT>
        <FONT COLOR=black><B>if</B></FONT>  <FONT COLOR=black><B>not</B></FONT> self.hasRunning(name) <FONT COLOR=black><B>and</B></FONT> <FONT COLOR=black><B>not</B></FONT> self.hasOnDemand(name):
            <FONT COLOR=black><B>return</B></FONT> 0
        <FONT COLOR=black><B>else</B></FONT>:
            handle = self.running(name)
            <FONT COLOR=black><B>if</B></FONT> handle:
                handle.runOnCompletion()
                <FONT COLOR=black><B>return</B></FONT> 1
            handle = self.onDemand(name)
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> handle:
                <FONT COLOR=black><B>return</B></FONT> 0            
            self.runTask(handle)
            <FONT COLOR=black><B>return</B></FONT> 1

    <FONT COLOR=black><B>def</B></FONT> stopTask(self, name):
        <FONT COLOR=#FF0000>"""
        This method is provided to put an immediate halt to a running background task.
        
        Returns 1 if the task was either not running, or was running and was told to stop.
        """</FONT>
        handle = self.running(name)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> handle:
            <FONT COLOR=black><B>return</B></FONT> 0
        handle.stop()
        <FONT COLOR=black><B>return</B></FONT> 1


    <FONT COLOR=black><B>def</B></FONT> stopAllTasks(self):
        <FONT COLOR=#FF0000>"""
        Terminate all running tasks.
        """</FONT>
        <FONT COLOR=black><B>for</B></FONT> i <FONT COLOR=black><B>in</B></FONT> self._running.keys():
            <FONT COLOR=black><B>print</B></FONT> <FONT COLOR=#FF0000>"Stopping "</FONT>,i
            self.stopTask(i)

    <FONT COLOR=black><B>def</B></FONT> disableTask(self, name):
        <FONT COLOR=#FF0000>"""
        This method is provided to specify that a task be suspended. Suspended tasks will 
        not be scheduled until later enabled. If the task is currently running, it will 
        not be interfered with, but the task will not be scheduled for execution in future 
        until re-enabled.
        
        Returns 1 if the task was found and disabled.
        """</FONT>
        handle = self.running(name)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> handle:
            handle = self.scheduled(name)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> handle:
            <FONT COLOR=black><B>return</B></FONT> 0
        handle.disable()
        <FONT COLOR=black><B>return</B></FONT> 1

    <FONT COLOR=black><B>def</B></FONT> enableTask(self, name):
        <FONT COLOR=#FF0000>"""
        This method is provided to specify that a task be re-enabled after a suspension.
        A re-enabled task will be scheduled for execution according to its original schedule, 
        with any runtimes that would have been issued during the time the task was suspended 
        simply skipped.

        Returns 1 if the task was found and enabled
        """</FONT>
        
        handle = self.running(name)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> handle:
            handle = self.scheduled(name)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> handle:
            <FONT COLOR=black><B>return</B></FONT> 0
        handle.enable()
        <FONT COLOR=black><B>return</B></FONT> 1

    <FONT COLOR=black><B>def</B></FONT> runTask(self, handle):
        <FONT COLOR=#FF0000>"""
        This method is used by the Scheduler thread's main loop to put a task in 
        the scheduled hash onto the run hash.
        """</FONT>
        name = handle.name()
        <FONT COLOR=black><B>if</B></FONT> self.delScheduled(name) <FONT COLOR=black><B>or</B></FONT> self.delOnDemand(name):
            self.setRunning(handle)
            handle.runTask()

    <FONT COLOR=black><B>def</B></FONT> scheduleTask(self, handle):
        <FONT COLOR=#FF0000>"""
        This method takes a task that needs to be scheduled and adds it to the scheduler. 
        All scheduling additions or changes are handled by this method. This is the only 
        Scheduler method that can notify the run() method that it may need to wake up early 
        to handle a newly registered task.
        """</FONT>
        self.setScheduled(handle)
        <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self.nextTime() <FONT COLOR=black><B>or</B></FONT> handle.startTime() &lt; self.nextTime():
            self.setNextTime(handle.startTime())
            self.notify()


    <FONT COLOR=#1111CC>## Misc Methods ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> notifyCompletion(self, handle):
        <FONT COLOR=#FF0000>"""
        This method is used by instances of TaskHandler to let the Scheduler thread know 
        when their tasks have run to completion.
        This method is responsible for rescheduling the task if it is a periodic task.
        """</FONT>
        name = handle.name()
        <FONT COLOR=black><B>if</B></FONT> self.hasRunning(name):
            self.delRunning(name)
            <FONT COLOR=black><B>if</B></FONT> handle.startTime() <FONT COLOR=black><B>and</B></FONT> handle.startTime() &gt; time():
                self.scheduleTask(handle)
            <FONT COLOR=black><B>else</B></FONT>:
                <FONT COLOR=black><B>if</B></FONT> handle.reschedule():
                    self.scheduleTask(handle)
                <FONT COLOR=black><B>elif</B></FONT> <FONT COLOR=black><B>not</B></FONT> handle.startTime():
                    self.setOnDemand(handle)
                    <FONT COLOR=black><B>if</B></FONT> handle.runAgain():
                        self.runTask(handle)

    <FONT COLOR=black><B>def</B></FONT> notify(self):
        self._notifyEvent.set()

    <FONT COLOR=black><B>def</B></FONT> stop(self):
        <FONT COLOR=#FF0000>"""
        This method terminates the scheduler and its associated tasks.
        """</FONT>
        self._isRunning = 0
        self.notify()
        self.stopAllTasks()
        self.join()  <FONT COLOR=#1111CC># jdh: wait until the scheduler thread exits; otherwise</FONT>
                     <FONT COLOR=#1111CC># it's possible for the interpreter to exit before this thread</FONT>
                     <FONT COLOR=#1111CC># has a chance to shut down completely, which causes a traceback</FONT>


    <FONT COLOR=#1111CC>## Main Method ##</FONT>

    <FONT COLOR=black><B>def</B></FONT> run(self):
        <FONT COLOR=#FF0000>"""
        This method is responsible for carrying out the scheduling work of this class 
        on a background thread. The basic logic is to wait until the next action is due to 
        run, move the task from our scheduled list to our running list, and run it. Other
        synchronized methods such as runTask(), scheduleTask(), and notifyCompletion(), may 
        be called while this method is waiting for something to happen. These methods modify 
        the data structures that run() uses to determine its scheduling needs.
        """</FONT>
        self._isRunning = 1
        <FONT COLOR=black><B>while</B></FONT> 1:
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self._isRunning:
                <FONT COLOR=black><B>return</B></FONT>
            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self.nextTime():
                self.wait()
            <FONT COLOR=black><B>else</B></FONT>:
                nextTime = self.nextTime()
                currentTime = time()
                <FONT COLOR=black><B>if</B></FONT> currentTime &lt; nextTime:
                    sleepTime = nextTime - currentTime
                    self.wait(sleepTime)
                <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> self._isRunning: <FONT COLOR=black><B>return</B></FONT>
                currentTime = time()
                <FONT COLOR=black><B>if</B></FONT> currentTime &gt;= nextTime:
                    toRun = []
                    nextRun = None
                    <FONT COLOR=black><B>for</B></FONT> handle <FONT COLOR=black><B>in</B></FONT> self._scheduled.values():
                        startTime = handle.startTime()
                        <FONT COLOR=black><B>if</B></FONT> startTime &lt;= currentTime:
                            toRun.append(handle)
                        <FONT COLOR=black><B>else</B></FONT>:
                            <FONT COLOR=black><B>if</B></FONT> <FONT COLOR=black><B>not</B></FONT> nextRun:
                                nextRun = startTime
                            <FONT COLOR=black><B>elif</B></FONT> startTime &lt; nextRun:
                                nextRun = startTime
                    self.setNextTime(nextRun)
                    <FONT COLOR=black><B>for</B></FONT> handle <FONT COLOR=black><B>in</B></FONT> toRun:
                        self.runTask(handle)
</PRE>
                  <!--footer-->
                  </BODY>
